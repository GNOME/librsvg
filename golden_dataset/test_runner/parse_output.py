#!/usr/bin/env python3
"""
Parse Output - Parses the agent's markdown comment into structured data.

This module extracts structured information from the markdown-formatted
PR review comment generated by the agent.

Expected format:
    ## Categories
    - security
    - performance
    
    ## Focus Areas
    - Input validation
    - Memory management
    
    ## Suggestions
    - Add bounds checking
    - Consider using saturating arithmetic
    
    ## Potential Issues
    - Silent return may hide errors
    - Backward compatibility concerns
"""

import re
import logging

logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)


def normalize_text(text):
    """Normalize text for comparison."""
    return text.lower().strip()


def extract_bullet_items(lines, start_idx):
    """Extract bullet point items from lines starting at given index."""
    items = []
    
    for i in range(start_idx, len(lines)):
        line = lines[i].strip()
        
        # Check if we've hit a new section (## header or end of content)
        if line.startswith('## ') or (line and not line.startswith('-') and not line.startswith('*')):
            break
        
        # Extract bullet item
        if line.startswith('- ') or line.startswith('* '):
            # Remove bullet and leading whitespace
            item = line[2:].strip()
            if item:
                items.append(item)
        elif line.startswith('-') or line.startswith('*'):
            # Handle edge cases like "-item" (no space)
            item = line[1:].strip()
            if item:
                items.append(item)
    
    return items


def parse_agent_comment(text):
    """
    Parse markdown-formatted agent comment into structured data.
    
    Args:
        text: Raw markdown text from agent's PR comment
    
    Returns:
        Dict with keys: categories, focus_areas, suggestions, potential_issues
    """
    result = {
        'categories': [],
        'focus_areas': [],
        'suggestions': [],
        'potential_issues': []
    }
    
    if not text:
        logger.warning("Empty comment text passed to parser")
        return result
    
    lines = text.split('\n')
    
    # Map section headers to result keys
    section_map = {
        'categories': 'categories',
        'category': 'categories',
        'focus areas': 'focus_areas',
        'focus areas:': 'focus_areas',
        'focus': 'focus_areas',
        'suggestions': 'suggestions',
        'suggestion': 'suggestions',
        'recommendations': 'suggestions',
        'potential issues': 'potential_issues',
        'potential issues:': 'potential_issues',
        'issues': 'potential_issues',
        'concerns': 'potential_issues',
        'problems': 'potential_issues',
    }
    
    current_section = None
    
    for i, line in enumerate(lines):
        line_stripped = line.strip()
        
        # Detect section headers
        if line_stripped.startswith('## '):
            header = line_stripped[3:].strip().lower()
            
            # Find matching section
            current_section = None
            for key, result_key in section_map.items():
                if key in header:
                    current_section = result_key
                    break
            
            # Extract items after this header
            if current_section:
                items = extract_bullet_items(lines, i + 1)
                result[current_section] = items
                logger.debug(f"Parsed {len(items)} items from section: {current_section}")
    
    # Also try to parse individual bullet points outside sections
    # This handles cases where agent doesn't use proper headers
    
    return result


def parse_agent_comment_flexible(text):
    """
    Flexible parser that tries multiple strategies to extract data.
    
    This is a fallback parser that attempts to extract information
    even if the markdown structure is not perfect.
    
    Args:
        text: Raw text from agent's PR comment
    
    Returns:
        Dict with extracted data
    """
    result = {
        'categories': [],
        'focus_areas': [],
        'suggestions': [],
        'potential_issues': []
    }
    
    if not text:
        return result
    
    lines = text.split('\n')
    
    # Strategy 1: Standard markdown parsing
    parsed = parse_agent_comment(text)
    
    # If we got results, return them
    if any(parsed.values()):
        return parsed
    
    # Strategy 2: Look for keywords in bullet points
    for line in lines:
        line_lower = line.lower().strip()
        
        if line_lower.startswith('- ') or line_lower.startswith('* '):
            item = line_lower[2:]
            
            # Categorize by keywords
            if any(kw in item for kw in ['security', 'safe', 'vulnerability']):
                result['categories'].append(item)
            elif any(kw in item for kw in ['suggestion', 'recommend', 'should', 'consider']):
                result['suggestions'].append(item)
            elif any(kw in item for kw in ['issue', 'problem', 'concern', 'warning']):
                result['potential_issues'].append(item)
            else:
                # Default to focus areas
                result['focus_areas'].append(item)
    
    return result


def extract_code_snippets(text):
    """
    Extract code snippets from the comment for additional analysis.
    
    Args:
        text: Raw comment text
    
    Returns:
        List of code snippet strings
    """
    snippets = []
    in_code_block = False
    current_snippet = []
    
    for line in text.split('\n'):
        if line.strip().startswith('```'):
            if in_code_block:
                snippets.append('\n'.join(current_snippet))
                current_snippet = []
            in_code_block = not in_code_block
        elif in_code_block:
            current_snippet.append(line)
    
    return snippets


def validate_parsed_output(parsed):
    """
    Validate that parsed output has expected structure.
    
    Args:
        parsed: Dict from parse_agent_comment
    
    Returns:
        Tuple of (is_valid, error_message)
    """
    required_keys = ['categories', 'focus_areas', 'suggestions', 'potential_issues']
    
    for key in required_keys:
        if key not in parsed:
            return False, f"Missing required key: {key}"
        
        if not isinstance(parsed[key], list):
            return False, f"Key '{key}' should be a list"
    
    return True, None


if __name__ == "__main__":
    # Example usage and testing
    sample_comment = """
## Categories
- security
- performance

## Focus Areas
- Input validation
- Memory management
- Error handling

## Suggestions
- Add bounds checking to prevent overflow
- Consider using saturating arithmetic for numeric operations
- Log a warning when transform is not invertible

## Potential Issues
- Silent return may hide valid transform errors
- Need to verify backward compatibility
- The original code may have intentionally panicked
"""
    
    result = parse_agent_comment(sample_comment)
    print("Parsed result:")
    import json
    print(json.dumps(result, indent=2))

#![feature(prelude_import)]
#![no_std]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;

extern crate cairo;
extern crate cairo_sys;
extern crate cssparser;
extern crate float_cmp;
extern crate glib;
extern crate glib_sys;
extern crate itertools;
extern crate libc;
extern crate pango;
extern crate pango_cairo_sys;
extern crate pango_sys;
extern crate pangocairo;
extern crate regex;

#[macro_use]
extern crate lazy_static;

#[macro_use]
extern crate downcast_rs;

#[macro_use]
extern crate rulinalg;

pub use attributes::rsvg_attribute_from_name;

pub use cnode::{rsvg_rust_cnode_get_impl, rsvg_rust_cnode_new};

pub use color::{rsvg_css_parse_color, ColorKind, ColorSpec};

pub use drawing_ctx::{
    rsvg_drawing_ctx_add_node_and_ancestors_to_stack, rsvg_drawing_ctx_draw_node_from_stack,
    rsvg_drawing_ctx_free, rsvg_drawing_ctx_get_ink_rect, rsvg_drawing_ctx_new,
};

pub use length::{
    rsvg_length_hand_normalize, rsvg_length_normalize, rsvg_length_parse, LengthDir, LengthUnit,
    RsvgLength,
};

pub use load::rsvg_load_new_node;

pub use node::{
    rsvg_node_add_child, rsvg_node_children_iter_begin, rsvg_node_children_iter_end,
    rsvg_node_children_iter_next, rsvg_node_children_iter_next_back, rsvg_node_get_parent,
    rsvg_node_get_type, rsvg_node_is_same, rsvg_node_ref, rsvg_node_register_in_defs,
    rsvg_node_set_attribute_parse_error, rsvg_node_set_atts, rsvg_node_set_overridden_properties,
    rsvg_node_unref, rsvg_root_node_cascade,
};

pub use parsers::{rsvg_css_parse_number_list, rsvg_css_parse_number_optional_number};

pub use property_bag::{
    rsvg_property_bag_free, rsvg_property_bag_iter_begin, rsvg_property_bag_iter_end,
    rsvg_property_bag_iter_next, rsvg_property_bag_new,
};

pub use state::{
    rsvg_computed_values_get_lighting_color_argb, rsvg_parse_style_attrs, rsvg_state_free,
    rsvg_state_new, rsvg_state_parse_style_pair,
};

pub use structure::{rsvg_node_svg_apply_atts, rsvg_node_svg_get_size, rsvg_node_svg_get_view_box};

pub use text::{rsvg_node_chars_append, rsvg_node_chars_new};

#[macro_use]
mod coord_units {

    use cssparser::{CowRcStr, Parser, Token};
    use error::AttributeError;
    use parsers::{Parse, ParseError};
    /// Defines the units to be used for things that can consider a
    /// coordinate system in terms of the current transformation, or in
    /// terms of the current object's bounding box.
    ///
    /// Keep in sync with rsvg-private.h:RsvgCoordUnits
    #[repr(C)]
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub enum CoordUnits {
        UserSpaceOnUse,
        ObjectBoundingBox,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for CoordUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&CoordUnits::UserSpaceOnUse,) => {
                    let mut debug_trait_builder = f.debug_tuple("UserSpaceOnUse");
                    debug_trait_builder.finish()
                }
                (&CoordUnits::ObjectBoundingBox,) => {
                    let mut debug_trait_builder = f.debug_tuple("ObjectBoundingBox");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for CoordUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for CoordUnits {
        #[inline]
        fn clone(&self) -> CoordUnits {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for CoordUnits {
        #[inline]
        fn eq(&self, other: &CoordUnits) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for CoordUnits {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl Parse for CoordUnits {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<CoordUnits, AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "userSpaceOnUse" => Ok(CoordUnits::UserSpaceOnUse),
                    "objectBoundingBox" => Ok(CoordUnits::ObjectBoundingBox),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(Token::Ident(CowRcStr::from(
                            cow.as_ref().to_string(),
                        ))),
                    ),
                })
                .map_err(|_| {
                    AttributeError::Parse(ParseError::new(
                        "expected \'userSpaceOnUse\' or \'objectBoundingBox\'",
                    ))
                })
        }
    }
    /// Creates a newtype around `CoordUnits`, with a default value.
    ///
    /// SVG attributes that can take `userSpaceOnUse` or
    /// `objectBoundingBox` values often have different default values
    /// depending on the type of SVG element.  We use this macro to create
    /// a newtype for each SVG element and attribute that requires values
    /// of this type.  The newtype provides an `impl Default` with the
    /// specified `$default` value.
    #[macro_export]
    macro_rules! coord_units(( $ name : ident , $ default : expr ) => {
                             # [
                             derive ( Debug , Copy , Clone , PartialEq , Eq )
                             ] pub struct $ name ( pub CoordUnits ) ; impl
                             Default for $ name {
                             fn default (  ) -> Self { $ name ( $ default ) }
                             } impl From < $ name > for CoordUnits {
                             fn from ( u : $ name ) -> Self { u . 0 } } impl $
                             crate :: parsers :: Parse for $ name {
                             type Data = (  ) ; type Err = $ crate :: error ::
                             AttributeError ; fn parse (
                             parser : & mut :: cssparser :: Parser , _ : (  )
                             , ) -> Result < Self , $ crate :: error ::
                             AttributeError > {
                             Ok (
                             $ name (
                             $ crate :: coord_units :: CoordUnits :: parse (
                             parser , (  ) ) ? ) ) } } } ;);
}
#[macro_use]
mod float_eq_cairo {
    use float_cmp::ApproxEq;
    const CAIRO_FIXED_FRAC_BITS: u64 = 8;
    const CAIRO_MAGIC_NUMBER_FIXED: f64 = (1u64 << (52 - CAIRO_FIXED_FRAC_BITS)) as f64 * 1.5;
    fn cairo_magic_double(d: f64) -> f64 {
        d + CAIRO_MAGIC_NUMBER_FIXED
    }
    fn cairo_fixed_from_double(d: f64) -> i32 {
        let bits = cairo_magic_double(d).to_bits();
        let lower = bits & 4294967295;
        lower as i32
    }
    /// Implements a method to check whether two `f64` numbers would have
    /// the same fixed-point representation in Cairo.
    ///
    /// This generally means that the absolute difference between them,
    /// when taken as floating-point numbers, is less than the smallest
    /// representable fraction that Cairo can represent in fixed-point.
    ///
    /// Implementation detail: Cairo fixed-point numbers use 24 bits for
    /// the integral part, and 8 bits for the fractional part.  That is,
    /// the smallest fraction they can represent is 1/256.
    pub trait FixedEqCairo {
        fn fixed_eq_cairo(&self, other: &Self) -> bool;
    }
    impl FixedEqCairo for f64 {
        fn fixed_eq_cairo(&self, other: &f64) -> bool {
            cairo_fixed_from_double(*self) == cairo_fixed_from_double(*other)
        }
    }
    /// Checks whether two floating-point numbers are approximately equal,
    /// considering Cairo's limitations on numeric representation.
    ///
    /// Cairo uses fixed-point numbers internally.  We implement this
    /// trait for `f64`, so that two numbers can be considered "close
    /// enough to equal" if their absolute difference is smaller than the
    /// smallest fixed-point fraction that Cairo can represent.
    ///
    /// Note that this trait is reliable even if the given numbers are
    /// outside of the range that Cairo's fixed-point numbers can
    /// represent.  In that case, we check for the absolute difference,
    /// and finally allow a difference of 1 unit-in-the-last-place (ULP)
    /// for very large f64 values.
    pub trait ApproxEqCairo: ApproxEq {
        fn approx_eq_cairo(&self, other: &Self) -> bool;
    }
    impl ApproxEqCairo for f64 {
        fn approx_eq_cairo(&self, other: &f64) -> bool {
            let cairo_smallest_fraction = 1.0 / f64::from(1 << CAIRO_FIXED_FRAC_BITS);
            self.approx_eq(other, cairo_smallest_fraction, 1)
        }
    }
    #[macro_export]
    macro_rules! assert_approx_eq_cairo(( $ left : expr , $ right : expr ) =>
                                        {
                                        {
                                        match ( & $ left , & $ right ) {
                                        ( l , r ) => {
                                        if ! l . approx_eq_cairo ( r ) {
                                        panic ! (
                                        r#"assertion failed: `(left == right)`
  left: `{:?}`,
 right: `{:?}`"#
                                        , l , r ) } } } } } ;);
}
#[macro_use]
mod property_macros {
    pub trait Property<T> {
        fn inherits_automatically() -> bool;
        fn compute(&self, &T) -> Self;
    }
    /// Generates a property definition that simply parses strings to enum variants
    /// or to a tuple struct of the given type.
    ///
    /// For example, the SVG spec defines the `stroke-linejoin` property
    /// to have possible values `miter | round | bevel | inherit`, with a default
    /// of `miter`.  We can define the property like this:
    ///
    /// ```ignore
    /// make_property!(
    /// StrokeLinejoin,
    /// default: Miter,
    ///     
    /// "miter" => Miter,
    /// "round" => Round,
    /// "bevel" => Bevel,
    /// );
    /// ```
    ///
    /// The macro will generate a `StrokeLinejoin` enum with the provided
    /// variants.  It will generate an `impl Default for StrokeLinejoin`
    /// with the provided `default:` value.  Finally, it will generate an
    /// `impl Parse for StrokeLinejoin`, from `parsers::Parse`, where
    /// `type Data = ()` and `type Err = AttributeError`.
    #[macro_export]
    macro_rules! make_property((
                               $ computed_values_type : ty , $ name : ident ,
                               default : $ default : ident ,
                               inherits_automatically : $
                               inherits_automatically : expr , identifiers : $
                               ( $ str_prop : expr => $ variant : ident , ) +
                               ) => {
                               # [ derive ( Debug , Copy , Clone , PartialEq )
                               ] pub enum $ name { $ ( $ variant ) , + }
                               impl_default ! ( $ name , $ name :: $ default )
                               ; impl_property ! (
                               $ computed_values_type , $ name , $
                               inherits_automatically ) ; impl :: parsers ::
                               Parse for $ name {
                               type Data = (  ) ; type Err = :: error ::
                               AttributeError ; fn parse (
                               parser : & mut :: cssparser :: Parser , _ :
                               Self :: Data ) -> Result < $ name , :: error ::
                               AttributeError > {
                               let loc = parser . current_source_location (  )
                               ; parser . expect_ident (  ) . and_then (
                               | cow | match cow . as_ref (  ) {
                               $ ( $ str_prop => Ok ( $ name :: $ variant ) ,
                               ) + _ => Err (
                               loc . new_basic_unexpected_token_error (
                               :: cssparser :: Token :: Ident (
                               :: cssparser :: CowRcStr :: from (
                               cow . as_ref (  ) . to_string (  ) , ) ) ) , )
                               , } ) . map_err (
                               | _ | {
                               :: error :: AttributeError :: Parse (
                               :: parsers :: ParseError :: new (
                               "unexpected value" , ) ) } ) } } } ; (
                               $ computed_values_type : ty , $ name : ident ,
                               default : $ default : expr ,
                               inherits_automatically : $
                               inherits_automatically : expr , newtype_parse :
                               $ type : ty , parse_data_type : $
                               parse_data_type : ty ) => {
                               # [ derive ( Debug , Clone , PartialEq ) ] pub
                               struct $ name ( pub $ type ) ; impl_default ! (
                               $ name , $ name ( $ default ) ) ; impl ::
                               property_macros :: Property < $
                               computed_values_type > for $ name {
                               fn inherits_automatically (  ) -> bool {
                               $ inherits_automatically } fn compute (
                               & self , _v : & $ computed_values_type ) ->
                               Self { self . clone (  ) } } impl :: parsers ::
                               Parse for $ name {
                               type Data = $ parse_data_type ; type Err = ::
                               error :: AttributeError ; fn parse (
                               parser : & mut :: cssparser :: Parser , d :
                               Self :: Data ) -> Result < $ name , :: error ::
                               AttributeError > {
                               Ok (
                               $ name (
                               < $ type as :: parsers :: Parse > :: parse (
                               parser , d ) ? ) ) } } } ; (
                               $ computed_values_type : ty , $ name : ident ,
                               default : $ default : expr , newtype_parse : $
                               type : ty , parse_data_type : $ parse_data_type
                               : ty , property_impl : { $ prop : item } ) => {
                               # [ derive ( Debug , Clone , PartialEq ) ] pub
                               struct $ name ( pub $ type ) ; impl_default ! (
                               $ name , $ name ( $ default ) ) ; $ prop impl
                               :: parsers :: Parse for $ name {
                               type Data = $ parse_data_type ; type Err = ::
                               error :: AttributeError ; fn parse (
                               parser : & mut :: cssparser :: Parser , d :
                               Self :: Data ) -> Result < $ name , :: error ::
                               AttributeError > {
                               Ok (
                               $ name (
                               < $ type as :: parsers :: Parse > :: parse (
                               parser , d ) ? ) ) } } } ; (
                               $ computed_values_type : ty , $ name : ident ,
                               default : $ default : expr , newtype : $ type :
                               ty , property_impl : { $ prop : item } ,
                               parse_impl : { $ parse : item } ) => {
                               # [ derive ( Debug , Clone , PartialEq ) ] pub
                               struct $ name ( pub $ type ) ; impl_default ! (
                               $ name , $ name ( $ default ) ) ; $ prop $
                               parse } ; (
                               $ computed_values_type : ty , $ name : ident ,
                               inherits_automatically : $
                               inherits_automatically : expr , fields : {
                               $ (
                               $ field_name : ident : $ field_type : ty ,
                               default : $ field_default : expr , ) + }
                               parse_impl : { $ parse : item } ) => {
                               # [ derive ( Debug , Clone , PartialEq ) ] pub
                               struct $ name {
                               $ ( pub $ field_name : $ field_type ) , + }
                               impl_default ! (
                               $ name , $ name {
                               $ ( $ field_name : $ field_default ) , + } ) ;
                               impl_property ! (
                               $ computed_values_type , $ name , $
                               inherits_automatically ) ; $ parse } ;);
    macro_rules! impl_default(( $ name : ident , $ default : expr ) => {
                              impl Default for $ name {
                              fn default (  ) -> $ name { $ default } } } ;);
    macro_rules! impl_property((
                               $ computed_values_type : ty , $ name : ident ,
                               $ inherits_automatically : expr ) => {
                               impl :: property_macros :: Property < $
                               computed_values_type > for $ name {
                               fn inherits_automatically (  ) -> bool {
                               $ inherits_automatically } fn compute (
                               & self , _v : & $ computed_values_type ) ->
                               Self { self . clone (  ) } } } ;);
}
mod aspect_ratio {
    //! Handling of `preserveAspectRatio` values
    //!
    //! This module handles `preserveAspectRatio` values [per the SVG specification][spec].
    //! We have an [`AspectRatio`] struct which encapsulates such a value.
    //!
    //! ```ignore
    //! assert_eq!(
    //!     AspectRatio::parse("xMidYMid", ()),
    //!     Ok(AspectRatio {
    //!         defer: false,
    //!         align: Some(Align {
    //!             x: X(Align1D::Mid),
    //!             y: Y(Align1D::Mid),
    //!             fit: FitMode::Meet,
    //!         }),
    //!     })
    //! );
    //! ```
    //!
    //! [`AspectRatio`]: struct.AspectRatio.html
    //! [spec]: https://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
    use cssparser::Parser;
    use error::*;
    use parsers::Parse;
    use parsers::ParseError;
    use std::ops::Deref;
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct AspectRatio {
        defer: bool,
        align: Option<Align>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for AspectRatio {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                AspectRatio {
                    defer: ref __self_0_0,
                    align: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("AspectRatio");
                    let _ = debug_trait_builder.field("defer", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("align", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for AspectRatio {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for AspectRatio {
        #[inline]
        fn clone(&self) -> AspectRatio {
            {
                let _: ::std::clone::AssertParamIsClone<bool>;
                let _: ::std::clone::AssertParamIsClone<Option<Align>>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for AspectRatio {
        #[inline]
        fn eq(&self, other: &AspectRatio) -> bool {
            match *other {
                AspectRatio {
                    defer: ref __self_1_0,
                    align: ref __self_1_1,
                } => match *self {
                    AspectRatio {
                        defer: ref __self_0_0,
                        align: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AspectRatio) -> bool {
            match *other {
                AspectRatio {
                    defer: ref __self_1_0,
                    align: ref __self_1_1,
                } => match *self {
                    AspectRatio {
                        defer: ref __self_0_0,
                        align: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for AspectRatio {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<bool>;
                let _: ::std::cmp::AssertParamIsEq<Option<Align>>;
            }
        }
    }
    impl Default for AspectRatio {
        fn default() -> AspectRatio {
            AspectRatio {
                defer: false,
                align: Some(Align::default()),
            }
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    enum FitMode {
        Meet,
        Slice,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FitMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FitMode::Meet,) => {
                    let mut debug_trait_builder = f.debug_tuple("Meet");
                    debug_trait_builder.finish()
                }
                (&FitMode::Slice,) => {
                    let mut debug_trait_builder = f.debug_tuple("Slice");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FitMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FitMode {
        #[inline]
        fn clone(&self) -> FitMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FitMode {
        #[inline]
        fn eq(&self, other: &FitMode) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for FitMode {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl Default for FitMode {
        fn default() -> FitMode {
            FitMode::Meet
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    struct Align {
        x: X,
        y: Y,
        fit: FitMode,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Align {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Align {
                    x: ref __self_0_0,
                    y: ref __self_0_1,
                    fit: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Align");
                    let _ = debug_trait_builder.field("x", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("y", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("fit", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Align {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Align {
        #[inline]
        fn clone(&self) -> Align {
            {
                let _: ::std::clone::AssertParamIsClone<X>;
                let _: ::std::clone::AssertParamIsClone<Y>;
                let _: ::std::clone::AssertParamIsClone<FitMode>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Align {
        #[inline]
        fn eq(&self, other: &Align) -> bool {
            match *other {
                Align {
                    x: ref __self_1_0,
                    y: ref __self_1_1,
                    fit: ref __self_1_2,
                } => match *self {
                    Align {
                        x: ref __self_0_0,
                        y: ref __self_0_1,
                        fit: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Align) -> bool {
            match *other {
                Align {
                    x: ref __self_1_0,
                    y: ref __self_1_1,
                    fit: ref __self_1_2,
                } => match *self {
                    Align {
                        x: ref __self_0_0,
                        y: ref __self_0_1,
                        fit: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Align {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<X>;
                let _: ::std::cmp::AssertParamIsEq<Y>;
                let _: ::std::cmp::AssertParamIsEq<FitMode>;
            }
        }
    }
    impl Default for Align {
        fn default() -> Align {
            Align {
                x: X(Align1D::Mid),
                y: Y(Align1D::Mid),
                fit: FitMode::default(),
            }
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    enum Align1D {
        Min,
        Mid,
        Max,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Align1D {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Align1D::Min,) => {
                    let mut debug_trait_builder = f.debug_tuple("Min");
                    debug_trait_builder.finish()
                }
                (&Align1D::Mid,) => {
                    let mut debug_trait_builder = f.debug_tuple("Mid");
                    debug_trait_builder.finish()
                }
                (&Align1D::Max,) => {
                    let mut debug_trait_builder = f.debug_tuple("Max");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Align1D {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Align1D {
        #[inline]
        fn clone(&self) -> Align1D {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Align1D {
        #[inline]
        fn eq(&self, other: &Align1D) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Align1D {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    struct X(Align1D);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for X {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                X(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("X");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for X {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for X {
        #[inline]
        fn clone(&self) -> X {
            {
                let _: ::std::clone::AssertParamIsClone<Align1D>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for X {
        #[inline]
        fn eq(&self, other: &X) -> bool {
            match *other {
                X(ref __self_1_0) => match *self {
                    X(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &X) -> bool {
            match *other {
                X(ref __self_1_0) => match *self {
                    X(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for X {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<Align1D>;
            }
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    struct Y(Align1D);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Y {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Y(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Y");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Y {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Y {
        #[inline]
        fn clone(&self) -> Y {
            {
                let _: ::std::clone::AssertParamIsClone<Align1D>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Y {
        #[inline]
        fn eq(&self, other: &Y) -> bool {
            match *other {
                Y(ref __self_1_0) => match *self {
                    Y(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Y) -> bool {
            match *other {
                Y(ref __self_1_0) => match *self {
                    Y(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Y {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<Align1D>;
            }
        }
    }
    impl Deref for X {
        type Target = Align1D;
        fn deref(&self) -> &Align1D {
            &self.0
        }
    }
    impl Deref for Y {
        type Target = Align1D;
        fn deref(&self) -> &Align1D {
            &self.0
        }
    }
    impl Align1D {
        fn compute(self, dest_pos: f64, dest_size: f64, obj_size: f64) -> f64 {
            match self {
                Align1D::Min => dest_pos,
                Align1D::Mid => dest_pos + (dest_size - obj_size) / 2.0,
                Align1D::Max => dest_pos + dest_size - obj_size,
            }
        }
    }
    impl AspectRatio {
        pub fn is_slice(&self) -> bool {
            match self.align {
                Some(Align {
                    fit: FitMode::Slice,
                    ..
                }) => true,
                _ => false,
            }
        }
        pub fn compute(
            &self,
            object_width: f64,
            object_height: f64,
            dest_x: f64,
            dest_y: f64,
            dest_width: f64,
            dest_height: f64,
        ) -> (f64, f64, f64, f64) {
            match self.align {
                None => (dest_x, dest_y, dest_width, dest_height),
                Some(Align { x, y, fit }) => {
                    let w_factor = dest_width / object_width;
                    let h_factor = dest_height / object_height;
                    let factor = match fit {
                        FitMode::Meet => w_factor.min(h_factor),
                        FitMode::Slice => w_factor.max(h_factor),
                    };
                    let w = object_width * factor;
                    let h = object_height * factor;
                    let xpos = x.compute(dest_x, dest_width, w);
                    let ypos = y.compute(dest_y, dest_height, h);
                    (xpos, ypos, w, h)
                }
            }
        }
        fn parse_input<'i, 't>(p: &mut Parser<'i, 't>) -> Result<AspectRatio, ()> {
            let defer = p.try(|p| p.expect_ident_matching("defer")).is_ok();
            let align_xy = p.try(|p| {
                p.expect_ident()
                    .map_err(|_| ())
                    .and_then(|ident| Align::parse_xy(ident))
            })?;
            let fit =
                p.try(|p| {
                    p.expect_ident()
                        .map_err(|_| ())
                        .and_then(|ident| FitMode::parse(ident))
                }).unwrap_or(FitMode::default());
            p.expect_exhausted().map_err(|_| ())?;
            let align = align_xy.map(|(x, y)| Align { x, y, fit });
            Ok(AspectRatio { defer, align })
        }
    }
    impl Align {
        fn parse_xy(s: &str) -> Result<Option<(X, Y)>, ()> {
            use self::Align1D::*;
            match s {
                "none" => Ok(None),
                "xMinYMin" => Ok(Some((X(Min), Y(Min)))),
                "xMidYMin" => Ok(Some((X(Mid), Y(Min)))),
                "xMaxYMin" => Ok(Some((X(Max), Y(Min)))),
                "xMinYMid" => Ok(Some((X(Min), Y(Mid)))),
                "xMidYMid" => Ok(Some((X(Mid), Y(Mid)))),
                "xMaxYMid" => Ok(Some((X(Max), Y(Mid)))),
                "xMinYMax" => Ok(Some((X(Min), Y(Max)))),
                "xMidYMax" => Ok(Some((X(Mid), Y(Max)))),
                "xMaxYMax" => Ok(Some((X(Max), Y(Max)))),
                _ => Err(()),
            }
        }
    }
    impl FitMode {
        fn parse(s: &str) -> Result<FitMode, ()> {
            match s {
                "meet" => Ok(FitMode::Meet),
                "slice" => Ok(FitMode::Slice),
                _ => Err(()),
            }
        }
    }
    impl Parse for AspectRatio {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<AspectRatio, AttributeError> {
            AspectRatio::parse_input(parser).map_err(|_| {
                AttributeError::Parse(ParseError::new(
                    "expected \"[defer] <align> [meet | slice]\"",
                ))
            })
        }
    }
}
mod attributes {
    extern crate phf;
    use glib::translate::*;
    use glib_sys;
    use libc;
    use std::str::FromStr;
    use util::utf8_cstr;
    #[repr(C)]
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub enum Attribute {
        Alternate,
        Amplitude,
        Azimuth,
        BaseFrequency,
        BaselineShift,
        Bias,
        Class,
        ClipPath,
        ClipRule,
        ClipPathUnits,
        Color,
        ColorInterpolationFilters,
        CompOp,
        Cx,
        Cy,
        D,
        DiffuseConstant,
        Direction,
        Display,
        Divisor,
        Dx,
        Dy,
        EdgeMode,
        Elevation,
        EnableBackground,
        Encoding,
        Exponent,
        Fill,
        FillOpacity,
        FillRule,
        Filter,
        FilterUnits,
        FloodColor,
        FloodOpacity,
        FontFamily,
        FontSize,
        FontStretch,
        FontStyle,
        FontVariant,
        FontWeight,
        Fx,
        Fy,
        GradientTransform,
        GradientUnits,
        Height,
        Href,
        Id,
        In,
        In2,
        Intercept,
        K1,
        K2,
        K3,
        K4,
        KernelMatrix,
        KernelUnitLength,
        LetterSpacing,
        LightingColor,
        LimitingConeAngle,
        Marker,
        MarkerEnd,
        MarkerMid,
        MarkerStart,
        MarkerHeight,
        MarkerUnits,
        MarkerWidth,
        Mask,
        MaskContentUnits,
        MaskUnits,
        Mode,
        NumOctaves,
        Offset,
        Opacity,
        Operator,
        Order,
        Orient,
        Overflow,
        Parse,
        Path,
        PatternContentUnits,
        PatternTransform,
        PatternUnits,
        Points,
        PointsAtX,
        PointsAtY,
        PointsAtZ,
        PreserveAlpha,
        PreserveAspectRatio,
        PrimitiveUnits,
        R,
        Radius,
        RefX,
        RefY,
        RequiredExtensions,
        RequiredFeatures,
        Result,
        Rx,
        Ry,
        Scale,
        Seed,
        ShapeRendering,
        Slope,
        SpecularConstant,
        SpecularExponent,
        SpreadMethod,
        StdDeviation,
        StitchTiles,
        StopColor,
        StopOpacity,
        Stroke,
        StrokeDasharray,
        StrokeDashoffset,
        StrokeLinecap,
        StrokeLinejoin,
        StrokeMiterlimit,
        StrokeOpacity,
        StrokeWidth,
        Style,
        SurfaceScale,
        SystemLanguage,
        TableValues,
        TargetX,
        TargetY,
        TextAnchor,
        TextDecoration,
        TextRendering,
        Transform,
        Type,
        UnicodeBidi,
        Values,
        Verts,
        ViewBox,
        Visibility,
        Width,
        WritingMode,
        X,
        X1,
        Y1,
        X2,
        Y2,
        XChannelSelector,
        XlinkHref,
        XmlLang,
        XmlSpace,
        Y,
        YChannelSelector,
        Z,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Attribute {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Attribute::Alternate,) => {
                    let mut debug_trait_builder = f.debug_tuple("Alternate");
                    debug_trait_builder.finish()
                }
                (&Attribute::Amplitude,) => {
                    let mut debug_trait_builder = f.debug_tuple("Amplitude");
                    debug_trait_builder.finish()
                }
                (&Attribute::Azimuth,) => {
                    let mut debug_trait_builder = f.debug_tuple("Azimuth");
                    debug_trait_builder.finish()
                }
                (&Attribute::BaseFrequency,) => {
                    let mut debug_trait_builder = f.debug_tuple("BaseFrequency");
                    debug_trait_builder.finish()
                }
                (&Attribute::BaselineShift,) => {
                    let mut debug_trait_builder = f.debug_tuple("BaselineShift");
                    debug_trait_builder.finish()
                }
                (&Attribute::Bias,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bias");
                    debug_trait_builder.finish()
                }
                (&Attribute::Class,) => {
                    let mut debug_trait_builder = f.debug_tuple("Class");
                    debug_trait_builder.finish()
                }
                (&Attribute::ClipPath,) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipPath");
                    debug_trait_builder.finish()
                }
                (&Attribute::ClipRule,) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipRule");
                    debug_trait_builder.finish()
                }
                (&Attribute::ClipPathUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipPathUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::Color,) => {
                    let mut debug_trait_builder = f.debug_tuple("Color");
                    debug_trait_builder.finish()
                }
                (&Attribute::ColorInterpolationFilters,) => {
                    let mut debug_trait_builder = f.debug_tuple("ColorInterpolationFilters");
                    debug_trait_builder.finish()
                }
                (&Attribute::CompOp,) => {
                    let mut debug_trait_builder = f.debug_tuple("CompOp");
                    debug_trait_builder.finish()
                }
                (&Attribute::Cx,) => {
                    let mut debug_trait_builder = f.debug_tuple("Cx");
                    debug_trait_builder.finish()
                }
                (&Attribute::Cy,) => {
                    let mut debug_trait_builder = f.debug_tuple("Cy");
                    debug_trait_builder.finish()
                }
                (&Attribute::D,) => {
                    let mut debug_trait_builder = f.debug_tuple("D");
                    debug_trait_builder.finish()
                }
                (&Attribute::DiffuseConstant,) => {
                    let mut debug_trait_builder = f.debug_tuple("DiffuseConstant");
                    debug_trait_builder.finish()
                }
                (&Attribute::Direction,) => {
                    let mut debug_trait_builder = f.debug_tuple("Direction");
                    debug_trait_builder.finish()
                }
                (&Attribute::Display,) => {
                    let mut debug_trait_builder = f.debug_tuple("Display");
                    debug_trait_builder.finish()
                }
                (&Attribute::Divisor,) => {
                    let mut debug_trait_builder = f.debug_tuple("Divisor");
                    debug_trait_builder.finish()
                }
                (&Attribute::Dx,) => {
                    let mut debug_trait_builder = f.debug_tuple("Dx");
                    debug_trait_builder.finish()
                }
                (&Attribute::Dy,) => {
                    let mut debug_trait_builder = f.debug_tuple("Dy");
                    debug_trait_builder.finish()
                }
                (&Attribute::EdgeMode,) => {
                    let mut debug_trait_builder = f.debug_tuple("EdgeMode");
                    debug_trait_builder.finish()
                }
                (&Attribute::Elevation,) => {
                    let mut debug_trait_builder = f.debug_tuple("Elevation");
                    debug_trait_builder.finish()
                }
                (&Attribute::EnableBackground,) => {
                    let mut debug_trait_builder = f.debug_tuple("EnableBackground");
                    debug_trait_builder.finish()
                }
                (&Attribute::Encoding,) => {
                    let mut debug_trait_builder = f.debug_tuple("Encoding");
                    debug_trait_builder.finish()
                }
                (&Attribute::Exponent,) => {
                    let mut debug_trait_builder = f.debug_tuple("Exponent");
                    debug_trait_builder.finish()
                }
                (&Attribute::Fill,) => {
                    let mut debug_trait_builder = f.debug_tuple("Fill");
                    debug_trait_builder.finish()
                }
                (&Attribute::FillOpacity,) => {
                    let mut debug_trait_builder = f.debug_tuple("FillOpacity");
                    debug_trait_builder.finish()
                }
                (&Attribute::FillRule,) => {
                    let mut debug_trait_builder = f.debug_tuple("FillRule");
                    debug_trait_builder.finish()
                }
                (&Attribute::Filter,) => {
                    let mut debug_trait_builder = f.debug_tuple("Filter");
                    debug_trait_builder.finish()
                }
                (&Attribute::FilterUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::FloodColor,) => {
                    let mut debug_trait_builder = f.debug_tuple("FloodColor");
                    debug_trait_builder.finish()
                }
                (&Attribute::FloodOpacity,) => {
                    let mut debug_trait_builder = f.debug_tuple("FloodOpacity");
                    debug_trait_builder.finish()
                }
                (&Attribute::FontFamily,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontFamily");
                    debug_trait_builder.finish()
                }
                (&Attribute::FontSize,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontSize");
                    debug_trait_builder.finish()
                }
                (&Attribute::FontStretch,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontStretch");
                    debug_trait_builder.finish()
                }
                (&Attribute::FontStyle,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontStyle");
                    debug_trait_builder.finish()
                }
                (&Attribute::FontVariant,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontVariant");
                    debug_trait_builder.finish()
                }
                (&Attribute::FontWeight,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontWeight");
                    debug_trait_builder.finish()
                }
                (&Attribute::Fx,) => {
                    let mut debug_trait_builder = f.debug_tuple("Fx");
                    debug_trait_builder.finish()
                }
                (&Attribute::Fy,) => {
                    let mut debug_trait_builder = f.debug_tuple("Fy");
                    debug_trait_builder.finish()
                }
                (&Attribute::GradientTransform,) => {
                    let mut debug_trait_builder = f.debug_tuple("GradientTransform");
                    debug_trait_builder.finish()
                }
                (&Attribute::GradientUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("GradientUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::Height,) => {
                    let mut debug_trait_builder = f.debug_tuple("Height");
                    debug_trait_builder.finish()
                }
                (&Attribute::Href,) => {
                    let mut debug_trait_builder = f.debug_tuple("Href");
                    debug_trait_builder.finish()
                }
                (&Attribute::Id,) => {
                    let mut debug_trait_builder = f.debug_tuple("Id");
                    debug_trait_builder.finish()
                }
                (&Attribute::In,) => {
                    let mut debug_trait_builder = f.debug_tuple("In");
                    debug_trait_builder.finish()
                }
                (&Attribute::In2,) => {
                    let mut debug_trait_builder = f.debug_tuple("In2");
                    debug_trait_builder.finish()
                }
                (&Attribute::Intercept,) => {
                    let mut debug_trait_builder = f.debug_tuple("Intercept");
                    debug_trait_builder.finish()
                }
                (&Attribute::K1,) => {
                    let mut debug_trait_builder = f.debug_tuple("K1");
                    debug_trait_builder.finish()
                }
                (&Attribute::K2,) => {
                    let mut debug_trait_builder = f.debug_tuple("K2");
                    debug_trait_builder.finish()
                }
                (&Attribute::K3,) => {
                    let mut debug_trait_builder = f.debug_tuple("K3");
                    debug_trait_builder.finish()
                }
                (&Attribute::K4,) => {
                    let mut debug_trait_builder = f.debug_tuple("K4");
                    debug_trait_builder.finish()
                }
                (&Attribute::KernelMatrix,) => {
                    let mut debug_trait_builder = f.debug_tuple("KernelMatrix");
                    debug_trait_builder.finish()
                }
                (&Attribute::KernelUnitLength,) => {
                    let mut debug_trait_builder = f.debug_tuple("KernelUnitLength");
                    debug_trait_builder.finish()
                }
                (&Attribute::LetterSpacing,) => {
                    let mut debug_trait_builder = f.debug_tuple("LetterSpacing");
                    debug_trait_builder.finish()
                }
                (&Attribute::LightingColor,) => {
                    let mut debug_trait_builder = f.debug_tuple("LightingColor");
                    debug_trait_builder.finish()
                }
                (&Attribute::LimitingConeAngle,) => {
                    let mut debug_trait_builder = f.debug_tuple("LimitingConeAngle");
                    debug_trait_builder.finish()
                }
                (&Attribute::Marker,) => {
                    let mut debug_trait_builder = f.debug_tuple("Marker");
                    debug_trait_builder.finish()
                }
                (&Attribute::MarkerEnd,) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerEnd");
                    debug_trait_builder.finish()
                }
                (&Attribute::MarkerMid,) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerMid");
                    debug_trait_builder.finish()
                }
                (&Attribute::MarkerStart,) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerStart");
                    debug_trait_builder.finish()
                }
                (&Attribute::MarkerHeight,) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerHeight");
                    debug_trait_builder.finish()
                }
                (&Attribute::MarkerUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::MarkerWidth,) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerWidth");
                    debug_trait_builder.finish()
                }
                (&Attribute::Mask,) => {
                    let mut debug_trait_builder = f.debug_tuple("Mask");
                    debug_trait_builder.finish()
                }
                (&Attribute::MaskContentUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("MaskContentUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::MaskUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("MaskUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::Mode,) => {
                    let mut debug_trait_builder = f.debug_tuple("Mode");
                    debug_trait_builder.finish()
                }
                (&Attribute::NumOctaves,) => {
                    let mut debug_trait_builder = f.debug_tuple("NumOctaves");
                    debug_trait_builder.finish()
                }
                (&Attribute::Offset,) => {
                    let mut debug_trait_builder = f.debug_tuple("Offset");
                    debug_trait_builder.finish()
                }
                (&Attribute::Opacity,) => {
                    let mut debug_trait_builder = f.debug_tuple("Opacity");
                    debug_trait_builder.finish()
                }
                (&Attribute::Operator,) => {
                    let mut debug_trait_builder = f.debug_tuple("Operator");
                    debug_trait_builder.finish()
                }
                (&Attribute::Order,) => {
                    let mut debug_trait_builder = f.debug_tuple("Order");
                    debug_trait_builder.finish()
                }
                (&Attribute::Orient,) => {
                    let mut debug_trait_builder = f.debug_tuple("Orient");
                    debug_trait_builder.finish()
                }
                (&Attribute::Overflow,) => {
                    let mut debug_trait_builder = f.debug_tuple("Overflow");
                    debug_trait_builder.finish()
                }
                (&Attribute::Parse,) => {
                    let mut debug_trait_builder = f.debug_tuple("Parse");
                    debug_trait_builder.finish()
                }
                (&Attribute::Path,) => {
                    let mut debug_trait_builder = f.debug_tuple("Path");
                    debug_trait_builder.finish()
                }
                (&Attribute::PatternContentUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("PatternContentUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::PatternTransform,) => {
                    let mut debug_trait_builder = f.debug_tuple("PatternTransform");
                    debug_trait_builder.finish()
                }
                (&Attribute::PatternUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("PatternUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::Points,) => {
                    let mut debug_trait_builder = f.debug_tuple("Points");
                    debug_trait_builder.finish()
                }
                (&Attribute::PointsAtX,) => {
                    let mut debug_trait_builder = f.debug_tuple("PointsAtX");
                    debug_trait_builder.finish()
                }
                (&Attribute::PointsAtY,) => {
                    let mut debug_trait_builder = f.debug_tuple("PointsAtY");
                    debug_trait_builder.finish()
                }
                (&Attribute::PointsAtZ,) => {
                    let mut debug_trait_builder = f.debug_tuple("PointsAtZ");
                    debug_trait_builder.finish()
                }
                (&Attribute::PreserveAlpha,) => {
                    let mut debug_trait_builder = f.debug_tuple("PreserveAlpha");
                    debug_trait_builder.finish()
                }
                (&Attribute::PreserveAspectRatio,) => {
                    let mut debug_trait_builder = f.debug_tuple("PreserveAspectRatio");
                    debug_trait_builder.finish()
                }
                (&Attribute::PrimitiveUnits,) => {
                    let mut debug_trait_builder = f.debug_tuple("PrimitiveUnits");
                    debug_trait_builder.finish()
                }
                (&Attribute::R,) => {
                    let mut debug_trait_builder = f.debug_tuple("R");
                    debug_trait_builder.finish()
                }
                (&Attribute::Radius,) => {
                    let mut debug_trait_builder = f.debug_tuple("Radius");
                    debug_trait_builder.finish()
                }
                (&Attribute::RefX,) => {
                    let mut debug_trait_builder = f.debug_tuple("RefX");
                    debug_trait_builder.finish()
                }
                (&Attribute::RefY,) => {
                    let mut debug_trait_builder = f.debug_tuple("RefY");
                    debug_trait_builder.finish()
                }
                (&Attribute::RequiredExtensions,) => {
                    let mut debug_trait_builder = f.debug_tuple("RequiredExtensions");
                    debug_trait_builder.finish()
                }
                (&Attribute::RequiredFeatures,) => {
                    let mut debug_trait_builder = f.debug_tuple("RequiredFeatures");
                    debug_trait_builder.finish()
                }
                (&Attribute::Result,) => {
                    let mut debug_trait_builder = f.debug_tuple("Result");
                    debug_trait_builder.finish()
                }
                (&Attribute::Rx,) => {
                    let mut debug_trait_builder = f.debug_tuple("Rx");
                    debug_trait_builder.finish()
                }
                (&Attribute::Ry,) => {
                    let mut debug_trait_builder = f.debug_tuple("Ry");
                    debug_trait_builder.finish()
                }
                (&Attribute::Scale,) => {
                    let mut debug_trait_builder = f.debug_tuple("Scale");
                    debug_trait_builder.finish()
                }
                (&Attribute::Seed,) => {
                    let mut debug_trait_builder = f.debug_tuple("Seed");
                    debug_trait_builder.finish()
                }
                (&Attribute::ShapeRendering,) => {
                    let mut debug_trait_builder = f.debug_tuple("ShapeRendering");
                    debug_trait_builder.finish()
                }
                (&Attribute::Slope,) => {
                    let mut debug_trait_builder = f.debug_tuple("Slope");
                    debug_trait_builder.finish()
                }
                (&Attribute::SpecularConstant,) => {
                    let mut debug_trait_builder = f.debug_tuple("SpecularConstant");
                    debug_trait_builder.finish()
                }
                (&Attribute::SpecularExponent,) => {
                    let mut debug_trait_builder = f.debug_tuple("SpecularExponent");
                    debug_trait_builder.finish()
                }
                (&Attribute::SpreadMethod,) => {
                    let mut debug_trait_builder = f.debug_tuple("SpreadMethod");
                    debug_trait_builder.finish()
                }
                (&Attribute::StdDeviation,) => {
                    let mut debug_trait_builder = f.debug_tuple("StdDeviation");
                    debug_trait_builder.finish()
                }
                (&Attribute::StitchTiles,) => {
                    let mut debug_trait_builder = f.debug_tuple("StitchTiles");
                    debug_trait_builder.finish()
                }
                (&Attribute::StopColor,) => {
                    let mut debug_trait_builder = f.debug_tuple("StopColor");
                    debug_trait_builder.finish()
                }
                (&Attribute::StopOpacity,) => {
                    let mut debug_trait_builder = f.debug_tuple("StopOpacity");
                    debug_trait_builder.finish()
                }
                (&Attribute::Stroke,) => {
                    let mut debug_trait_builder = f.debug_tuple("Stroke");
                    debug_trait_builder.finish()
                }
                (&Attribute::StrokeDasharray,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeDasharray");
                    debug_trait_builder.finish()
                }
                (&Attribute::StrokeDashoffset,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeDashoffset");
                    debug_trait_builder.finish()
                }
                (&Attribute::StrokeLinecap,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeLinecap");
                    debug_trait_builder.finish()
                }
                (&Attribute::StrokeLinejoin,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeLinejoin");
                    debug_trait_builder.finish()
                }
                (&Attribute::StrokeMiterlimit,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeMiterlimit");
                    debug_trait_builder.finish()
                }
                (&Attribute::StrokeOpacity,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeOpacity");
                    debug_trait_builder.finish()
                }
                (&Attribute::StrokeWidth,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeWidth");
                    debug_trait_builder.finish()
                }
                (&Attribute::Style,) => {
                    let mut debug_trait_builder = f.debug_tuple("Style");
                    debug_trait_builder.finish()
                }
                (&Attribute::SurfaceScale,) => {
                    let mut debug_trait_builder = f.debug_tuple("SurfaceScale");
                    debug_trait_builder.finish()
                }
                (&Attribute::SystemLanguage,) => {
                    let mut debug_trait_builder = f.debug_tuple("SystemLanguage");
                    debug_trait_builder.finish()
                }
                (&Attribute::TableValues,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableValues");
                    debug_trait_builder.finish()
                }
                (&Attribute::TargetX,) => {
                    let mut debug_trait_builder = f.debug_tuple("TargetX");
                    debug_trait_builder.finish()
                }
                (&Attribute::TargetY,) => {
                    let mut debug_trait_builder = f.debug_tuple("TargetY");
                    debug_trait_builder.finish()
                }
                (&Attribute::TextAnchor,) => {
                    let mut debug_trait_builder = f.debug_tuple("TextAnchor");
                    debug_trait_builder.finish()
                }
                (&Attribute::TextDecoration,) => {
                    let mut debug_trait_builder = f.debug_tuple("TextDecoration");
                    debug_trait_builder.finish()
                }
                (&Attribute::TextRendering,) => {
                    let mut debug_trait_builder = f.debug_tuple("TextRendering");
                    debug_trait_builder.finish()
                }
                (&Attribute::Transform,) => {
                    let mut debug_trait_builder = f.debug_tuple("Transform");
                    debug_trait_builder.finish()
                }
                (&Attribute::Type,) => {
                    let mut debug_trait_builder = f.debug_tuple("Type");
                    debug_trait_builder.finish()
                }
                (&Attribute::UnicodeBidi,) => {
                    let mut debug_trait_builder = f.debug_tuple("UnicodeBidi");
                    debug_trait_builder.finish()
                }
                (&Attribute::Values,) => {
                    let mut debug_trait_builder = f.debug_tuple("Values");
                    debug_trait_builder.finish()
                }
                (&Attribute::Verts,) => {
                    let mut debug_trait_builder = f.debug_tuple("Verts");
                    debug_trait_builder.finish()
                }
                (&Attribute::ViewBox,) => {
                    let mut debug_trait_builder = f.debug_tuple("ViewBox");
                    debug_trait_builder.finish()
                }
                (&Attribute::Visibility,) => {
                    let mut debug_trait_builder = f.debug_tuple("Visibility");
                    debug_trait_builder.finish()
                }
                (&Attribute::Width,) => {
                    let mut debug_trait_builder = f.debug_tuple("Width");
                    debug_trait_builder.finish()
                }
                (&Attribute::WritingMode,) => {
                    let mut debug_trait_builder = f.debug_tuple("WritingMode");
                    debug_trait_builder.finish()
                }
                (&Attribute::X,) => {
                    let mut debug_trait_builder = f.debug_tuple("X");
                    debug_trait_builder.finish()
                }
                (&Attribute::X1,) => {
                    let mut debug_trait_builder = f.debug_tuple("X1");
                    debug_trait_builder.finish()
                }
                (&Attribute::Y1,) => {
                    let mut debug_trait_builder = f.debug_tuple("Y1");
                    debug_trait_builder.finish()
                }
                (&Attribute::X2,) => {
                    let mut debug_trait_builder = f.debug_tuple("X2");
                    debug_trait_builder.finish()
                }
                (&Attribute::Y2,) => {
                    let mut debug_trait_builder = f.debug_tuple("Y2");
                    debug_trait_builder.finish()
                }
                (&Attribute::XChannelSelector,) => {
                    let mut debug_trait_builder = f.debug_tuple("XChannelSelector");
                    debug_trait_builder.finish()
                }
                (&Attribute::XlinkHref,) => {
                    let mut debug_trait_builder = f.debug_tuple("XlinkHref");
                    debug_trait_builder.finish()
                }
                (&Attribute::XmlLang,) => {
                    let mut debug_trait_builder = f.debug_tuple("XmlLang");
                    debug_trait_builder.finish()
                }
                (&Attribute::XmlSpace,) => {
                    let mut debug_trait_builder = f.debug_tuple("XmlSpace");
                    debug_trait_builder.finish()
                }
                (&Attribute::Y,) => {
                    let mut debug_trait_builder = f.debug_tuple("Y");
                    debug_trait_builder.finish()
                }
                (&Attribute::YChannelSelector,) => {
                    let mut debug_trait_builder = f.debug_tuple("YChannelSelector");
                    debug_trait_builder.finish()
                }
                (&Attribute::Z,) => {
                    let mut debug_trait_builder = f.debug_tuple("Z");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Attribute {
        #[inline]
        fn clone(&self) -> Attribute {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Attribute {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Attribute {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Attribute {
        #[inline]
        fn eq(&self, other: &Attribute) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::hash::Hash for Attribute {
        fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::std::hash::Hash::hash(
                    &unsafe { ::std::intrinsics::discriminant_value(self) },
                    state,
                ),
            }
        }
    }
    static ATTRIBUTES: phf::Map<&'static str, Attribute> = phf::Map {
        key: 9603444721912725599,
        disps: phf::Slice::Static(&[
            (0, 9),
            (0, 5),
            (7, 129),
            (0, 45),
            (0, 93),
            (0, 9),
            (2, 103),
            (0, 105),
            (0, 6),
            (1, 48),
            (5, 2),
            (0, 18),
            (0, 5),
            (2, 38),
            (0, 0),
            (0, 30),
            (0, 130),
            (1, 37),
            (3, 59),
            (1, 0),
            (0, 45),
            (14, 42),
            (11, 51),
            (0, 1),
            (12, 121),
            (1, 24),
            (13, 130),
            (0, 69),
            (33, 59),
            (0, 4),
        ]),
        entries: phf::Slice::Static(&[
            ("clipPathUnits", Attribute::ClipPathUnits),
            ("requiredFeatures", Attribute::RequiredFeatures),
            ("width", Attribute::Width),
            ("points", Attribute::Points),
            ("font-family", Attribute::FontFamily),
            ("stroke-width", Attribute::StrokeWidth),
            ("fill-opacity", Attribute::FillOpacity),
            ("k1", Attribute::K1),
            ("pointsAtX", Attribute::PointsAtX),
            ("text-decoration", Attribute::TextDecoration),
            ("stroke-linejoin", Attribute::StrokeLinejoin),
            ("visibility", Attribute::Visibility),
            ("amplitude", Attribute::Amplitude),
            ("baseline-shift", Attribute::BaselineShift),
            ("patternUnits", Attribute::PatternUnits),
            ("stdDeviation", Attribute::StdDeviation),
            ("id", Attribute::Id),
            ("orient", Attribute::Orient),
            ("limitingConeAngle", Attribute::LimitingConeAngle),
            ("targetX", Attribute::TargetX),
            ("color", Attribute::Color),
            ("primitiveUnits", Attribute::PrimitiveUnits),
            ("elevation", Attribute::Elevation),
            ("mode", Attribute::Mode),
            ("result", Attribute::Result),
            ("text-anchor", Attribute::TextAnchor),
            ("marker-mid", Attribute::MarkerMid),
            ("comp-op", Attribute::CompOp),
            ("refY", Attribute::RefY),
            ("specularConstant", Attribute::SpecularConstant),
            ("viewBox", Attribute::ViewBox),
            ("stroke-miterlimit", Attribute::StrokeMiterlimit),
            ("scale", Attribute::Scale),
            ("marker-end", Attribute::MarkerEnd),
            ("pointsAtZ", Attribute::PointsAtZ),
            ("x2", Attribute::X2),
            ("r", Attribute::R),
            ("dx", Attribute::Dx),
            ("cx", Attribute::Cx),
            ("exponent", Attribute::Exponent),
            ("lighting-color", Attribute::LightingColor),
            ("in2", Attribute::In2),
            ("encoding", Attribute::Encoding),
            ("preserveAlpha", Attribute::PreserveAlpha),
            ("clip-path", Attribute::ClipPath),
            ("kernelMatrix", Attribute::KernelMatrix),
            ("dy", Attribute::Dy),
            ("specularExponent", Attribute::SpecularExponent),
            ("xlink:href", Attribute::XlinkHref),
            ("patternContentUnits", Attribute::PatternContentUnits),
            ("ry", Attribute::Ry),
            ("maskUnits", Attribute::MaskUnits),
            ("patternTransform", Attribute::PatternTransform),
            ("in", Attribute::In),
            ("y", Attribute::Y),
            ("filterUnits", Attribute::FilterUnits),
            ("unicode-bidi", Attribute::UnicodeBidi),
            ("xml:lang", Attribute::XmlLang),
            ("writing-mode", Attribute::WritingMode),
            ("pointsAtY", Attribute::PointsAtY),
            ("spreadMethod", Attribute::SpreadMethod),
            ("seed", Attribute::Seed),
            ("bias", Attribute::Bias),
            ("x1", Attribute::X1),
            ("systemLanguage", Attribute::SystemLanguage),
            ("stroke-dasharray", Attribute::StrokeDasharray),
            ("targetY", Attribute::TargetY),
            ("values", Attribute::Values),
            (
                "color-interpolation-filters",
                Attribute::ColorInterpolationFilters,
            ),
            ("verts", Attribute::Verts),
            ("stroke-dashoffset", Attribute::StrokeDashoffset),
            ("y2", Attribute::Y2),
            ("stroke", Attribute::Stroke),
            ("markerUnits", Attribute::MarkerUnits),
            ("font-weight", Attribute::FontWeight),
            ("xChannelSelector", Attribute::XChannelSelector),
            ("tableValues", Attribute::TableValues),
            ("overflow", Attribute::Overflow),
            ("href", Attribute::Href),
            ("flood-color", Attribute::FloodColor),
            ("divisor", Attribute::Divisor),
            ("enable-background", Attribute::EnableBackground),
            ("surfaceScale", Attribute::SurfaceScale),
            ("marker-start", Attribute::MarkerStart),
            ("numOctaves", Attribute::NumOctaves),
            ("y1", Attribute::Y1),
            ("style", Attribute::Style),
            ("text-rendering", Attribute::TextRendering),
            ("maskContentUnits", Attribute::MaskContentUnits),
            ("k4", Attribute::K4),
            ("parse", Attribute::Parse),
            ("filter", Attribute::Filter),
            ("display", Attribute::Display),
            ("requiredExtensions", Attribute::RequiredExtensions),
            ("fill-rule", Attribute::FillRule),
            ("cy", Attribute::Cy),
            ("markerWidth", Attribute::MarkerWidth),
            ("z", Attribute::Z),
            ("gradientUnits", Attribute::GradientUnits),
            ("alternate", Attribute::Alternate),
            ("font-style", Attribute::FontStyle),
            ("gradientTransform", Attribute::GradientTransform),
            ("stroke-linecap", Attribute::StrokeLinecap),
            ("intercept", Attribute::Intercept),
            ("d", Attribute::D),
            ("font-size", Attribute::FontSize),
            ("shape-rendering", Attribute::ShapeRendering),
            ("flood-opacity", Attribute::FloodOpacity),
            ("stop-color", Attribute::StopColor),
            ("k2", Attribute::K2),
            ("preserveAspectRatio", Attribute::PreserveAspectRatio),
            ("slope", Attribute::Slope),
            ("markerHeight", Attribute::MarkerHeight),
            ("xml:space", Attribute::XmlSpace),
            ("k3", Attribute::K3),
            ("font-stretch", Attribute::FontStretch),
            ("stop-opacity", Attribute::StopOpacity),
            ("fill", Attribute::Fill),
            ("letter-spacing", Attribute::LetterSpacing),
            ("kernelUnitLength", Attribute::KernelUnitLength),
            ("stroke-opacity", Attribute::StrokeOpacity),
            ("fx", Attribute::Fx),
            ("operator", Attribute::Operator),
            ("mask", Attribute::Mask),
            ("radius", Attribute::Radius),
            ("baseFrequency", Attribute::BaseFrequency),
            ("offset", Attribute::Offset),
            ("diffuseConstant", Attribute::DiffuseConstant),
            ("clip-rule", Attribute::ClipRule),
            ("opacity", Attribute::Opacity),
            ("type", Attribute::Type),
            ("order", Attribute::Order),
            ("edgeMode", Attribute::EdgeMode),
            ("transform", Attribute::Transform),
            ("height", Attribute::Height),
            ("marker", Attribute::Marker),
            ("rx", Attribute::Rx),
            ("font-variant", Attribute::FontVariant),
            ("x", Attribute::X),
            ("fy", Attribute::Fy),
            ("stitchTiles", Attribute::StitchTiles),
            ("class", Attribute::Class),
            ("path", Attribute::Path),
            ("azimuth", Attribute::Azimuth),
            ("refX", Attribute::RefX),
            ("yChannelSelector", Attribute::YChannelSelector),
            ("direction", Attribute::Direction),
        ]),
    };
    impl FromStr for Attribute {
        type Err = ();
        fn from_str(s: &str) -> Result<Attribute, ()> {
            ATTRIBUTES.get(s).cloned().ok_or(())
        }
    }
    impl Attribute {
        pub fn to_str(&self) -> &'static str {
            for (k, v) in ATTRIBUTES.entries() {
                if *v == *self {
                    return k;
                }
            }
            {
                {
                    ::rt::begin_panic(
                        "internal error: entered unreachable code",
                        &("rsvg_internals/src/attributes.rs", 32u32, 9u32),
                    )
                }
            };
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_attribute_from_name(
        raw_name: *const libc::c_char,
        out_attr: *mut Attribute,
    ) -> glib_sys::gboolean {
        let name = unsafe { utf8_cstr(raw_name) };
        match Attribute::from_str(name) {
            Ok(a) => {
                unsafe {
                    *out_attr = a;
                }
                true.to_glib()
            }
            Err(_) => false.to_glib(),
        }
    }
}
mod bbox {
    use cairo;
    use cairo::MatrixTrait;
    use rect::RectangleExt;
    #[rustc_copy_clone_marker]
    pub struct BoundingBox {
        pub affine: cairo::Matrix,
        pub rect: Option<cairo::Rectangle>,
        pub ink_rect: Option<cairo::Rectangle>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for BoundingBox {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                BoundingBox {
                    affine: ref __self_0_0,
                    rect: ref __self_0_1,
                    ink_rect: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("BoundingBox");
                    let _ = debug_trait_builder.field("affine", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("rect", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("ink_rect", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for BoundingBox {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for BoundingBox {
        #[inline]
        fn clone(&self) -> BoundingBox {
            {
                let _: ::std::clone::AssertParamIsClone<cairo::Matrix>;
                let _: ::std::clone::AssertParamIsClone<Option<cairo::Rectangle>>;
                let _: ::std::clone::AssertParamIsClone<Option<cairo::Rectangle>>;
                *self
            }
        }
    }
    impl BoundingBox {
        pub fn new(affine: &cairo::Matrix) -> BoundingBox {
            BoundingBox {
                affine: *affine,
                rect: None,
                ink_rect: None,
            }
        }
        pub fn with_rect(self, rect: Option<cairo::Rectangle>) -> BoundingBox {
            BoundingBox { rect, ..self }
        }
        pub fn with_extents(self, extents: (f64, f64, f64, f64)) -> BoundingBox {
            let rect = rect_from_extents(extents);
            BoundingBox { rect, ..self }
        }
        pub fn with_ink_extents(self, extents: (f64, f64, f64, f64)) -> BoundingBox {
            let ink_rect = rect_from_extents(extents);
            BoundingBox { ink_rect, ..self }
        }
        fn combine(&mut self, src: &BoundingBox, clip: bool) {
            if src.rect.is_none() && src.ink_rect.is_none() {
                return;
            }
            let mut affine = self.affine;
            affine.invert();
            affine = cairo::Matrix::multiply(&src.affine, &affine);
            self.rect = combine_rects(self.rect, src.rect, &affine, clip);
            self.ink_rect = combine_rects(self.ink_rect, src.ink_rect, &affine, clip);
        }
        pub fn insert(&mut self, src: &BoundingBox) {
            self.combine(src, false);
        }
        pub fn clip(&mut self, src: &BoundingBox) {
            self.combine(src, true);
        }
    }
    fn rect_from_extents((x1, y1, x2, y2): (f64, f64, f64, f64)) -> Option<cairo::Rectangle> {
        Some(cairo::Rectangle {
            x: x1,
            y: y1,
            width: x2 - x1,
            height: y2 - y1,
        })
    }
    fn combine_rects(
        r1: Option<cairo::Rectangle>,
        r2: Option<cairo::Rectangle>,
        affine: &cairo::Matrix,
        clip: bool,
    ) -> Option<cairo::Rectangle> {
        match (r1, r2, clip) {
            (r1, None, _) => r1,
            (None, Some(r2), _) => Some(r2.transform(&affine)),
            (Some(r1), Some(r2), true) => Some(r2.transform(&affine).intersect(&r1)),
            (Some(r1), Some(r2), false) => Some(r2.transform(&affine).union(&r1)),
        }
    }
}
mod clip_path {
    use attributes::Attribute;
    use cairo::{self, MatrixTrait};
    use coord_units::CoordUnits;
    use drawing_ctx::DrawingCtx;
    use handle::RsvgHandle;
    use node::{NodeResult, NodeTrait, RsvgNode};
    use parsers::parse;
    use property_bag::PropertyBag;
    use std::cell::Cell;
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct ClipPathUnits(pub CoordUnits);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ClipPathUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ClipPathUnits(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipPathUnits");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ClipPathUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ClipPathUnits {
        #[inline]
        fn clone(&self) -> ClipPathUnits {
            {
                let _: ::std::clone::AssertParamIsClone<CoordUnits>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ClipPathUnits {
        #[inline]
        fn eq(&self, other: &ClipPathUnits) -> bool {
            match *other {
                ClipPathUnits(ref __self_1_0) => match *self {
                    ClipPathUnits(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ClipPathUnits) -> bool {
            match *other {
                ClipPathUnits(ref __self_1_0) => match *self {
                    ClipPathUnits(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for ClipPathUnits {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<CoordUnits>;
            }
        }
    }
    impl Default for ClipPathUnits {
        fn default() -> Self {
            ClipPathUnits(CoordUnits::UserSpaceOnUse)
        }
    }
    impl From<ClipPathUnits> for CoordUnits {
        fn from(u: ClipPathUnits) -> Self {
            u.0
        }
    }
    impl ::parsers::Parse for ClipPathUnits {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(parser: &mut ::cssparser::Parser, _: ()) -> Result<Self, ::error::AttributeError> {
            Ok(ClipPathUnits(::coord_units::CoordUnits::parse(parser, ())?))
        }
    }
    pub struct NodeClipPath {
        units: Cell<ClipPathUnits>,
    }
    impl NodeClipPath {
        pub fn new() -> NodeClipPath {
            NodeClipPath {
                units: Cell::new(ClipPathUnits::default()),
            }
        }
        pub fn get_units(&self) -> ClipPathUnits {
            self.units.get()
        }
        pub fn to_cairo_context(
            &self,
            node: &RsvgNode,
            affine_before_clip: &cairo::Matrix,
            draw_ctx: &mut DrawingCtx,
        ) {
            let cascaded = node.get_cascaded_values();
            let clip_units = self.units.get();
            let orig_bbox = draw_ctx.get_bbox().clone();
            let child_matrix = if clip_units == ClipPathUnits(CoordUnits::ObjectBoundingBox) {
                if orig_bbox.rect.is_none() {
                    return;
                }
                let rect = orig_bbox.rect.unwrap();
                let mut bbtransform =
                    cairo::Matrix::new(rect.width, 0.0, 0.0, rect.height, rect.x, rect.y);
                cairo::Matrix::multiply(&bbtransform, affine_before_clip)
            } else {
                *affine_before_clip
            };
            let cr = draw_ctx.get_cairo_context();
            let save_affine = cr.get_matrix();
            cr.set_matrix(child_matrix);
            node.draw_children(&cascaded, draw_ctx, true);
            cr.set_matrix(save_affine);
            draw_ctx.set_bbox(&orig_bbox);
            let cr = draw_ctx.get_cairo_context();
            cr.clip();
        }
    }
    impl NodeTrait for NodeClipPath {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::ClipPathUnits => self.units.set(parse("clipPathUnits", value, ())?),
                    _ => (),
                }
            }
            Ok(())
        }
    }
}
mod cnode {
    use handle::*;
    use libc;
    use node::*;
    use property_bag::PropertyBag;
    use state::rsvg_state_new;
    use std::rc::*;
    use util::utf8_cstr_opt;
    type CNodeSetAtts = unsafe extern "C" fn(
        node: *const RsvgNode,
        node_impl: *const RsvgCNodeImpl,
        handle: *const RsvgHandle,
        pbag: *const PropertyBag,
    );
    type CNodeFree = unsafe extern "C" fn(node_impl: *const RsvgCNodeImpl);
    struct CNode {
        c_node_impl: *const RsvgCNodeImpl,
        set_atts_fn: CNodeSetAtts,
        free_fn: CNodeFree,
    }
    impl NodeTrait for CNode {
        fn set_atts(
            &self,
            node: &RsvgNode,
            handle: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            unsafe {
                (self.set_atts_fn)(
                    node as *const RsvgNode,
                    self.c_node_impl,
                    handle,
                    pbag.ffi(),
                );
            }
            node.get_result()
        }
        fn get_c_impl(&self) -> *const RsvgCNodeImpl {
            self.c_node_impl
        }
    }
    impl Drop for CNode {
        fn drop(&mut self) {
            unsafe {
                (self.free_fn)(self.c_node_impl);
            }
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_rust_cnode_new(
        node_type: NodeType,
        raw_parent: *const RsvgNode,
        id: *const libc::c_char,
        class: *const libc::c_char,
        c_node_impl: *const RsvgCNodeImpl,
        set_atts_fn: CNodeSetAtts,
        free_fn: CNodeFree,
    ) -> *const RsvgNode {
        if !!c_node_impl.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !c_node_impl.is_null()",
                    &("rsvg_internals/src/cnode.rs", 68u32, 5u32),
                )
            }
        };
        let cnode = CNode {
            c_node_impl,
            set_atts_fn,
            free_fn,
        };
        box_node(Rc::new(Node::new(
            node_type,
            node_ptr_to_weak(raw_parent),
            unsafe { utf8_cstr_opt(id) },
            unsafe { utf8_cstr_opt(class) },
            rsvg_state_new(),
            Box::new(cnode),
        )))
    }
    #[no_mangle]
    pub extern "C" fn rsvg_rust_cnode_get_impl(raw_node: *const RsvgNode) -> *const RsvgCNodeImpl {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/cnode.rs", 88u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        node.get_c_impl()
    }
}
mod color {
    pub use cssparser::Color;
    use cssparser::{self, Parser};
    use error::*;
    use libc;
    use parsers::Parse;
    use parsers::ParseError;
    use util::utf8_cstr;
    impl Parse for cssparser::Color {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: Self::Data) -> Result<cssparser::Color, AttributeError> {
            cssparser::Color::parse(parser)
                .map_err(|_| AttributeError::Parse(ParseError::new("invalid syntax for color")))
        }
    }
    impl Parse for cssparser::RGBA {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: Self::Data) -> Result<cssparser::RGBA, AttributeError> {
            match cssparser::Color::parse(parser) {
                Ok(cssparser::Color::RGBA(rgba)) => Ok(rgba),
                Ok(cssparser::Color::CurrentColor) => Err(AttributeError::Value(
                    "currentColor is not allowed here".to_string(),
                )),
                _ => Err(AttributeError::Parse(ParseError::new(
                    "invalid syntax for color",
                ))),
            }
        }
    }
    #[repr(C)]
    #[rustc_copy_clone_marker]
    pub enum ColorKind {
        Inherit,
        CurrentColor,
        ARGB,
        ParseError,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ColorKind {
        #[inline]
        fn clone(&self) -> ColorKind {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ColorKind {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ColorKind {
        #[inline]
        fn eq(&self, other: &ColorKind) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ColorKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&ColorKind::Inherit,) => {
                    let mut debug_trait_builder = f.debug_tuple("Inherit");
                    debug_trait_builder.finish()
                }
                (&ColorKind::CurrentColor,) => {
                    let mut debug_trait_builder = f.debug_tuple("CurrentColor");
                    debug_trait_builder.finish()
                }
                (&ColorKind::ARGB,) => {
                    let mut debug_trait_builder = f.debug_tuple("ARGB");
                    debug_trait_builder.finish()
                }
                (&ColorKind::ParseError,) => {
                    let mut debug_trait_builder = f.debug_tuple("ParseError");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[repr(C)]
    #[rustc_copy_clone_marker]
    pub struct ColorSpec {
        kind: ColorKind,
        argb: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ColorSpec {
        #[inline]
        fn clone(&self) -> ColorSpec {
            {
                let _: ::std::clone::AssertParamIsClone<ColorKind>;
                let _: ::std::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ColorSpec {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ColorSpec {
        #[inline]
        fn eq(&self, other: &ColorSpec) -> bool {
            match *other {
                ColorSpec {
                    kind: ref __self_1_0,
                    argb: ref __self_1_1,
                } => match *self {
                    ColorSpec {
                        kind: ref __self_0_0,
                        argb: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ColorSpec) -> bool {
            match *other {
                ColorSpec {
                    kind: ref __self_1_0,
                    argb: ref __self_1_1,
                } => match *self {
                    ColorSpec {
                        kind: ref __self_0_0,
                        argb: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ColorSpec {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ColorSpec {
                    kind: ref __self_0_0,
                    argb: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("ColorSpec");
                    let _ = debug_trait_builder.field("kind", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("argb", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    pub fn rgba_to_argb(rgba: cssparser::RGBA) -> u32 {
        u32::from(rgba.alpha) << 24
            | u32::from(rgba.red) << 16
            | u32::from(rgba.green) << 8
            | u32::from(rgba.blue)
    }
    impl From<Result<Option<cssparser::Color>, AttributeError>> for ColorSpec {
        fn from(result: Result<Option<cssparser::Color>, AttributeError>) -> ColorSpec {
            match result {
                Ok(None) => ColorSpec {
                    kind: ColorKind::Inherit,
                    argb: 0,
                },
                Ok(Some(cssparser::Color::CurrentColor)) => ColorSpec {
                    kind: ColorKind::CurrentColor,
                    argb: 0,
                },
                Ok(Some(cssparser::Color::RGBA(rgba))) => ColorSpec {
                    kind: ColorKind::ARGB,
                    argb: rgba_to_argb(rgba),
                },
                _ => ColorSpec {
                    kind: ColorKind::ParseError,
                    argb: 0,
                },
            }
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_css_parse_color(string: *const libc::c_char) -> ColorSpec {
        let s = unsafe { utf8_cstr(string) };
        if s == "inherit" {
            ColorSpec {
                kind: ColorKind::Inherit,
                argb: 0,
            }
        } else {
            ColorSpec::from(<Color as Parse>::parse_str(s, ()).map(|v| Some(v)))
        }
    }
}
mod cond {
    use error::*;
    #[allow(unused_imports, deprecated)]
    use std::ascii::AsciiExt;
    use std::marker::PhantomData;
    static IMPLEMENTED_EXTENSIONS: &[&str] = &[];
    pub struct RequiredExtensions(pub bool);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for RequiredExtensions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                RequiredExtensions(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("RequiredExtensions");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for RequiredExtensions {
        #[inline]
        fn eq(&self, other: &RequiredExtensions) -> bool {
            match *other {
                RequiredExtensions(ref __self_1_0) => match *self {
                    RequiredExtensions(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &RequiredExtensions) -> bool {
            match *other {
                RequiredExtensions(ref __self_1_0) => match *self {
                    RequiredExtensions(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl RequiredExtensions {
        pub fn from_attribute(s: &str) -> Result<RequiredExtensions, AttributeError> {
            Ok(RequiredExtensions(
                s.split_whitespace()
                    .all(|f| IMPLEMENTED_EXTENSIONS.binary_search(&f).is_ok()),
            ))
        }
    }
    static IMPLEMENTED_FEATURES: &[&str] = &[
        "http://www.w3.org/TR/SVG11/feature#BasicFilter",
        "http://www.w3.org/TR/SVG11/feature#BasicGraphicsAttribute",
        "http://www.w3.org/TR/SVG11/feature#BasicPaintAttribute",
        "http://www.w3.org/TR/SVG11/feature#BasicStructure",
        "http://www.w3.org/TR/SVG11/feature#BasicText",
        "http://www.w3.org/TR/SVG11/feature#ConditionalProcessing",
        "http://www.w3.org/TR/SVG11/feature#ContainerAttribute",
        "http://www.w3.org/TR/SVG11/feature#Filter",
        "http://www.w3.org/TR/SVG11/feature#Gradient",
        "http://www.w3.org/TR/SVG11/feature#Image",
        "http://www.w3.org/TR/SVG11/feature#Marker",
        "http://www.w3.org/TR/SVG11/feature#Mask",
        "http://www.w3.org/TR/SVG11/feature#OpacityAttribute",
        "http://www.w3.org/TR/SVG11/feature#Pattern",
        "http://www.w3.org/TR/SVG11/feature#SVG",
        "http://www.w3.org/TR/SVG11/feature#SVG-static",
        "http://www.w3.org/TR/SVG11/feature#Shape",
        "http://www.w3.org/TR/SVG11/feature#Structure",
        "http://www.w3.org/TR/SVG11/feature#Style",
        "http://www.w3.org/TR/SVG11/feature#View",
        "org.w3c.svg.static",
    ];
    pub struct RequiredFeatures(pub bool);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for RequiredFeatures {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                RequiredFeatures(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("RequiredFeatures");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for RequiredFeatures {
        #[inline]
        fn eq(&self, other: &RequiredFeatures) -> bool {
            match *other {
                RequiredFeatures(ref __self_1_0) => match *self {
                    RequiredFeatures(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &RequiredFeatures) -> bool {
            match *other {
                RequiredFeatures(ref __self_1_0) => match *self {
                    RequiredFeatures(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl RequiredFeatures {
        pub fn from_attribute(s: &str) -> Result<RequiredFeatures, AttributeError> {
            Ok(RequiredFeatures(
                s.split_whitespace()
                    .all(|f| IMPLEMENTED_FEATURES.binary_search(&f).is_ok()),
            ))
        }
    }
    pub struct SystemLanguage<'a>(pub bool, pub PhantomData<&'a i8>);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::fmt::Debug for SystemLanguage<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                SystemLanguage(ref __self_0_0, ref __self_0_1) => {
                    let mut debug_trait_builder = f.debug_tuple("SystemLanguage");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    let _ = debug_trait_builder.field(&&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::std::cmp::PartialEq for SystemLanguage<'a> {
        #[inline]
        fn eq(&self, other: &SystemLanguage<'a>) -> bool {
            match *other {
                SystemLanguage(ref __self_1_0, ref __self_1_1) => match *self {
                    SystemLanguage(ref __self_0_0, ref __self_0_1) => {
                        (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &SystemLanguage<'a>) -> bool {
            match *other {
                SystemLanguage(ref __self_1_0, ref __self_1_1) => match *self {
                    SystemLanguage(ref __self_0_0, ref __self_0_1) => {
                        (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1)
                    }
                },
            }
        }
    }
    impl<'a> SystemLanguage<'a> {
        pub fn from_attribute(
            s: &str,
            system_languages: &[String],
        ) -> Result<SystemLanguage<'a>, AttributeError> {
            Ok(SystemLanguage(
                s.split(',')
                    .map(|s| s.trim())
                    .filter(|s| !s.is_empty())
                    .any(|l| {
                        system_languages.iter().any(|sl| {
                            if sl.eq_ignore_ascii_case(l) {
                                return true;
                            }
                            if let Some(offset) = l.find('-') {
                                return sl.eq_ignore_ascii_case(&l[..offset]);
                            }
                            false
                        })
                    }),
                PhantomData,
            ))
        }
    }
}
mod defs {
    use glib::translate::*;
    use libc;
    use node::RsvgNode;
    pub enum RsvgDefs {}
    #[allow(improper_ctypes)]
    extern "C" {
        fn rsvg_defs_register_node_by_id(
            defs: *mut RsvgDefs,
            id: *const libc::c_char,
            node: *const RsvgNode,
        );
        fn rsvg_defs_lookup(defs: *const RsvgDefs, name: *const libc::c_char) -> *mut RsvgNode;
    }
    pub fn register_node_by_id(defs: *mut RsvgDefs, id: &str, node: &RsvgNode) {
        unsafe {
            rsvg_defs_register_node_by_id(defs, id.to_glib_none().0, node);
        }
    }
    pub fn lookup(defs: *const RsvgDefs, name: &str) -> Option<&mut RsvgNode> {
        unsafe {
            let node = rsvg_defs_lookup(defs, name.to_glib_none().0);
            if node.is_null() {
                None
            } else {
                Some(&mut *node)
            }
        }
    }
}
mod drawing_ctx {
    use bbox::BoundingBox;
    use cairo;
    use cairo::MatrixTrait;
    use cairo_sys;
    use clip_path::{ClipPathUnits, NodeClipPath};
    use coord_units::CoordUnits;
    use defs::{self, RsvgDefs};
    use filters::filter_render;
    use float_eq_cairo::ApproxEqCairo;
    use glib::translate::*;
    use glib_sys;
    use length::Dasharray;
    use libc;
    use mask::NodeMask;
    use node::{CascadedValues, NodeType, RsvgNode};
    use paint_server::{self, PaintServer};
    use pango::{self, ContextExt, FontMapExt, LayoutExt};
    use pango_cairo_sys;
    use pango_sys;
    use pangocairo;
    use rect::RectangleExt;
    use state::{
        ClipRule, CompOp, ComputedValues, EnableBackground, FillRule, ShapeRendering,
        StrokeDasharray, StrokeLinecap, StrokeLinejoin, TextRendering,
    };
    use std::cell::RefCell;
    use std::rc::Rc;
    use unitinterval::UnitInterval;
    use viewbox::ViewBox;
    pub enum RsvgDrawingCtx {}
    pub struct DrawingCtx {
        rect: cairo::Rectangle,
        dpi_x: f64,
        dpi_y: f64,
        cr_stack: Vec<cairo::Context>,
        cr: cairo::Context,
        initial_cr: cairo::Context,
        surfaces_stack: Vec<cairo::ImageSurface>,
        vb: ViewBox,
        vb_stack: Vec<ViewBox>,
        bbox: BoundingBox,
        bbox_stack: Vec<BoundingBox>,
        drawsub_stack: Vec<RsvgNode>,
        defs: *const RsvgDefs,
        acquired_nodes: RefCell<Vec<RsvgNode>>,
        is_testing: bool,
    }
    impl<'a> DrawingCtx {
        pub fn new(
            cr: cairo::Context,
            width: f64,
            height: f64,
            vb_width: f64,
            vb_height: f64,
            dpi_x: f64,
            dpi_y: f64,
            defs: *const RsvgDefs,
            is_testing: bool,
        ) -> DrawingCtx {
            let mut affine = cr.get_matrix();
            let rect = cairo::Rectangle {
                x: 0.0,
                y: 0.0,
                width,
                height,
            }.transform(&affine)
                .outer();
            let mut scale = cairo::Matrix::identity();
            scale.scale(width / vb_width, height / vb_height);
            affine = cairo::Matrix::multiply(&affine, &scale);
            affine.x0 -= rect.x;
            affine.y0 -= rect.y;
            cr.set_matrix(affine);
            DrawingCtx {
                rect,
                dpi_x,
                dpi_y,
                cr_stack: Vec::new(),
                cr: cr.clone(),
                initial_cr: cr.clone(),
                surfaces_stack: Vec::new(),
                vb: ViewBox::new(0.0, 0.0, vb_width, vb_height),
                vb_stack: Vec::new(),
                bbox: BoundingBox::new(&affine),
                bbox_stack: Vec::new(),
                drawsub_stack: Vec::new(),
                defs,
                acquired_nodes: RefCell::new(Vec::new()),
                is_testing,
            }
        }
        pub fn get_cairo_context(&self) -> cairo::Context {
            self.cr.clone()
        }
        pub fn set_cairo_context(&mut self, cr: &cairo::Context) {
            self.cr = cr.clone();
        }
        pub fn is_cairo_context_nested(&self, cr: &cairo::Context) -> bool {
            cr.to_raw_none() != self.initial_cr.to_raw_none()
        }
        pub fn get_cr_stack(&self) -> &Vec<cairo::Context> {
            &self.cr_stack
        }
        pub fn get_width(&self) -> f64 {
            self.rect.width
        }
        pub fn get_height(&self) -> f64 {
            self.rect.height
        }
        pub fn get_raw_offset(&self) -> (f64, f64) {
            (self.rect.x, self.rect.y)
        }
        pub fn get_offset(&self) -> (f64, f64) {
            if self.is_cairo_context_nested(&self.get_cairo_context()) {
                (0.0, 0.0)
            } else {
                (self.rect.x, self.rect.y)
            }
        }
        pub fn get_dpi(&self) -> (f64, f64) {
            (self.dpi_x, self.dpi_y)
        }
        pub fn get_view_box_size(&self) -> (f64, f64) {
            (self.vb.0.width, self.vb.0.height)
        }
        pub fn push_view_box(&mut self, width: f64, height: f64) {
            self.vb_stack.push(self.vb);
            self.vb = ViewBox::new(0.0, 0.0, width, height);
        }
        pub fn pop_view_box(&mut self) {
            self.vb = self.vb_stack.pop().unwrap();
        }
        pub fn insert_bbox(&mut self, bbox: &BoundingBox) {
            self.bbox.insert(bbox);
        }
        pub fn set_bbox(&mut self, bbox: &BoundingBox) {
            self.bbox = *bbox;
        }
        pub fn get_bbox(&self) -> &BoundingBox {
            &self.bbox
        }
        pub fn get_acquired_node(&mut self, url: &str) -> Option<AcquiredNode> {
            if let Some(node) = defs::lookup(self.defs, url) {
                if !self.acquired_nodes_contains(node) {
                    self.acquired_nodes.borrow_mut().push(node.clone());
                    return Some(AcquiredNode(&self.acquired_nodes as *const _, node.clone()));
                }
            }
            None
        }
        fn acquired_nodes_contains(&self, node: &RsvgNode) -> bool {
            self.acquired_nodes
                .borrow()
                .iter()
                .find(|n| Rc::ptr_eq(n, node))
                .is_some()
        }
        pub fn get_acquired_node_of_type(
            &mut self,
            url: Option<&str>,
            node_type: NodeType,
        ) -> Option<AcquiredNode> {
            url.and_then(move |url| self.get_acquired_node(url))
                .and_then(|acquired| {
                    if acquired.get().get_type() == node_type {
                        Some(acquired)
                    } else {
                        None
                    }
                })
        }
        pub fn with_discrete_layer(
            &mut self,
            node: &RsvgNode,
            values: &ComputedValues,
            clipping: bool,
            draw_fn: &mut FnMut(&mut DrawingCtx),
        ) {
            if clipping {
                draw_fn(self);
            } else {
                let original_cr = self.cr.clone();
                original_cr.save();
                let clip_uri = values.clip_path.0.get();
                let mask = values.mask.0.get();
                let filter = if node.get_type() == NodeType::Mask {
                    None
                } else {
                    values.filter.0.get()
                };
                let UnitInterval(opacity) = values.opacity.0;
                let comp_op = values.comp_op;
                let enable_background = values.enable_background;
                let affine = original_cr.get_matrix();
                let (clip_node, clip_units) = {
                    let clip_node = self
                        .get_acquired_node_of_type(clip_uri, NodeType::ClipPath)
                        .and_then(|acquired| Some(acquired.get()));
                    let mut clip_units = Default::default();
                    if let Some(ref clip_node) = clip_node {
                        clip_node.with_impl(|clip_path: &NodeClipPath| {
                            let ClipPathUnits(u) = clip_path.get_units();
                            clip_units = Some(u);
                        });
                    }
                    (clip_node, clip_units)
                };
                if clip_units == Some(CoordUnits::UserSpaceOnUse) {
                    if let Some(ref clip_node) = clip_node {
                        clip_node.with_impl(|clip_path: &NodeClipPath| {
                            clip_path.to_cairo_context(clip_node, &affine, self);
                        });
                    }
                }
                let needs_temporary_surface = !(opacity == 1.0
                    && filter.is_none()
                    && mask.is_none()
                    && (clip_units == None || clip_units == Some(CoordUnits::UserSpaceOnUse))
                    && comp_op == CompOp::SrcOver
                    && enable_background == EnableBackground::Accumulate);
                let child_surface = {
                    if needs_temporary_surface {
                        let surface = cairo::ImageSurface::create(
                            cairo::Format::ARgb32,
                            self.rect.width as i32,
                            self.rect.height as i32,
                        ).unwrap();
                        if filter.is_some() {
                            self.surfaces_stack.push(surface.clone());
                        }
                        let cr = cairo::Context::new(&surface);
                        cr.set_matrix(affine);
                        self.cr_stack.push(self.cr.clone());
                        self.cr = cr.clone();
                        self.bbox_stack.push(self.bbox);
                        self.bbox = BoundingBox::new(&affine);
                        surface
                    } else {
                        cairo::ImageSurface::from(original_cr.get_target()).unwrap()
                    }
                };
                draw_fn(self);
                if needs_temporary_surface {
                    let filter_result_surface = filter
                        .and_then(|_| {
                            let output = self.surfaces_stack.pop().unwrap();
                            match self.get_acquired_node_of_type(filter, NodeType::Filter) {
                                Some(acquired) => {
                                    let filter_node = acquired.get();
                                    if !filter_node.is_in_error() {
                                        Some(filter_render(&filter_node, node, &output, self))
                                    } else {
                                        None
                                    }
                                }
                                None => Some(
                                    cairo::ImageSurface::create(
                                        cairo::Format::ARgb32,
                                        child_surface.get_width(),
                                        child_surface.get_height(),
                                    ).expect("couldn\'t create an empty surface"),
                                ),
                            }
                        })
                        .or(Some(child_surface))
                        .unwrap();
                    self.cr = self.cr_stack.pop().unwrap();
                    let (xofs, yofs) = self.get_offset();
                    original_cr.identity_matrix();
                    original_cr.set_source_surface(&filter_result_surface, xofs, yofs);
                    if clip_units == Some(CoordUnits::ObjectBoundingBox) {
                        if let Some(ref clip_node) = clip_node {
                            clip_node.with_impl(|clip_path: &NodeClipPath| {
                                clip_path.to_cairo_context(clip_node, &affine, self);
                            });
                        }
                    }
                    original_cr.set_operator(cairo::Operator::from(comp_op));
                    if let Some(mask) = mask {
                        if let Some(acquired) =
                            self.get_acquired_node_of_type(Some(mask), NodeType::Mask)
                        {
                            let node = acquired.get();
                            node.with_impl(|mask: &NodeMask| {
                                mask.generate_cairo_mask(&node, &affine, self);
                            });
                        }
                    } else if opacity < 1.0 {
                        original_cr.paint_with_alpha(opacity);
                    } else {
                        original_cr.paint();
                    }
                    let bbox = self.bbox;
                    self.bbox = self.bbox_stack.pop().unwrap();
                    self.bbox.insert(&bbox);
                }
                original_cr.restore();
            }
        }
        pub fn get_pango_context(&self) -> pango::Context {
            let font_map = pangocairo::FontMap::get_default().unwrap();
            let context = font_map.create_context().unwrap();
            let cr = self.get_cairo_context();
            pangocairo::functions::update_context(&cr, &context);
            set_resolution(&context, self.dpi_x);
            if self.is_testing {
                let mut options = cairo::FontOptions::new();
                options.set_antialias(cairo::Antialias::Gray);
                options.set_hint_style(cairo::enums::HintStyle::Full);
                options.set_hint_metrics(cairo::enums::HintMetrics::On);
                set_font_options(&context, &options);
            }
            context
        }
        pub fn draw_pango_layout(
            &mut self,
            layout: &pango::Layout,
            values: &ComputedValues,
            x: f64,
            y: f64,
            clipping: bool,
        ) {
            let (ink, _) = layout.get_extents();
            if ink.width == 0 || ink.height == 0 {
                return;
            }
            let cr = self.get_cairo_context();
            cr.save();
            self.set_affine_on_cr(&cr);
            let affine = cr.get_matrix();
            let gravity = layout.get_context().unwrap().get_gravity();
            let bbox = compute_text_bbox(&ink, x, y, &affine, gravity);
            if !clipping {
                self.insert_bbox(&bbox);
            }
            cr.set_antialias(cairo::Antialias::from(values.text_rendering));
            self.setup_cr_for_stroke(&cr, values);
            let rotation = unsafe { pango_sys::pango_gravity_to_rotation(gravity.to_glib()) };
            cr.move_to(x, y);
            if !rotation.approx_eq_cairo(&0.0) {
                cr.rotate(-rotation);
            }
            let current_color = &values.color.0;
            let fill_opacity = &values.fill_opacity.0;
            if !clipping {
                if paint_server::set_source_paint_server(
                    self,
                    &values.fill.0,
                    fill_opacity,
                    &bbox,
                    current_color,
                ) {
                    pangocairo::functions::update_layout(&cr, layout);
                    pangocairo::functions::show_layout(&cr, layout);
                }
            }
            let stroke_opacity = &values.stroke_opacity.0;
            let mut need_layout_path = clipping;
            if !clipping {
                if paint_server::set_source_paint_server(
                    self,
                    &values.stroke.0,
                    stroke_opacity,
                    &bbox,
                    &current_color,
                ) {
                    need_layout_path = true;
                }
            }
            if need_layout_path {
                pangocairo::functions::update_layout(&cr, layout);
                pangocairo::functions::layout_path(&cr, layout);
                if !clipping {
                    let ib = BoundingBox::new(&affine).with_ink_extents(cr.stroke_extents());
                    cr.stroke();
                    self.insert_bbox(&ib);
                }
            }
            cr.restore();
        }
        fn setup_cr_for_stroke(&self, cr: &cairo::Context, values: &ComputedValues) {
            cr.set_line_width(values.stroke_width.0.normalize(values, self));
            cr.set_miter_limit(values.stroke_miterlimit.0);
            cr.set_line_cap(cairo::LineCap::from(values.stroke_line_cap));
            cr.set_line_join(cairo::LineJoin::from(values.stroke_line_join));
            if let StrokeDasharray(Dasharray::Array(ref dashes)) = values.stroke_dasharray {
                let normalized_dashes: Vec<f64> =
                    dashes.iter().map(|l| l.normalize(values, self)).collect();
                let total_length = normalized_dashes.iter().fold(0.0, |acc, &len| acc + len);
                if total_length > 0.0 {
                    let offset = values.stroke_dashoffset.0.normalize(values, self);
                    cr.set_dash(&normalized_dashes, offset);
                } else {
                    cr.set_dash(&[], 0.0);
                }
            }
        }
        pub fn stroke_and_fill(&mut self, cr: &cairo::Context, values: &ComputedValues) {
            cr.set_antialias(cairo::Antialias::from(values.shape_rendering));
            self.setup_cr_for_stroke(cr, values);
            let bbox = compute_stroke_and_fill_box(cr, values);
            self.insert_bbox(&bbox);
            let current_color = &values.color.0;
            let fill_opacity = &values.fill_opacity.0;
            if paint_server::set_source_paint_server(
                self,
                &values.fill.0,
                fill_opacity,
                &bbox,
                current_color,
            ) {
                if values.stroke.0 == PaintServer::None {
                    cr.fill();
                } else {
                    cr.fill_preserve();
                }
            }
            let stroke_opacity = values.stroke_opacity.0;
            if paint_server::set_source_paint_server(
                self,
                &values.stroke.0,
                &stroke_opacity,
                &bbox,
                &current_color,
            ) {
                cr.stroke();
            }
            cr.new_path();
        }
        pub fn set_affine_on_cr(&self, cr: &cairo::Context) {
            let (x0, y0) = self.get_offset();
            let affine = cr.get_matrix();
            let matrix = cairo::Matrix::new(
                affine.xx,
                affine.yx,
                affine.xy,
                affine.yy,
                affine.x0 + x0,
                affine.y0 + y0,
            );
            cr.set_matrix(matrix);
        }
        pub fn clip(&mut self, x: f64, y: f64, w: f64, h: f64) {
            let cr = self.get_cairo_context();
            let save_affine = cr.get_matrix();
            self.set_affine_on_cr(&cr);
            cr.rectangle(x, y, w, h);
            cr.clip();
            cr.set_matrix(save_affine);
        }
        pub fn draw_node_on_surface(
            &mut self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            surface: &cairo::ImageSurface,
            width: f64,
            height: f64,
        ) {
            let save_cr = self.cr.clone();
            let save_initial_cr = self.initial_cr.clone();
            let save_rect = self.rect;
            let save_affine = self.get_cairo_context().get_matrix();
            let cr = cairo::Context::new(surface);
            cr.set_matrix(save_affine);
            self.cr = cr;
            self.initial_cr = self.cr.clone();
            self.rect.x = 0.0;
            self.rect.y = 0.0;
            self.rect.width = width;
            self.rect.height = height;
            self.draw_node_from_stack(cascaded, node, false);
            self.cr = save_cr;
            self.initial_cr = save_initial_cr;
            self.rect = save_rect;
        }
        pub fn draw_node_from_stack(
            &mut self,
            cascaded: &CascadedValues,
            node: &RsvgNode,
            clipping: bool,
        ) {
            let mut draw = true;
            let stack_top = self.drawsub_stack.pop();
            if let Some(ref top) = stack_top {
                if !Rc::ptr_eq(top, node) {
                    draw = false;
                }
            }
            if draw {
                let values = cascaded.get();
                if values.is_visible() {
                    node.draw(node, cascaded, self, clipping);
                }
            }
            if let Some(top) = stack_top {
                self.drawsub_stack.push(top);
            }
        }
        pub fn add_node_and_ancestors_to_stack(&mut self, node: &RsvgNode) {
            self.drawsub_stack.push(node.clone());
            if let Some(ref parent) = node.get_parent() {
                self.add_node_and_ancestors_to_stack(parent);
            }
        }
    }
    fn set_resolution(context: &pango::Context, dpi: f64) {
        unsafe {
            pango_cairo_sys::pango_cairo_context_set_resolution(context.to_glib_none().0, dpi);
        }
    }
    fn set_font_options(context: &pango::Context, options: &cairo::FontOptions) {
        unsafe {
            pango_cairo_sys::pango_cairo_context_set_font_options(
                context.to_glib_none().0,
                options.to_glib_none().0,
            );
        }
    }
    fn gravity_is_vertical(gravity: pango::Gravity) -> bool {
        match gravity {
            pango::Gravity::East | pango::Gravity::West => true,
            _ => false,
        }
    }
    fn compute_text_bbox(
        ink: &pango::Rectangle,
        x: f64,
        y: f64,
        affine: &cairo::Matrix,
        gravity: pango::Gravity,
    ) -> BoundingBox {
        let pango_scale = f64::from(pango::SCALE);
        let mut bbox = BoundingBox::new(affine);
        let ink_x = f64::from(ink.x);
        let ink_y = f64::from(ink.y);
        let ink_width = f64::from(ink.width);
        let ink_height = f64::from(ink.height);
        if gravity_is_vertical(gravity) {
            bbox.rect = Some(cairo::Rectangle {
                x: x + (ink_x - ink_height) / pango_scale,
                y: y + ink_y / pango_scale,
                width: ink_height / pango_scale,
                height: ink_width / pango_scale,
            });
        } else {
            bbox.rect = Some(cairo::Rectangle {
                x: x + ink_x / pango_scale,
                y: y + ink_y / pango_scale,
                width: ink_width / pango_scale,
                height: ink_height / pango_scale,
            });
        }
        bbox
    }
    fn compute_stroke_and_fill_box(cr: &cairo::Context, values: &ComputedValues) -> BoundingBox {
        let affine = cr.get_matrix();
        let mut bbox = BoundingBox::new(&affine);
        let backup_tolerance = cr.get_tolerance();
        cr.set_tolerance(1.0);
        let fb = BoundingBox::new(&affine).with_ink_extents(cr.fill_extents());
        bbox.insert(&fb);
        if values.stroke.0 != PaintServer::None {
            let sb = BoundingBox::new(&affine).with_ink_extents(cr.stroke_extents());
            bbox.insert(&sb);
        }
        let ob = BoundingBox::new(&affine).with_extents(path_extents(cr));
        bbox.insert(&ob);
        cr.set_tolerance(backup_tolerance);
        bbox
    }
    fn path_extents(cr: &cairo::Context) -> (f64, f64, f64, f64) {
        let mut x1: f64 = 0.0;
        let mut y1: f64 = 0.0;
        let mut x2: f64 = 0.0;
        let mut y2: f64 = 0.0;
        unsafe {
            cairo_sys::cairo_path_extents(cr.to_glib_none().0, &mut x1, &mut y1, &mut x2, &mut y2);
        }
        (x1, y1, x2, y2)
    }
    impl From<StrokeLinejoin> for cairo::LineJoin {
        fn from(j: StrokeLinejoin) -> cairo::LineJoin {
            match j {
                StrokeLinejoin::Miter => cairo::LineJoin::Miter,
                StrokeLinejoin::Round => cairo::LineJoin::Round,
                StrokeLinejoin::Bevel => cairo::LineJoin::Bevel,
            }
        }
    }
    impl From<StrokeLinecap> for cairo::LineCap {
        fn from(j: StrokeLinecap) -> cairo::LineCap {
            match j {
                StrokeLinecap::Butt => cairo::LineCap::Butt,
                StrokeLinecap::Round => cairo::LineCap::Round,
                StrokeLinecap::Square => cairo::LineCap::Square,
            }
        }
    }
    impl From<CompOp> for cairo::Operator {
        fn from(op: CompOp) -> cairo::Operator {
            match op {
                CompOp::Clear => cairo::Operator::Clear,
                CompOp::Src => cairo::Operator::Source,
                CompOp::Dst => cairo::Operator::Dest,
                CompOp::SrcOver => cairo::Operator::Over,
                CompOp::DstOver => cairo::Operator::DestOver,
                CompOp::SrcIn => cairo::Operator::In,
                CompOp::DstIn => cairo::Operator::DestIn,
                CompOp::SrcOut => cairo::Operator::Out,
                CompOp::DstOut => cairo::Operator::DestOut,
                CompOp::SrcAtop => cairo::Operator::Atop,
                CompOp::DstAtop => cairo::Operator::DestAtop,
                CompOp::Xor => cairo::Operator::Xor,
                CompOp::Plus => cairo::Operator::Add,
                CompOp::Multiply => cairo::Operator::Multiply,
                CompOp::Screen => cairo::Operator::Screen,
                CompOp::Overlay => cairo::Operator::Overlay,
                CompOp::Darken => cairo::Operator::Darken,
                CompOp::Lighten => cairo::Operator::Lighten,
                CompOp::ColorDodge => cairo::Operator::ColorDodge,
                CompOp::ColorBurn => cairo::Operator::ColorBurn,
                CompOp::HardLight => cairo::Operator::HardLight,
                CompOp::SoftLight => cairo::Operator::SoftLight,
                CompOp::Difference => cairo::Operator::Difference,
                CompOp::Exclusion => cairo::Operator::Exclusion,
            }
        }
    }
    impl From<ClipRule> for cairo::FillRule {
        fn from(c: ClipRule) -> cairo::FillRule {
            match c {
                ClipRule::NonZero => cairo::FillRule::Winding,
                ClipRule::EvenOdd => cairo::FillRule::EvenOdd,
            }
        }
    }
    impl From<FillRule> for cairo::FillRule {
        fn from(f: FillRule) -> cairo::FillRule {
            match f {
                FillRule::NonZero => cairo::FillRule::Winding,
                FillRule::EvenOdd => cairo::FillRule::EvenOdd,
            }
        }
    }
    impl From<ShapeRendering> for cairo::Antialias {
        fn from(sr: ShapeRendering) -> cairo::Antialias {
            match sr {
                ShapeRendering::Auto | ShapeRendering::GeometricPrecision => {
                    cairo::Antialias::Default
                }
                ShapeRendering::OptimizeSpeed | ShapeRendering::CrispEdges => {
                    cairo::Antialias::None
                }
            }
        }
    }
    impl From<TextRendering> for cairo::Antialias {
        fn from(tr: TextRendering) -> cairo::Antialias {
            match tr {
                TextRendering::Auto
                | TextRendering::OptimizeLegibility
                | TextRendering::GeometricPrecision => cairo::Antialias::Default,
                TextRendering::OptimizeSpeed => cairo::Antialias::None,
            }
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_drawing_ctx_draw_node_from_stack(
        raw_draw_ctx: *mut RsvgDrawingCtx,
        raw_node: *const RsvgNode,
        raw_cascade_from: *const RsvgNode,
        clipping: glib_sys::gboolean,
    ) {
        if !!raw_draw_ctx.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_draw_ctx.is_null()",
                    &("rsvg_internals/src/drawing_ctx.rs", 890u32, 5u32),
                )
            }
        };
        let draw_ctx = unsafe { &mut *(raw_draw_ctx as *mut DrawingCtx) };
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/drawing_ctx.rs", 893u32, 5u32),
                )
            }
        };
        let node = unsafe { &*raw_node };
        let cascade_from = if raw_cascade_from.is_null() {
            None
        } else {
            Some(unsafe { &*raw_cascade_from })
        };
        let clipping: bool = from_glib(clipping);
        let cascaded = match cascade_from {
            None => node.get_cascaded_values(),
            Some(n) => {
                let c = n.get_cascaded_values();
                let v = c.get();
                CascadedValues::new_from_values(node, v)
            }
        };
        draw_ctx.draw_node_from_stack(&cascaded, node, clipping);
    }
    #[no_mangle]
    pub extern "C" fn rsvg_drawing_ctx_add_node_and_ancestors_to_stack(
        raw_draw_ctx: *const RsvgDrawingCtx,
        raw_node: *const RsvgNode,
    ) {
        if !!raw_draw_ctx.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_draw_ctx.is_null()",
                    &("rsvg_internals/src/drawing_ctx.rs", 921u32, 5u32),
                )
            }
        };
        let draw_ctx = unsafe { &mut *(raw_draw_ctx as *mut DrawingCtx) };
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/drawing_ctx.rs", 924u32, 5u32),
                )
            }
        };
        let node = unsafe { &*raw_node };
        draw_ctx.add_node_and_ancestors_to_stack(node);
    }
    #[no_mangle]
    pub extern "C" fn rsvg_drawing_ctx_get_ink_rect(
        raw_draw_ctx: *const RsvgDrawingCtx,
        ink_rect: *mut cairo_sys::cairo_rectangle_t,
    ) {
        if !!raw_draw_ctx.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_draw_ctx.is_null()",
                    &("rsvg_internals/src/drawing_ctx.rs", 935u32, 5u32),
                )
            }
        };
        let draw_ctx = unsafe { &mut *(raw_draw_ctx as *mut DrawingCtx) };
        if !!ink_rect.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !ink_rect.is_null()",
                    &("rsvg_internals/src/drawing_ctx.rs", 938u32, 5u32),
                )
            }
        };
        let r = draw_ctx.get_bbox().ink_rect.unwrap();
        unsafe {
            (*ink_rect).x = r.x;
            (*ink_rect).y = r.y;
            (*ink_rect).width = r.width;
            (*ink_rect).height = r.height;
        }
    }
    pub struct AcquiredNode(*const RefCell<Vec<RsvgNode>>, RsvgNode);
    impl Drop for AcquiredNode {
        fn drop(&mut self) {
            unsafe {
                let mut v = (*self.0).borrow_mut();
                if !Rc::ptr_eq(v.last().unwrap(), &self.1) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: Rc::ptr_eq(v.last().unwrap(), &self.1)",
                            &("rsvg_internals/src/drawing_ctx.rs", 955u32, 13u32),
                        )
                    }
                };
                v.pop();
            }
        }
    }
    impl AcquiredNode {
        pub fn get(&self) -> RsvgNode {
            self.1.clone()
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_drawing_ctx_new(
        cr: *mut cairo_sys::cairo_t,
        width: u32,
        height: u32,
        vb_width: libc::c_double,
        vb_height: libc::c_double,
        dpi_x: libc::c_double,
        dpi_y: libc::c_double,
        defs: *const RsvgDefs,
        is_testing: glib_sys::gboolean,
    ) -> *mut RsvgDrawingCtx {
        Box::into_raw(Box::new(DrawingCtx::new(
            unsafe { from_glib_none(cr) },
            f64::from(width),
            f64::from(height),
            vb_width,
            vb_height,
            dpi_x,
            dpi_y,
            defs,
            from_glib(is_testing),
        ))) as *mut RsvgDrawingCtx
    }
    #[no_mangle]
    pub extern "C" fn rsvg_drawing_ctx_free(raw_draw_ctx: *mut RsvgDrawingCtx) {
        if !!raw_draw_ctx.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_draw_ctx.is_null()",
                    &("rsvg_internals/src/drawing_ctx.rs", 994u32, 5u32),
                )
            }
        };
        let draw_ctx = unsafe { &mut *(raw_draw_ctx as *mut DrawingCtx) };
        unsafe {
            Box::from_raw(draw_ctx);
        }
    }
}
mod error {
    use attributes::Attribute;
    use cssparser::BasicParseError;
    use parsers::ParseError;
    use std::error;
    use std::fmt;
    pub enum AttributeError {
        Parse(ParseError),
        Value(String),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for AttributeError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&AttributeError::Parse(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Parse");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&AttributeError::Value(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Value");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for AttributeError {
        #[inline]
        fn clone(&self) -> AttributeError {
            match (&*self,) {
                (&AttributeError::Parse(ref __self_0),) => {
                    AttributeError::Parse(::std::clone::Clone::clone(&(*__self_0)))
                }
                (&AttributeError::Value(ref __self_0),) => {
                    AttributeError::Value(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for AttributeError {
        #[inline]
        fn eq(&self, other: &AttributeError) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &AttributeError::Parse(ref __self_0),
                            &AttributeError::Parse(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &AttributeError::Value(ref __self_0),
                            &AttributeError::Value(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &AttributeError) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &AttributeError::Parse(ref __self_0),
                            &AttributeError::Parse(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &AttributeError::Value(ref __self_0),
                            &AttributeError::Value(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    pub struct NodeError {
        attr: Attribute,
        err: AttributeError,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for NodeError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                NodeError {
                    attr: ref __self_0_0,
                    err: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("NodeError");
                    let _ = debug_trait_builder.field("attr", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("err", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for NodeError {
        #[inline]
        fn clone(&self) -> NodeError {
            match *self {
                NodeError {
                    attr: ref __self_0_0,
                    err: ref __self_0_1,
                } => NodeError {
                    attr: ::std::clone::Clone::clone(&(*__self_0_0)),
                    err: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for NodeError {
        #[inline]
        fn eq(&self, other: &NodeError) -> bool {
            match *other {
                NodeError {
                    attr: ref __self_1_0,
                    err: ref __self_1_1,
                } => match *self {
                    NodeError {
                        attr: ref __self_0_0,
                        err: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &NodeError) -> bool {
            match *other {
                NodeError {
                    attr: ref __self_1_0,
                    err: ref __self_1_1,
                } => match *self {
                    NodeError {
                        attr: ref __self_0_0,
                        err: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl NodeError {
        pub fn parse_error(attr: Attribute, error: ParseError) -> NodeError {
            NodeError {
                attr,
                err: AttributeError::Parse(error),
            }
        }
        pub fn value_error(attr: Attribute, description: &str) -> NodeError {
            NodeError {
                attr,
                err: AttributeError::Value(description.to_string()),
            }
        }
        pub fn attribute_error(attr: Attribute, error: AttributeError) -> NodeError {
            NodeError { attr, err: error }
        }
    }
    impl error::Error for NodeError {
        fn description(&self) -> &str {
            match self.err {
                AttributeError::Parse(_) => "parse error",
                AttributeError::Value(_) => "invalid attribute value",
            }
        }
    }
    impl fmt::Display for NodeError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self.err {
                AttributeError::Parse(ref n) => {
                    f.write_fmt(::std::fmt::Arguments::new_v1_formatted(
                        &["error parsing value for attribute \"", "\": "],
                        &match (&self.attr.to_str(), &n.display) {
                            (arg0, arg1) => [
                                ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                            ],
                        },
                        &[
                            ::std::fmt::rt::v1::Argument {
                                position: ::std::fmt::rt::v1::Position::At(0usize),
                                format: ::std::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                    width: ::std::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::std::fmt::rt::v1::Argument {
                                position: ::std::fmt::rt::v1::Position::At(1usize),
                                format: ::std::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                    width: ::std::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ))
                }
                AttributeError::Value(ref s) => {
                    f.write_fmt(::std::fmt::Arguments::new_v1_formatted(
                        &["invalid value for attribute \"", "\": "],
                        &match (&self.attr.to_str(), &s) {
                            (arg0, arg1) => [
                                ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                            ],
                        },
                        &[
                            ::std::fmt::rt::v1::Argument {
                                position: ::std::fmt::rt::v1::Position::At(0usize),
                                format: ::std::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                    width: ::std::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::std::fmt::rt::v1::Argument {
                                position: ::std::fmt::rt::v1::Position::At(1usize),
                                format: ::std::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                    width: ::std::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ))
                }
            }
        }
    }
    impl From<ParseError> for AttributeError {
        fn from(pe: ParseError) -> AttributeError {
            AttributeError::Parse(pe)
        }
    }
    impl<'a> From<BasicParseError<'a>> for AttributeError {
        fn from(e: BasicParseError) -> AttributeError {
            AttributeError::from(ParseError::from(e))
        }
    }
}
pub mod filters {
    use attributes::Attribute;
    use coord_units::CoordUnits;
    use drawing_ctx::DrawingCtx;
    use error::AttributeError;
    use handle::RsvgHandle;
    use length::{LengthDir, LengthUnit, RsvgLength};
    use node::{NodeResult, NodeTrait, NodeType, RsvgCNodeImpl, RsvgNode};
    use parsers::{parse_and_validate, ParseError};
    use property_bag::PropertyBag;
    use std::cell::{Cell, RefCell};
    use std::ops::Deref;
    mod bounds {
        //! Filter primitive subregion computation.
        use super::context::{FilterContext, FilterInput, FilterOutput, IRect};
        use bbox::BoundingBox;
        use cairo::{self, MatrixTrait};
        use drawing_ctx::DrawingCtx;
        use length::RsvgLength;
        /// A helper type for filter primitive subregion computation.
        #[rustc_copy_clone_marker]
        pub struct BoundsBuilder<'a> {
            /// The filter context.
            ctx: &'a FilterContext,
            /// The current bounding box.
            bbox: BoundingBox,
            /// Whether one of the input nodes is standard input.
            standard_input_was_referenced: bool,
            /// Filter primitive properties.
            x: Option<RsvgLength>,
            y: Option<RsvgLength>,
            width: Option<RsvgLength>,
            height: Option<RsvgLength>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::clone::Clone for BoundsBuilder<'a> {
            #[inline]
            fn clone(&self) -> BoundsBuilder<'a> {
                {
                    let _: ::std::clone::AssertParamIsClone<&'a FilterContext>;
                    let _: ::std::clone::AssertParamIsClone<BoundingBox>;
                    let _: ::std::clone::AssertParamIsClone<bool>;
                    let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                    let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                    let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                    let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::marker::Copy for BoundsBuilder<'a> {}
        impl<'a> BoundsBuilder<'a> {
            /// Constructs a new `BoundsBuilder`.
            #[inline]
            pub fn new(
                ctx: &'a FilterContext,
                x: Option<RsvgLength>,
                y: Option<RsvgLength>,
                width: Option<RsvgLength>,
                height: Option<RsvgLength>,
            ) -> Self {
                Self {
                    ctx,
                    bbox: BoundingBox::new(&ctx.paffine()),
                    standard_input_was_referenced: false,
                    x,
                    y,
                    width,
                    height,
                }
            }
            /// Adds a filter primitive input to the bounding box.
            #[inline]
            pub fn add_input(mut self, input: &FilterInput) -> Self {
                if self.standard_input_was_referenced {
                    return self;
                }
                match *input {
                    FilterInput::StandardInput(_) => {
                        self.standard_input_was_referenced = true;
                    }
                    FilterInput::PrimitiveOutput(FilterOutput {
                        bounds: IRect { x0, y0, x1, y1 },
                        ..
                    }) => {
                        let rect = cairo::Rectangle {
                            x: f64::from(x0),
                            y: f64::from(y0),
                            width: f64::from(x1 - x0),
                            height: f64::from(y1 - y0),
                        };
                        let input_bbox =
                            BoundingBox::new(&cairo::Matrix::identity()).with_rect(Some(rect));
                        self.bbox.insert(&input_bbox);
                    }
                }
                self
            }
            /// Returns the final pixel bounds.
            #[inline]
            pub fn into_irect(self, draw_ctx: &mut DrawingCtx) -> IRect {
                let mut bbox = self.apply_properties(draw_ctx);
                let effects_region = self.ctx.effects_region();
                bbox.clip(&effects_region);
                bbox.rect.unwrap().into()
            }
            /// Returns the final pixel bounds without clipping to the filter effects region.
            ///
            /// Used by feImage.
            #[inline]
            pub fn into_irect_without_clipping(self, draw_ctx: &mut DrawingCtx) -> IRect {
                self.apply_properties(draw_ctx).rect.unwrap().into()
            }
            /// Applies the filter primitive properties.
            fn apply_properties(mut self, draw_ctx: &mut DrawingCtx) -> BoundingBox {
                if self.bbox.rect.is_none() || self.standard_input_was_referenced {
                    let effects_region = self.ctx.effects_region();
                    self.bbox = self.bbox.with_rect(None);
                    self.bbox.insert(&effects_region);
                }
                if self.x.is_some()
                    || self.y.is_some()
                    || self.width.is_some()
                    || self.height.is_some()
                {
                    self.ctx.with_primitive_units(draw_ctx, |normalize| {
                        let rect = self.bbox.rect.as_mut().unwrap();
                        if let Some(x) = self.x {
                            rect.x = normalize(&x);
                        }
                        if let Some(y) = self.y {
                            rect.y = normalize(&y);
                        }
                        if let Some(width) = self.width {
                            rect.width = normalize(&width);
                        }
                        if let Some(height) = self.height {
                            rect.height = normalize(&height);
                        }
                    });
                }
                let mut bbox = BoundingBox::new(&cairo::Matrix::identity());
                bbox.insert(&self.bbox);
                bbox
            }
        }
    }
    use self::bounds::BoundsBuilder;
    pub mod context {
        use super::error::FilterError;
        use super::input::Input;
        use super::node::NodeFilter;
        use bbox::BoundingBox;
        use cairo::{self, MatrixTrait};
        use coord_units::CoordUnits;
        use drawing_ctx::DrawingCtx;
        use length::RsvgLength;
        use node::RsvgNode;
        use paint_server::{self, PaintServer};
        use srgb::{linearize_surface, unlinearize_surface};
        use std::cell::UnsafeCell;
        use std::collections::HashMap;
        use std::f64;
        use surface_utils::shared_surface::SharedImageSurface;
        use unitinterval::UnitInterval;
        #[structural_match]
        #[rustc_copy_clone_marker]
        pub struct IRect {
            pub x0: i32,
            pub y0: i32,
            pub x1: i32,
            pub y1: i32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for IRect {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    IRect {
                        x0: ref __self_0_0,
                        y0: ref __self_0_1,
                        x1: ref __self_0_2,
                        y1: ref __self_0_3,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("IRect");
                        let _ = debug_trait_builder.field("x0", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("y0", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("x1", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("y1", &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for IRect {
            #[inline]
            fn clone(&self) -> IRect {
                {
                    let _: ::std::clone::AssertParamIsClone<i32>;
                    let _: ::std::clone::AssertParamIsClone<i32>;
                    let _: ::std::clone::AssertParamIsClone<i32>;
                    let _: ::std::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for IRect {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for IRect {
            #[inline]
            fn eq(&self, other: &IRect) -> bool {
                match *other {
                    IRect {
                        x0: ref __self_1_0,
                        y0: ref __self_1_1,
                        x1: ref __self_1_2,
                        y1: ref __self_1_3,
                    } => match *self {
                        IRect {
                            x0: ref __self_0_0,
                            y0: ref __self_0_1,
                            x1: ref __self_0_2,
                            y1: ref __self_0_3,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &IRect) -> bool {
                match *other {
                    IRect {
                        x0: ref __self_1_0,
                        y0: ref __self_1_1,
                        x1: ref __self_1_2,
                        y1: ref __self_1_3,
                    } => match *self {
                        IRect {
                            x0: ref __self_0_0,
                            y0: ref __self_0_1,
                            x1: ref __self_0_2,
                            y1: ref __self_0_3,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                        }
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for IRect {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::std::cmp::AssertParamIsEq<i32>;
                    let _: ::std::cmp::AssertParamIsEq<i32>;
                    let _: ::std::cmp::AssertParamIsEq<i32>;
                    let _: ::std::cmp::AssertParamIsEq<i32>;
                }
            }
        }
        /// A filter primitive output.
        pub struct FilterOutput {
            /// The surface after the filter primitive was applied.
            pub surface: SharedImageSurface,
            /// The filter primitive subregion.
            pub bounds: IRect,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for FilterOutput {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    FilterOutput {
                        surface: ref __self_0_0,
                        bounds: ref __self_0_1,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("FilterOutput");
                        let _ = debug_trait_builder.field("surface", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("bounds", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for FilterOutput {
            #[inline]
            fn clone(&self) -> FilterOutput {
                match *self {
                    FilterOutput {
                        surface: ref __self_0_0,
                        bounds: ref __self_0_1,
                    } => FilterOutput {
                        surface: ::std::clone::Clone::clone(&(*__self_0_0)),
                        bounds: ::std::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        /// A filter primitive result.
        pub struct FilterResult {
            /// The name of this result: the value of the `result` attribute.
            pub name: Option<String>,
            /// The output.
            pub output: FilterOutput,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for FilterResult {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    FilterResult {
                        name: ref __self_0_0,
                        output: ref __self_0_1,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("FilterResult");
                        let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("output", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for FilterResult {
            #[inline]
            fn clone(&self) -> FilterResult {
                match *self {
                    FilterResult {
                        name: ref __self_0_0,
                        output: ref __self_0_1,
                    } => FilterResult {
                        name: ::std::clone::Clone::clone(&(*__self_0_0)),
                        output: ::std::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        /// An input to a filter primitive.
        pub enum FilterInput {
            /// One of the standard inputs.
            StandardInput(SharedImageSurface),

            /// Output of another filter primitive.
            PrimitiveOutput(FilterOutput),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for FilterInput {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&FilterInput::StandardInput(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("StandardInput");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&FilterInput::PrimitiveOutput(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("PrimitiveOutput");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for FilterInput {
            #[inline]
            fn clone(&self) -> FilterInput {
                match (&*self,) {
                    (&FilterInput::StandardInput(ref __self_0),) => {
                        FilterInput::StandardInput(::std::clone::Clone::clone(&(*__self_0)))
                    }
                    (&FilterInput::PrimitiveOutput(ref __self_0),) => {
                        FilterInput::PrimitiveOutput(::std::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        /// The filter rendering context.
        pub struct FilterContext {
            /// The <filter> node.
            node: RsvgNode,
            /// The node which referenced this filter.
            node_being_filtered: RsvgNode,
            /// The source graphic surface.
            source_surface: SharedImageSurface,
            /// Output of the last filter primitive.
            last_result: Option<FilterOutput>,
            /// Surfaces of the previous filter primitives by name.
            previous_results: HashMap<String, FilterOutput>,
            /// The background surface. Computed lazily.
            background_surface: UnsafeCell<Option<Result<SharedImageSurface, FilterError>>>,
            /// The filter effects region.
            effects_region: BoundingBox,
            /// Whether the currently rendered filter primitive uses linear RGB for color operations.
            ///
            /// This affects `get_input()` and `store_result()` which should perform linearization and
            /// unlinearization respectively when this is set to `true`.
            processing_linear_rgb: bool,
            /// The filter element affine matrix.
            ///
            /// If `filterUnits == userSpaceOnUse`, equal to the drawing context matrix, so, for example,
            /// if the target node is in a group with `transform="translate(30, 20)"`, this will be equal
            /// to a matrix that translates to 30, 20 (and does not scale). Note that the target node
            /// bounding box isn't included in the computations in this case.
            ///
            /// If `filterUnits == objectBoundingBox`, equal to the target node bounding box matrix
            /// multiplied by the drawing context matrix, so, for example, if the target node is in a group
            /// with `transform="translate(30, 20)"` and also has `x="1", y="1", width="50", height="50"`,
            /// this will be equal to a matrix that translates to 31, 21 and scales to 50, 50.
            ///
            /// This is to be used in conjunction with setting the viewbox size to account for the scaling.
            /// For `filterUnits == userSpaceOnUse`, the viewbox will have the actual resolution size, and
            /// for `filterUnits == objectBoundingBox`, the viewbox will have the size of 1, 1.
            _affine: cairo::Matrix,
            /// The filter primitive affine matrix.
            ///
            /// See the comments for `_affine`, they largely apply here.
            paffine: cairo::Matrix,
        }
        /// Computes and returns the filter effects region.
        fn compute_effects_region(
            filter_node: &RsvgNode,
            target_node: &RsvgNode,
            draw_ctx: &mut DrawingCtx,
            affine: cairo::Matrix,
            width: f64,
            height: f64,
        ) -> BoundingBox {
            let cascaded = target_node.get_cascaded_values();
            let values = cascaded.get();
            let filter = filter_node.get_impl::<NodeFilter>().unwrap();
            let mut bbox = BoundingBox::new(&cairo::Matrix::identity());
            if filter.filterunits.get() == CoordUnits::ObjectBoundingBox {
                draw_ctx.push_view_box(1.0, 1.0);
            }
            let rect = if filter.filterunits.get() == CoordUnits::ObjectBoundingBox {
                cairo::Rectangle {
                    x: filter.x.get().get_unitless(),
                    y: filter.y.get().get_unitless(),
                    width: filter.width.get().get_unitless(),
                    height: filter.height.get().get_unitless(),
                }
            } else {
                cairo::Rectangle {
                    x: filter.x.get().normalize(values, draw_ctx),
                    y: filter.y.get().normalize(values, draw_ctx),
                    width: filter.width.get().normalize(values, draw_ctx),
                    height: filter.height.get().normalize(values, draw_ctx),
                }
            };
            if filter.filterunits.get() == CoordUnits::ObjectBoundingBox {
                draw_ctx.pop_view_box();
            }
            let other_bbox = BoundingBox::new(&affine).with_rect(Some(rect));
            bbox.insert(&other_bbox);
            let rect = cairo::Rectangle {
                x: 0f64,
                y: 0f64,
                width,
                height,
            };
            let other_bbox = BoundingBox::new(&cairo::Matrix::identity()).with_rect(Some(rect));
            bbox.clip(&other_bbox);
            bbox
        }
        impl IRect {
            /// Returns true if the `IRect` contains the given coordinates.
            #[inline]
            pub fn contains(self, x: i32, y: i32) -> bool {
                x >= self.x0 && x < self.x1 && y >= self.y0 && y < self.y1
            }
            /// Returns an `IRect` scaled by the given amounts.
            ///
            /// The returned `IRect` encompasses all, even partially covered, pixels after the scaling.
            #[inline]
            pub fn scale(self, x: f64, y: f64) -> IRect {
                IRect {
                    x0: (f64::from(self.x0) * x).floor() as i32,
                    y0: (f64::from(self.y0) * y).floor() as i32,
                    x1: (f64::from(self.x1) * x).ceil() as i32,
                    y1: (f64::from(self.y1) * y).ceil() as i32,
                }
            }
        }
        impl FilterContext {
            /// Creates a new `FilterContext`.
            pub fn new(
                filter_node: &RsvgNode,
                node_being_filtered: &RsvgNode,
                source_surface: SharedImageSurface,
                draw_ctx: &mut DrawingCtx,
            ) -> Self {
                let cr_affine = draw_ctx.get_cairo_context().get_matrix();
                let bbox = draw_ctx.get_bbox().clone();
                let bbox_rect = bbox.rect.unwrap_or(cairo::Rectangle {
                    x: 0.0,
                    y: 0.0,
                    width: 0.0,
                    height: 0.0,
                });
                let filter = filter_node.get_impl::<NodeFilter>().unwrap();
                let affine = match filter.filterunits.get() {
                    CoordUnits::UserSpaceOnUse => cr_affine,
                    CoordUnits::ObjectBoundingBox => {
                        let affine = cairo::Matrix::new(
                            bbox_rect.width,
                            0f64,
                            0f64,
                            bbox_rect.height,
                            bbox_rect.x,
                            bbox_rect.y,
                        );
                        cairo::Matrix::multiply(&affine, &cr_affine)
                    }
                };
                let paffine = match filter.primitiveunits.get() {
                    CoordUnits::UserSpaceOnUse => cr_affine,
                    CoordUnits::ObjectBoundingBox => {
                        let affine = cairo::Matrix::new(
                            bbox_rect.width,
                            0f64,
                            0f64,
                            bbox_rect.height,
                            bbox_rect.x,
                            bbox_rect.y,
                        );
                        cairo::Matrix::multiply(&affine, &cr_affine)
                    }
                };
                let width = source_surface.width();
                let height = source_surface.height();
                Self {
                    node: filter_node.clone(),
                    node_being_filtered: node_being_filtered.clone(),
                    source_surface,
                    last_result: None,
                    previous_results: HashMap::new(),
                    background_surface: UnsafeCell::new(None),
                    effects_region: compute_effects_region(
                        filter_node,
                        node_being_filtered,
                        draw_ctx,
                        affine,
                        f64::from(width),
                        f64::from(height),
                    ),
                    processing_linear_rgb: false,
                    _affine: affine,
                    paffine,
                }
            }
            /// Returns the <filter> node for this context.
            #[inline]
            pub fn get_filter_node(&self) -> RsvgNode {
                self.node.clone()
            }
            /// Returns the node that referenced this filter.
            #[inline]
            pub fn get_node_being_filtered(&self) -> RsvgNode {
                self.node_being_filtered.clone()
            }
            /// Returns the surface corresponding to the last filter primitive's result.
            #[inline]
            pub fn last_result(&self) -> Option<&FilterOutput> {
                self.last_result.as_ref()
            }
            /// Returns the surface corresponding to the source graphic.
            #[inline]
            pub fn source_graphic(&self) -> &SharedImageSurface {
                &self.source_surface
            }
            /// Returns the surface containing the source graphic alpha.
            #[inline]
            pub fn source_alpha(&self, bounds: IRect) -> Result<cairo::ImageSurface, FilterError> {
                self.source_surface
                    .extract_alpha(bounds)
                    .map_err(FilterError::IntermediateSurfaceCreation)
            }
            /// Computes and returns the background image snapshot.
            fn compute_background_image(
                &self,
                draw_ctx: &DrawingCtx,
            ) -> Result<cairo::ImageSurface, cairo::Status> {
                let surface = cairo::ImageSurface::create(
                    cairo::Format::ARgb32,
                    self.source_surface.width(),
                    self.source_surface.height(),
                )?;
                let (x, y) = draw_ctx.get_raw_offset();
                let stack = draw_ctx.get_cr_stack();
                let cr = cairo::Context::new(&surface);
                for draw in stack.into_iter().rev() {
                    let nested = draw_ctx.is_cairo_context_nested(&draw);
                    cr.set_source_surface(
                        &draw.get_target(),
                        if nested { 0f64 } else { -x },
                        if nested { 0f64 } else { -y },
                    );
                    cr.paint();
                }
                Ok(surface)
            }
            /// Returns the surface corresponding to the background image snapshot.
            pub fn background_image(
                &self,
                draw_ctx: &DrawingCtx,
            ) -> Result<&SharedImageSurface, FilterError> {
                {
                    let bg = unsafe { &*self.background_surface.get() };
                    if let Some(result) = bg.as_ref() {
                        return result.as_ref().map_err(|&s| s);
                    }
                }
                let bg = unsafe { &mut *self.background_surface.get() };
                *bg = Some(
                    self.compute_background_image(draw_ctx)
                        .map_err(FilterError::IntermediateSurfaceCreation)
                        .and_then(|surface| {
                            SharedImageSurface::new(surface)
                                .map_err(FilterError::BadIntermediateSurfaceStatus)
                        }),
                );
                bg.as_ref().unwrap().as_ref().map_err(|&s| s)
            }
            /// Returns the surface containing the background image snapshot alpha.
            #[inline]
            pub fn background_alpha(
                &self,
                draw_ctx: &DrawingCtx,
                bounds: IRect,
            ) -> Result<cairo::ImageSurface, FilterError> {
                self.background_image(draw_ctx)?
                    .extract_alpha(bounds)
                    .map_err(FilterError::IntermediateSurfaceCreation)
            }
            /// Returns the output of the filter primitive by its result name.
            #[inline]
            pub fn filter_output(&self, name: &str) -> Option<&FilterOutput> {
                self.previous_results.get(name)
            }
            /// Converts this `FilterContext` into the surface corresponding to the output of the filter
            /// chain.
            #[inline]
            pub fn into_output(self) -> Result<SharedImageSurface, FilterError> {
                match self.last_result.map(|FilterOutput { surface, .. }| surface) {
                    Some(surface) => Ok(surface),
                    None => {
                        let empty_surface = cairo::ImageSurface::create(
                            cairo::Format::ARgb32,
                            self.source_surface.width(),
                            self.source_surface.height(),
                        ).map_err(FilterError::IntermediateSurfaceCreation)?;
                        SharedImageSurface::new(empty_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)
                    }
                }
            }
            /// Stores a filter primitive result into the context.
            #[inline]
            pub fn store_result(&mut self, mut result: FilterResult) -> Result<(), FilterError> {
                if self.processing_linear_rgb {
                    result.output.surface =
                        unlinearize_surface(&result.output.surface, result.output.bounds)
                            .map_err(FilterError::IntermediateSurfaceCreation)
                            .and_then(|surface| {
                                SharedImageSurface::new(surface)
                                    .map_err(FilterError::BadIntermediateSurfaceStatus)
                            })?;
                }
                if let Some(name) = result.name {
                    self.previous_results.insert(name, result.output.clone());
                }
                self.last_result = Some(result.output);
                Ok(())
            }
            /// Returns the paffine matrix.
            #[inline]
            pub fn paffine(&self) -> cairo::Matrix {
                self.paffine
            }
            /// Returns the filter effects region.
            #[inline]
            pub fn effects_region(&self) -> BoundingBox {
                self.effects_region
            }
            /// Calls the given function with correct behavior for the value of `primitiveUnits`.
            pub fn with_primitive_units<F, T>(&self, draw_ctx: &mut DrawingCtx, f: F) -> T
            where
                for<'b> F: FnOnce(Box<Fn(&RsvgLength) -> f64 + 'b>) -> T,
            {
                let cascaded = self.node_being_filtered.get_cascaded_values();
                let values = cascaded.get();
                let filter = self.node.get_impl::<NodeFilter>().unwrap();
                if filter.primitiveunits.get() == CoordUnits::ObjectBoundingBox {
                    draw_ctx.push_view_box(1.0, 1.0);
                    let rv = f(Box::new(RsvgLength::get_unitless));
                    draw_ctx.pop_view_box();
                    rv
                } else {
                    f(Box::new(|length: &RsvgLength| {
                        length.normalize(values, draw_ctx)
                    }))
                }
            }
            /// Computes and returns a surface corresponding to the given paint server.
            fn get_paint_server_surface(
                &self,
                draw_ctx: &mut DrawingCtx,
                paint_server: &PaintServer,
                opacity: UnitInterval,
            ) -> Result<cairo::ImageSurface, cairo::Status> {
                let surface = cairo::ImageSurface::create(
                    cairo::Format::ARgb32,
                    self.source_surface.width(),
                    self.source_surface.height(),
                )?;
                let cr_save = draw_ctx.get_cairo_context();
                let cr = cairo::Context::new(&surface);
                draw_ctx.set_cairo_context(&cr);
                let cascaded = self.node_being_filtered.get_cascaded_values();
                let values = cascaded.get();
                let bbox = draw_ctx.get_bbox().clone();
                if paint_server::set_source_paint_server(
                    draw_ctx,
                    paint_server,
                    &opacity,
                    &bbox,
                    &values.color.0,
                ) {
                    cr.paint();
                }
                draw_ctx.set_cairo_context(&cr_save);
                Ok(surface)
            }
            /// Retrieves the filter input surface according to the SVG rules.
            ///
            /// Does not take `processing_linear_rgb` into account.
            fn get_input_raw(
                &self,
                draw_ctx: &mut DrawingCtx,
                in_: Option<&Input>,
            ) -> Result<FilterInput, FilterError> {
                if in_.is_none() {
                    if let Some(output) = self.last_result().cloned() {
                        return Ok(FilterInput::PrimitiveOutput(output));
                    } else {
                        return Ok(FilterInput::StandardInput(self.source_graphic().clone()));
                    }
                }
                let cascaded = self.node_being_filtered.get_cascaded_values();
                let values = cascaded.get();
                match *in_.unwrap() {
                    Input::SourceGraphic => {
                        Ok(FilterInput::StandardInput(self.source_graphic().clone()))
                    }
                    Input::SourceAlpha => self
                        .source_alpha(self.effects_region().rect.unwrap().into())
                        .and_then(|surface| {
                            SharedImageSurface::new(surface)
                                .map_err(FilterError::BadIntermediateSurfaceStatus)
                        })
                        .map(FilterInput::StandardInput),
                    Input::BackgroundImage => self
                        .background_image(draw_ctx)
                        .map(Clone::clone)
                        .map(FilterInput::StandardInput),
                    Input::BackgroundAlpha => self
                        .background_alpha(draw_ctx, self.effects_region().rect.unwrap().into())
                        .and_then(|surface| {
                            SharedImageSurface::new(surface)
                                .map_err(FilterError::BadIntermediateSurfaceStatus)
                        })
                        .map(FilterInput::StandardInput),
                    Input::FillPaint => self
                        .get_paint_server_surface(draw_ctx, &values.fill.0, values.fill_opacity.0)
                        .map_err(FilterError::IntermediateSurfaceCreation)
                        .and_then(|surface| {
                            SharedImageSurface::new(surface)
                                .map_err(FilterError::BadIntermediateSurfaceStatus)
                        })
                        .map(FilterInput::StandardInput),
                    Input::StrokePaint => {
                        self.get_paint_server_surface(
                            draw_ctx,
                            &values.stroke.0,
                            values.stroke_opacity.0,
                        ).map_err(FilterError::IntermediateSurfaceCreation)
                            .and_then(|surface| {
                                SharedImageSurface::new(surface)
                                    .map_err(FilterError::BadIntermediateSurfaceStatus)
                            })
                            .map(FilterInput::StandardInput)
                    }
                    Input::FilterOutput(ref name) => self
                        .filter_output(name)
                        .cloned()
                        .map(FilterInput::PrimitiveOutput)
                        .ok_or(FilterError::InvalidInput),
                }
            }
            /// Retrieves the filter input surface according to the SVG rules.
            pub fn get_input(
                &self,
                draw_ctx: &mut DrawingCtx,
                in_: Option<&Input>,
            ) -> Result<FilterInput, FilterError> {
                let raw = self.get_input_raw(draw_ctx, in_)?;
                if self.processing_linear_rgb {
                    let (surface, bounds) = match raw {
                        FilterInput::StandardInput(ref surface) => {
                            (surface, self.effects_region().rect.unwrap().into())
                        }
                        FilterInput::PrimitiveOutput(FilterOutput {
                            ref surface,
                            ref bounds,
                        }) => (surface, *bounds),
                    };
                    linearize_surface(surface, bounds)
                        .map_err(FilterError::IntermediateSurfaceCreation)
                        .and_then(|surface| {
                            SharedImageSurface::new(surface)
                                .map_err(FilterError::BadIntermediateSurfaceStatus)
                        })
                        .map(|surface| match raw {
                            FilterInput::StandardInput(_) => FilterInput::StandardInput(surface),
                            FilterInput::PrimitiveOutput(ref output) => {
                                FilterInput::PrimitiveOutput(FilterOutput { surface, ..*output })
                            }
                        })
                } else {
                    Ok(raw)
                }
            }
            /// Calls the given closure with linear RGB processing enabled.
            #[inline]
            pub fn with_linear_rgb<T, F: FnOnce(&mut FilterContext) -> T>(&mut self, f: F) -> T {
                self.processing_linear_rgb = true;
                let rv = f(self);
                self.processing_linear_rgb = false;
                rv
            }
            /// Applies the `primitiveUnits` coordinate transformation to a non-x or y distance.
            #[inline]
            pub fn transform_dist(&self, d: f64) -> f64 {
                d * (self.paffine.xx.powi(2) + self.paffine.yy.powi(2)).sqrt() / f64::consts::SQRT_2
            }
        }
        impl FilterInput {
            /// Retrieves the surface from `FilterInput`.
            #[inline]
            pub fn surface(&self) -> &SharedImageSurface {
                match *self {
                    FilterInput::StandardInput(ref surface) => surface,
                    FilterInput::PrimitiveOutput(FilterOutput { ref surface, .. }) => surface,
                }
            }
        }
        impl From<cairo::Rectangle> for IRect {
            #[inline]
            fn from(
                cairo::Rectangle {
                    x,
                    y,
                    width,
                    height,
                }: cairo::Rectangle,
            ) -> Self {
                Self {
                    x0: x.floor() as i32,
                    y0: y.floor() as i32,
                    x1: (x + width).ceil() as i32,
                    y1: (y + height).ceil() as i32,
                }
            }
        }
    }
    use self::context::{FilterContext, FilterInput, FilterResult};
    mod error {
        use cairo;
        use std::error::Error;
        use std::fmt;
        /// An enumeration of errors that can occur during filter primitive rendering.
        #[structural_match]
        #[rustc_copy_clone_marker]
        pub enum FilterError {
            /// The filter was passed invalid input (the `in` attribute).
            InvalidInput,

            /// The filter input surface has an unsuccessful status.
            BadInputSurfaceStatus(cairo::Status),

            /// Couldn't create an intermediate surface.
            IntermediateSurfaceCreation(cairo::Status),

            /// An intermediate surface has an unsuccessful status.
            BadIntermediateSurfaceStatus(cairo::Status),

            /// A lighting filter has none or multiple light sources.
            InvalidLightSourceCount,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for FilterError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&FilterError::InvalidInput,) => {
                        let mut debug_trait_builder = f.debug_tuple("InvalidInput");
                        debug_trait_builder.finish()
                    }
                    (&FilterError::BadInputSurfaceStatus(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("BadInputSurfaceStatus");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&FilterError::IntermediateSurfaceCreation(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("IntermediateSurfaceCreation");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&FilterError::BadIntermediateSurfaceStatus(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("BadIntermediateSurfaceStatus");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                    (&FilterError::InvalidLightSourceCount,) => {
                        let mut debug_trait_builder = f.debug_tuple("InvalidLightSourceCount");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for FilterError {
            #[inline]
            fn clone(&self) -> FilterError {
                {
                    let _: ::std::clone::AssertParamIsClone<cairo::Status>;
                    let _: ::std::clone::AssertParamIsClone<cairo::Status>;
                    let _: ::std::clone::AssertParamIsClone<cairo::Status>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for FilterError {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for FilterError {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::std::cmp::AssertParamIsEq<cairo::Status>;
                    let _: ::std::cmp::AssertParamIsEq<cairo::Status>;
                    let _: ::std::cmp::AssertParamIsEq<cairo::Status>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for FilterError {
            #[inline]
            fn eq(&self, other: &FilterError) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &FilterError::BadInputSurfaceStatus(ref __self_0),
                                &FilterError::BadInputSurfaceStatus(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &FilterError::IntermediateSurfaceCreation(ref __self_0),
                                &FilterError::IntermediateSurfaceCreation(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            (
                                &FilterError::BadIntermediateSurfaceStatus(ref __self_0),
                                &FilterError::BadIntermediateSurfaceStatus(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &FilterError) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &FilterError::BadInputSurfaceStatus(ref __self_0),
                                &FilterError::BadInputSurfaceStatus(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &FilterError::IntermediateSurfaceCreation(ref __self_0),
                                &FilterError::IntermediateSurfaceCreation(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            (
                                &FilterError::BadIntermediateSurfaceStatus(ref __self_0),
                                &FilterError::BadIntermediateSurfaceStatus(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        impl Error for FilterError {
            #[inline]
            fn description(&self) -> &str {
                match *self {
                    FilterError::InvalidInput => "invalid value of the `in` attribute",
                    FilterError::BadInputSurfaceStatus(_) => "invalid status of the input surface",
                    FilterError::IntermediateSurfaceCreation(_) => {
                        "couldn\'t create an intermediate surface"
                    }
                    FilterError::BadIntermediateSurfaceStatus(_) => {
                        "invalid status of an intermediate surface"
                    }
                    FilterError::InvalidLightSourceCount => "invalid light source count",
                }
            }
            #[inline]
            fn cause(&self) -> Option<&Error> {
                None
            }
        }
        impl fmt::Display for FilterError {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                match *self {
                    FilterError::BadInputSurfaceStatus(ref status)
                    | FilterError::IntermediateSurfaceCreation(ref status)
                    | FilterError::BadIntermediateSurfaceStatus(ref status) => {
                        f.write_fmt(::std::fmt::Arguments::new_v1_formatted(
                            &["", ": "],
                            &match (&self.description(), &status) {
                                (arg0, arg1) => [
                                    ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                    ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Debug::fmt),
                                ],
                            },
                            &[
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(1usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                            ],
                        ))
                    }
                    _ => f.write_fmt(::std::fmt::Arguments::new_v1_formatted(
                        &[""],
                        &match (&self.description(),) {
                            (arg0,) => {
                                [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)]
                            }
                        },
                        &[::std::fmt::rt::v1::Argument {
                            position: ::std::fmt::rt::v1::Position::At(0usize),
                            format: ::std::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::std::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::std::fmt::rt::v1::Count::Implied,
                                width: ::std::fmt::rt::v1::Count::Implied,
                            },
                        }],
                    )),
                }
            }
        }
    }
    use self::error::FilterError;
    mod ffi {
        //! Internal FFI and marshalling things.
        use super::context::FilterContext;
        use super::{Filter, FilterError, FilterResult};
        use cairo;
        use drawing_ctx::DrawingCtx;
        use node::{NodeType, RsvgNode};
        use state::ColorInterpolationFilters;
        use surface_utils::shared_surface::SharedImageSurface;
        /// The type of the render function below.
        pub(super) type RenderFunctionType =
            fn(&RsvgNode, &FilterContext, &mut DrawingCtx) -> Result<FilterResult, FilterError>;
        /// Downcasts the given `node` to the type `T` and calls `Filter::render()` on it.
        pub(super) fn render<T: Filter>(
            node: &RsvgNode,
            ctx: &FilterContext,
            draw_ctx: &mut DrawingCtx,
        ) -> Result<FilterResult, FilterError> {
            node.with_impl(|filter: &T| filter.render(node, ctx, draw_ctx))
        }
        /// The type of the `is_affected_by_color_interpolation_filters` function below.
        pub(super) type IsAffectedByColorInterpFunctionType = fn() -> bool;
        /// Container for the filter function pointers. Needed to pass them around with C pointers.
        #[rustc_copy_clone_marker]
        pub(super) struct FilterFunctionPointers {
            render: RenderFunctionType,
            is_affected_by_color_interpolation_filters: IsAffectedByColorInterpFunctionType,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for FilterFunctionPointers {
            #[inline]
            fn clone(&self) -> FilterFunctionPointers {
                {
                    let _: ::std::clone::AssertParamIsClone<RenderFunctionType>;
                    let _: ::std::clone::AssertParamIsClone<
                        IsAffectedByColorInterpFunctionType,
                    >;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for FilterFunctionPointers {}
        impl FilterFunctionPointers {
            /// Creates a `FilterFunctionPointers` filled with pointers for `T`.
            pub(super) fn new<T: Filter>() -> Self {
                Self {
                    render: render::<T>,
                    is_affected_by_color_interpolation_filters:
                        T::is_affected_by_color_interpolation_filters,
                }
            }
        }
        /// Creates a new surface applied the filter. This function will create a context for itself, set up
        /// the coordinate systems execute all its little primitives and then clean up its own mess.
        pub fn filter_render(
            filter_node: &RsvgNode,
            node_being_filtered: &RsvgNode,
            source: &cairo::ImageSurface,
            draw_ctx: &mut DrawingCtx,
        ) -> cairo::ImageSurface {
            let filter_node = &*filter_node;
            {
                match (&filter_node.get_type(), &NodeType::Filter) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            {
                                ::rt::begin_panic_fmt(
                                    &::std::fmt::Arguments::new_v1_formatted(
                                        &[
                                            "assertion failed: `(left == right)`\n  left: `",
                                            "`,\n right: `",
                                            "`",
                                        ],
                                        &match (&left_val, &right_val) {
                                            (arg0, arg1) => [
                                                ::std::fmt::ArgumentV1::new(
                                                    arg0,
                                                    ::std::fmt::Debug::fmt,
                                                ),
                                                ::std::fmt::ArgumentV1::new(
                                                    arg1,
                                                    ::std::fmt::Debug::fmt,
                                                ),
                                            ],
                                        },
                                        &[
                                            ::std::fmt::rt::v1::Argument {
                                                position: ::std::fmt::rt::v1::Position::At(0usize),
                                                format: ::std::fmt::rt::v1::FormatSpec {
                                                    fill: ' ',
                                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                                    flags: 0u32,
                                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                                    width: ::std::fmt::rt::v1::Count::Implied,
                                                },
                                            },
                                            ::std::fmt::rt::v1::Argument {
                                                position: ::std::fmt::rt::v1::Position::At(1usize),
                                                format: ::std::fmt::rt::v1::FormatSpec {
                                                    fill: ' ',
                                                    align: ::std::fmt::rt::v1::Alignment::Unknown,
                                                    flags: 0u32,
                                                    precision: ::std::fmt::rt::v1::Count::Implied,
                                                    width: ::std::fmt::rt::v1::Count::Implied,
                                                },
                                            },
                                        ],
                                    ),
                                    &("rsvg_internals/src/filters/ffi.rs", 56u32, 5u32),
                                )
                            }
                        }
                    }
                }
            };
            if !!filter_node.is_in_error() {
                {
                    ::rt::begin_panic(
                        "assertion failed: !filter_node.is_in_error()",
                        &("rsvg_internals/src/filters/ffi.rs", 57u32, 5u32),
                    )
                }
            };
            let source_surface = cairo::ImageSurface::create(
                cairo::Format::ARgb32,
                source.get_width(),
                source.get_height(),
            ).unwrap();
            {
                let cr = cairo::Context::new(&source_surface);
                cr.set_source_surface(source, 0f64, 0f64);
                cr.paint();
            }
            let source_surface = SharedImageSurface::new(source_surface).unwrap();
            let mut filter_ctx =
                FilterContext::new(filter_node, node_being_filtered, source_surface, draw_ctx);
            filter_node
                .children()
                .filter(|c| {
                    c.get_type() > NodeType::FilterPrimitiveFirst
                        && c.get_type() < NodeType::FilterPrimitiveLast
                })
                .filter(|c| !c.is_in_error())
                .map(|c| {
                    let linear_rgb = {
                        let cascaded = c.get_cascaded_values();
                        let values = cascaded.get();
                        values.color_interpolation_filters == ColorInterpolationFilters::LinearRgb
                    };
                    (c, linear_rgb)
                })
                .for_each(|(c, linear_rgb)| {
                    let pointers = unsafe { *(c.get_c_impl() as *const FilterFunctionPointers) };
                    let mut render = |filter_ctx: &mut FilterContext| {
                        if let Err(_) = (pointers.render)(&c, filter_ctx, draw_ctx)
                            .and_then(|result| filter_ctx.store_result(result))
                        {
                        }
                    };
                    if (pointers.is_affected_by_color_interpolation_filters)() && linear_rgb {
                        filter_ctx.with_linear_rgb(render);
                    } else {
                        render(&mut filter_ctx);
                    }
                });
            match filter_ctx.into_output() {
                Ok(surface) => surface.into_image_surface(),
                Err(err) => {
                    {
                        ::rt::begin_panic_fmt(
                            &::std::fmt::Arguments::new_v1_formatted(
                                &["Could not create an empty surface to return from a filter: "],
                                &match (&err,) {
                                    (arg0,) => [::std::fmt::ArgumentV1::new(
                                        arg0,
                                        ::std::fmt::Display::fmt,
                                    )],
                                },
                                &[::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                }],
                            ),
                            &("rsvg_internals/src/filters/ffi.rs", 114u32, 13u32),
                        )
                    };
                }
            }
        }
    }
    pub use self::ffi::filter_render;
    use self::ffi::*;
    mod input {
        use attributes::Attribute;
        use error::NodeError;
        use parsers::ParseError;
        /// An enumeration of possible inputs for a filter primitive.
        #[structural_match]
        pub enum Input {
            SourceGraphic,
            SourceAlpha,
            BackgroundImage,
            BackgroundAlpha,
            FillPaint,
            StrokePaint,
            FilterOutput(String),
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Input {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&Input::SourceGraphic,) => {
                        let mut debug_trait_builder = f.debug_tuple("SourceGraphic");
                        debug_trait_builder.finish()
                    }
                    (&Input::SourceAlpha,) => {
                        let mut debug_trait_builder = f.debug_tuple("SourceAlpha");
                        debug_trait_builder.finish()
                    }
                    (&Input::BackgroundImage,) => {
                        let mut debug_trait_builder = f.debug_tuple("BackgroundImage");
                        debug_trait_builder.finish()
                    }
                    (&Input::BackgroundAlpha,) => {
                        let mut debug_trait_builder = f.debug_tuple("BackgroundAlpha");
                        debug_trait_builder.finish()
                    }
                    (&Input::FillPaint,) => {
                        let mut debug_trait_builder = f.debug_tuple("FillPaint");
                        debug_trait_builder.finish()
                    }
                    (&Input::StrokePaint,) => {
                        let mut debug_trait_builder = f.debug_tuple("StrokePaint");
                        debug_trait_builder.finish()
                    }
                    (&Input::FilterOutput(ref __self_0),) => {
                        let mut debug_trait_builder = f.debug_tuple("FilterOutput");
                        let _ = debug_trait_builder.field(&&(*__self_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Input {
            #[inline]
            fn clone(&self) -> Input {
                match (&*self,) {
                    (&Input::SourceGraphic,) => Input::SourceGraphic,
                    (&Input::SourceAlpha,) => Input::SourceAlpha,
                    (&Input::BackgroundImage,) => Input::BackgroundImage,
                    (&Input::BackgroundAlpha,) => Input::BackgroundAlpha,
                    (&Input::FillPaint,) => Input::FillPaint,
                    (&Input::StrokePaint,) => Input::StrokePaint,
                    (&Input::FilterOutput(ref __self_0),) => {
                        Input::FilterOutput(::std::clone::Clone::clone(&(*__self_0)))
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Input {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::std::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Input {
            #[inline]
            fn eq(&self, other: &Input) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Input::FilterOutput(ref __self_0),
                                &Input::FilterOutput(ref __arg_1_0),
                            ) => (*__self_0) == (*__arg_1_0),
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
            #[inline]
            fn ne(&self, other: &Input) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            (
                                &Input::FilterOutput(ref __self_0),
                                &Input::FilterOutput(ref __arg_1_0),
                            ) => (*__self_0) != (*__arg_1_0),
                            _ => false,
                        }
                    } else {
                        true
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::hash::Hash for Input {
            fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    (&Input::FilterOutput(ref __self_0),) => {
                        ::std::hash::Hash::hash(
                            &unsafe { ::std::intrinsics::discriminant_value(self) },
                            state,
                        );
                        ::std::hash::Hash::hash(&(*__self_0), state)
                    }
                    _ => ::std::hash::Hash::hash(
                        &unsafe { ::std::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        impl Input {
            pub fn parse(attr: Attribute, s: &str) -> Result<Input, NodeError> {
                match s {
                    "SourceGraphic" => Ok(Input::SourceGraphic),
                    "SourceAlpha" => Ok(Input::SourceAlpha),
                    "BackgroundImage" => Ok(Input::BackgroundImage),
                    "BackgroundAlpha" => Ok(Input::BackgroundAlpha),
                    "FillPaint" => Ok(Input::FillPaint),
                    "StrokePaint" => Ok(Input::StrokePaint),
                    s if !s.is_empty() => Ok(Input::FilterOutput(s.to_string())),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
    }
    use self::input::Input;
    pub mod node {
        //! The <filter> node.
        use attributes::Attribute;
        use coord_units::CoordUnits;
        use error::AttributeError;
        use handle::RsvgHandle;
        use length::{LengthDir, LengthUnit, RsvgLength};
        use node::{NodeResult, NodeTrait, RsvgNode};
        use parsers::{parse, parse_and_validate, Parse, ParseError};
        use property_bag::PropertyBag;
        use std::cell::Cell;
        /// The <filter> node.
        pub struct NodeFilter {
            pub x: Cell<RsvgLength>,
            pub y: Cell<RsvgLength>,
            pub width: Cell<RsvgLength>,
            pub height: Cell<RsvgLength>,
            pub filterunits: Cell<CoordUnits>,
            pub primitiveunits: Cell<CoordUnits>,
        }
        impl NodeFilter {
            /// Constructs a new `NodeFilter` with default properties.
            #[inline]
            pub fn new() -> Self {
                Self {
                    x: Cell::new(RsvgLength::parse_str("-10%", LengthDir::Horizontal).unwrap()),
                    y: Cell::new(RsvgLength::parse_str("-10%", LengthDir::Vertical).unwrap()),
                    width: Cell::new(RsvgLength::parse_str("120%", LengthDir::Horizontal).unwrap()),
                    height: Cell::new(RsvgLength::parse_str("120%", LengthDir::Vertical).unwrap()),
                    filterunits: Cell::new(CoordUnits::ObjectBoundingBox),
                    primitiveunits: Cell::new(CoordUnits::UserSpaceOnUse),
                }
            }
        }
        impl NodeTrait for NodeFilter {
            fn set_atts(
                &self,
                _node: &RsvgNode,
                _handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::FilterUnits => {
                            self.filterunits.set(parse("filterUnits", value, ())?)
                        }
                        _ => (),
                    }
                }
                let no_units_allowed = self.filterunits.get() == CoordUnits::ObjectBoundingBox;
                let check_units = |length: RsvgLength| {
                    if !no_units_allowed {
                        return Ok(length);
                    }
                    match length.unit {
                                LengthUnit::Default | LengthUnit::Percent =>
                                Ok(length),
                                _ =>
                                Err(AttributeError::Parse(ParseError::new("unit identifiers are not allowed with filterUnits set to objectBoundingBox"))),
                            }
                };
                let check_units_and_ensure_nonnegative = |length: RsvgLength| {
                    check_units(length).and_then(RsvgLength::check_nonnegative)
                };
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::X => self.x.set(parse_and_validate(
                            "x",
                            value,
                            LengthDir::Horizontal,
                            check_units,
                        )?),
                        Attribute::Y => self.y.set(parse_and_validate(
                            "y",
                            value,
                            LengthDir::Vertical,
                            check_units,
                        )?),
                        Attribute::Width => self.width.set(parse_and_validate(
                            "width",
                            value,
                            LengthDir::Horizontal,
                            check_units_and_ensure_nonnegative,
                        )?),
                        Attribute::Height => self.height.set(parse_and_validate(
                            "height",
                            value,
                            LengthDir::Vertical,
                            check_units_and_ensure_nonnegative,
                        )?),
                        Attribute::PrimitiveUnits => {
                            self.primitiveunits.set(parse("primitiveUnits", value, ())?)
                        }
                        _ => (),
                    }
                }
                Ok(())
            }
        }
    }
    use self::node::NodeFilter;
    pub mod blend {
        use super::context::{FilterContext, FilterOutput, FilterResult};
        use super::input::Input;
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo;
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::ParseError;
        use property_bag::PropertyBag;
        use std::cell::{Cell, RefCell};
        use surface_utils::shared_surface::SharedImageSurface;
        /// Enumeration of the possible blending modes.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum Mode {
            Normal,
            Multiply,
            Screen,
            Darken,
            Lighten,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Mode {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&Mode::Normal,) => {
                        let mut debug_trait_builder = f.debug_tuple("Normal");
                        debug_trait_builder.finish()
                    }
                    (&Mode::Multiply,) => {
                        let mut debug_trait_builder = f.debug_tuple("Multiply");
                        debug_trait_builder.finish()
                    }
                    (&Mode::Screen,) => {
                        let mut debug_trait_builder = f.debug_tuple("Screen");
                        debug_trait_builder.finish()
                    }
                    (&Mode::Darken,) => {
                        let mut debug_trait_builder = f.debug_tuple("Darken");
                        debug_trait_builder.finish()
                    }
                    (&Mode::Lighten,) => {
                        let mut debug_trait_builder = f.debug_tuple("Lighten");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Mode {
            #[inline]
            fn clone(&self) -> Mode {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Mode {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Mode {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Mode {
            #[inline]
            fn eq(&self, other: &Mode) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::hash::Hash for Mode {
            fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    _ => ::std::hash::Hash::hash(
                        &unsafe { ::std::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        /// The `feBlend` filter primitive.
        pub struct Blend {
            base: PrimitiveWithInput,
            in2: RefCell<Option<Input>>,
            mode: Cell<Mode>,
        }
        impl Blend {
            /// Constructs a new `Blend` with empty properties.
            #[inline]
            pub fn new() -> Blend {
                Blend {
                    base: PrimitiveWithInput::new::<Self>(),
                    in2: RefCell::new(None),
                    mode: Cell::new(Mode::Normal),
                }
            }
        }
        impl NodeTrait for Blend {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::In2 => {
                            self.in2.replace(Some(Input::parse(attr, value)?));
                        }
                        Attribute::Mode => self.mode.set(Mode::parse(attr, value)?),
                        _ => (),
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for Blend {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let input_2 = ctx.get_input(draw_ctx, self.in2.borrow().as_ref())?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .add_input(&input_2)
                    .into_irect(draw_ctx);
                let output_surface = input_2
                    .surface()
                    .copy_surface(bounds)
                    .map_err(FilterError::IntermediateSurfaceCreation)?;
                {
                    let cr = cairo::Context::new(&output_surface);
                    cr.rectangle(
                        bounds.x0 as f64,
                        bounds.y0 as f64,
                        (bounds.x1 - bounds.x0) as f64,
                        (bounds.y1 - bounds.y0) as f64,
                    );
                    cr.clip();
                    input.surface().set_as_source_surface(&cr, 0f64, 0f64);
                    cr.set_operator(self.mode.get().into());
                    cr.paint();
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
        impl Mode {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "normal" => Ok(Mode::Normal),
                    "multiply" => Ok(Mode::Multiply),
                    "screen" => Ok(Mode::Screen),
                    "darken" => Ok(Mode::Darken),
                    "lighten" => Ok(Mode::Lighten),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
        impl From<Mode> for cairo::Operator {
            #[inline]
            fn from(x: Mode) -> Self {
                match x {
                    Mode::Normal => cairo::Operator::Over,
                    Mode::Multiply => cairo::Operator::Multiply,
                    Mode::Screen => cairo::Operator::Screen,
                    Mode::Darken => cairo::Operator::Darken,
                    Mode::Lighten => cairo::Operator::Lighten,
                }
            }
        }
    }
    pub mod color_matrix {
        use super::context::{FilterContext, FilterOutput, FilterResult};
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::{self, ImageSurface};
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::{self, ListLength, NumberListError, ParseError};
        use property_bag::PropertyBag;
        use rulinalg::{
            self,
            matrix::{BaseMatrix, BaseMatrixMut, Matrix},
        };
        use std::cell::RefCell;
        use surface_utils::{
            iterators::Pixels, shared_surface::SharedImageSurface, ImageSurfaceDataExt, Pixel,
        };
        use util::clamp;
        /// Color matrix operation types.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum OperationType {
            Matrix,
            Saturate,
            HueRotate,
            LuminanceToAlpha,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for OperationType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&OperationType::Matrix,) => {
                        let mut debug_trait_builder = f.debug_tuple("Matrix");
                        debug_trait_builder.finish()
                    }
                    (&OperationType::Saturate,) => {
                        let mut debug_trait_builder = f.debug_tuple("Saturate");
                        debug_trait_builder.finish()
                    }
                    (&OperationType::HueRotate,) => {
                        let mut debug_trait_builder = f.debug_tuple("HueRotate");
                        debug_trait_builder.finish()
                    }
                    (&OperationType::LuminanceToAlpha,) => {
                        let mut debug_trait_builder = f.debug_tuple("LuminanceToAlpha");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for OperationType {
            #[inline]
            fn clone(&self) -> OperationType {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for OperationType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for OperationType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for OperationType {
            #[inline]
            fn eq(&self, other: &OperationType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        /// The `feColorMatrix` filter primitive.
        pub struct ColorMatrix {
            base: PrimitiveWithInput,
            matrix: RefCell<Matrix<f64>>,
        }
        impl ColorMatrix {
            /// Constructs a new `ColorMatrix` with empty properties.
            #[inline]
            pub fn new() -> ColorMatrix {
                ColorMatrix {
                    base: PrimitiveWithInput::new::<Self>(),
                    matrix: RefCell::new(Matrix::identity(5)),
                }
            }
        }
        impl NodeTrait for ColorMatrix {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                let mut operation_type = OperationType::Matrix;
                for (_, attr, value) in pbag.iter().filter(|(_, attr, _)| *attr == Attribute::Type)
                {
                    operation_type = OperationType::parse(attr, value)?;
                }
                if operation_type == OperationType::LuminanceToAlpha {
                    self.matrix.replace({
                        use matrix::Matrix;
                        let data_as_nested_array = [
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 0.0],
                            [0.2125, 0.7154, 0.0721, 0.0, 0.0],
                            [0.0, 0.0, 0.0, 0.0, 1.0],
                        ];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    });
                } else {
                    for (_, attr, value) in pbag
                        .iter()
                        .filter(|(_, attr, _)| *attr == Attribute::Values)
                    {
                        let new_matrix = match operation_type {
                            OperationType::LuminanceToAlpha => ::rt::begin_panic(
                                "internal error: entered unreachable code",
                                &("rsvg_internals/src/filters/color_matrix.rs", 84u32, 56u32),
                            ),
                            OperationType::Matrix => {
                                let top = Matrix::new(
                                    4,
                                    5,
                                    parsers::number_list_from_str(value, ListLength::Exact(20))
                                        .map_err(|err| {
                                            NodeError::parse_error(attr,
                                                                                                                                                match err
                                                                                                                                                    {
                                                                                                                                                    NumberListError::IncorrectNumberOfElements
                                                                                                                                                    =>
                                                                                                                                                    {
                                                                                                                                                        ParseError::new("incorrect number of elements: expected 20")
                                                                                                                                                    }
                                                                                                                                                    NumberListError::Parse(err)
                                                                                                                                                    =>
                                                                                                                                                    err,
                                                                                                                                                })
                                        })?,
                                );
                                let mut matrix = Matrix::identity(5);
                                matrix.sub_slice_mut([0, 0], 4, 5).set_to(top);
                                matrix
                            }
                            OperationType::Saturate => {
                                let s = parsers::number(value)
                                    .map_err(|err| NodeError::parse_error(attr, err))?;
                                if s < 0.0 || s > 1.0 {
                                    return Err(NodeError::value_error(
                                        attr,
                                        "expected value from 0 to 1",
                                    ));
                                }
                                {
                                    use matrix::Matrix;
                                    let data_as_nested_array = [
                                        [
                                            0.213 + 0.787 * s,
                                            0.715 - 0.715 * s,
                                            0.072 - 0.072 * s,
                                            0.0,
                                            0.0,
                                        ],
                                        [
                                            0.213 - 0.213 * s,
                                            0.715 + 0.285 * s,
                                            0.072 - 0.072 * s,
                                            0.0,
                                            0.0,
                                        ],
                                        [
                                            0.213 - 0.213 * s,
                                            0.715 - 0.715 * s,
                                            0.072 + 0.928 * s,
                                            0.0,
                                            0.0,
                                        ],
                                        [0.0, 0.0, 0.0, 1.0, 0.0],
                                        [0.0, 0.0, 0.0, 0.0, 1.0],
                                    ];
                                    let rows = data_as_nested_array.len();
                                    let cols = data_as_nested_array[0].len();
                                    let data_as_flat_array: Vec<
                                        _,
                                    > = data_as_nested_array
                                        .into_iter()
                                        .flat_map(|row| row.into_iter())
                                        .cloned()
                                        .collect();
                                    Matrix::new(rows, cols, data_as_flat_array)
                                }
                            }
                            OperationType::HueRotate => {
                                let degrees = parsers::number(value)
                                    .map_err(|err| NodeError::parse_error(attr, err))?;
                                let (sin, cos) = degrees.to_radians().sin_cos();
                                let a = {
                                    use matrix::Matrix;
                                    let data_as_nested_array = [
                                        [0.213, 0.715, 0.072],
                                        [0.213, 0.715, 0.072],
                                        [0.213, 0.715, 0.072],
                                    ];
                                    let rows = data_as_nested_array.len();
                                    let cols = data_as_nested_array[0].len();
                                    let data_as_flat_array: Vec<
                                        _,
                                    > = data_as_nested_array
                                        .into_iter()
                                        .flat_map(|row| row.into_iter())
                                        .cloned()
                                        .collect();
                                    Matrix::new(rows, cols, data_as_flat_array)
                                };
                                let b = {
                                    use matrix::Matrix;
                                    let data_as_nested_array = [
                                        [0.787, -0.715, -0.072],
                                        [-0.213, 0.285, -0.072],
                                        [-0.213, -0.715, 0.928],
                                    ];
                                    let rows = data_as_nested_array.len();
                                    let cols = data_as_nested_array[0].len();
                                    let data_as_flat_array: Vec<
                                        _,
                                    > = data_as_nested_array
                                        .into_iter()
                                        .flat_map(|row| row.into_iter())
                                        .cloned()
                                        .collect();
                                    Matrix::new(rows, cols, data_as_flat_array)
                                };
                                let c = {
                                    use matrix::Matrix;
                                    let data_as_nested_array = [
                                        [-0.213, -0.715, 0.928],
                                        [0.143, 0.140, -0.283],
                                        [-0.787, 0.715, 0.072],
                                    ];
                                    let rows = data_as_nested_array.len();
                                    let cols = data_as_nested_array[0].len();
                                    let data_as_flat_array: Vec<
                                        _,
                                    > = data_as_nested_array
                                        .into_iter()
                                        .flat_map(|row| row.into_iter())
                                        .cloned()
                                        .collect();
                                    Matrix::new(rows, cols, data_as_flat_array)
                                };
                                let top_left = a + b * cos + c * sin;
                                let mut matrix = Matrix::identity(5);
                                matrix.sub_slice_mut([0, 0], 3, 3).set_to(top_left);
                                matrix
                            }
                        };
                        self.matrix.replace(new_matrix);
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for ColorMatrix {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .into_irect(draw_ctx);
                let matrix = &*self.matrix.borrow();
                /// Multiplies a matrix by a vector and puts the result into a slice.
                #[inline]
                fn mul_into(out: &mut [f64], m: &Matrix<f64>, v: &[f64]) {
                    {
                        match (&v.len(), &m.cols()) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["assertion failed: `(left == right)`\n  left: `",
                                                                                                         "`,\n right: `",
                                                                                                         "`"],
                                                                                                       &match (&left_val,
                                                                                                               &right_val)
                                                                                                            {
                                                                                                            (arg0,
                                                                                                             arg1)
                                                                                                            =>
                                                                                                            [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                         ::std::fmt::Debug::fmt),
                                                                                                             ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                         ::std::fmt::Debug::fmt)],
                                                                                                        },
                                                                                                       &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                          ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                      format:
                                                                                                                                          ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                             ' ',
                                                                                                                                                                         align:
                                                                                                                                                                             ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                         flags:
                                                                                                                                                                             0u32,
                                                                                                                                                                         precision:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                         width:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                         ::std::fmt::rt::v1::Argument{position:
                                                                                                                                          ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                      format:
                                                                                                                                          ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                             ' ',
                                                                                                                                                                         align:
                                                                                                                                                                             ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                         flags:
                                                                                                                                                                             0u32,
                                                                                                                                                                         precision:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                         width:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,},}]),
                                                              &("rsvg_internals/src/filters/color_matrix.rs",
                                                                189u32,
                                                                13u32))
                                    }
                                }
                            }
                        }
                    };
                    {
                        match (&v.len(), &out.len()) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    {
                                        ::rt::begin_panic_fmt(&::std::fmt::Arguments::new_v1_formatted(&["assertion failed: `(left == right)`\n  left: `",
                                                                                                         "`,\n right: `",
                                                                                                         "`"],
                                                                                                       &match (&left_val,
                                                                                                               &right_val)
                                                                                                            {
                                                                                                            (arg0,
                                                                                                             arg1)
                                                                                                            =>
                                                                                                            [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                         ::std::fmt::Debug::fmt),
                                                                                                             ::std::fmt::ArgumentV1::new(arg1,
                                                                                                                                         ::std::fmt::Debug::fmt)],
                                                                                                        },
                                                                                                       &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                          ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                      format:
                                                                                                                                          ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                             ' ',
                                                                                                                                                                         align:
                                                                                                                                                                             ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                         flags:
                                                                                                                                                                             0u32,
                                                                                                                                                                         precision:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                         width:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,},},
                                                                                                         ::std::fmt::rt::v1::Argument{position:
                                                                                                                                          ::std::fmt::rt::v1::Position::At(1usize),
                                                                                                                                      format:
                                                                                                                                          ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                             ' ',
                                                                                                                                                                         align:
                                                                                                                                                                             ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                         flags:
                                                                                                                                                                             0u32,
                                                                                                                                                                         precision:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                         width:
                                                                                                                                                                             ::std::fmt::rt::v1::Count::Implied,},}]),
                                                              &("rsvg_internals/src/filters/color_matrix.rs",
                                                                190u32,
                                                                13u32))
                                    }
                                }
                            }
                        }
                    };
                    for (i, row) in m.row_iter().enumerate() {
                        out[i] = rulinalg::utils::dot(row.raw_slice(), v);
                    }
                }
                let mut output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let output_stride = output_surface.get_stride() as usize;
                {
                    let mut output_data = output_surface.get_data().unwrap();
                    for (x, y, pixel) in Pixels::new(input.surface(), bounds) {
                        let alpha = f64::from(pixel.a) / 255f64;
                        let pixel_vec = if alpha == 0.0 {
                            [0.0, 0.0, 0.0, 0.0, 1.0]
                        } else {
                            [
                                f64::from(pixel.r) / 255f64 / alpha,
                                f64::from(pixel.g) / 255f64 / alpha,
                                f64::from(pixel.b) / 255f64 / alpha,
                                alpha,
                                1.0,
                            ]
                        };
                        let mut new_pixel_vec = [0.0; 5];
                        mul_into(&mut new_pixel_vec, &matrix, &pixel_vec);
                        let new_alpha = clamp(new_pixel_vec[3], 0.0, 1.0);
                        let premultiply =
                            |x: f64| (clamp(x, 0.0, 1.0) * new_alpha * 255f64).round() as u8;
                        let output_pixel = Pixel {
                            r: premultiply(new_pixel_vec[0]),
                            g: premultiply(new_pixel_vec[1]),
                            b: premultiply(new_pixel_vec[2]),
                            a: (new_alpha * 255f64).round() as u8,
                        };
                        output_data.set_pixel(output_stride, output_pixel, x, y);
                    }
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
        impl OperationType {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "matrix" => Ok(OperationType::Matrix),
                    "saturate" => Ok(OperationType::Saturate),
                    "hueRotate" => Ok(OperationType::HueRotate),
                    "luminanceToAlpha" => Ok(OperationType::LuminanceToAlpha),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
    }
    pub mod component_transfer {
        use super::context::{FilterContext, FilterOutput, FilterResult};
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::{self, ImageSurface};
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, NodeType, RsvgCNodeImpl, RsvgNode};
        use parsers::{self, ListLength, NumberListError, ParseError};
        use property_bag::PropertyBag;
        use std::cell::{Cell, Ref, RefCell};
        use std::cmp::min;
        use surface_utils::{
            iterators::Pixels, shared_surface::SharedImageSurface, ImageSurfaceDataExt, Pixel,
        };
        use util::clamp;
        /// The `feComponentTransfer` filter primitive.
        pub struct ComponentTransfer {
            base: PrimitiveWithInput,
        }
        /// Pixel components that can be influenced by `feComponentTransfer`.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum Channel {
            R,
            G,
            B,
            A,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Channel {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&Channel::R,) => {
                        let mut debug_trait_builder = f.debug_tuple("R");
                        debug_trait_builder.finish()
                    }
                    (&Channel::G,) => {
                        let mut debug_trait_builder = f.debug_tuple("G");
                        debug_trait_builder.finish()
                    }
                    (&Channel::B,) => {
                        let mut debug_trait_builder = f.debug_tuple("B");
                        debug_trait_builder.finish()
                    }
                    (&Channel::A,) => {
                        let mut debug_trait_builder = f.debug_tuple("A");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Channel {
            #[inline]
            fn clone(&self) -> Channel {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Channel {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Channel {
            #[inline]
            fn eq(&self, other: &Channel) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Channel {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        /// Component transfer function types.
        #[rustc_copy_clone_marker]
        enum FunctionType {
            Identity,
            Table,
            Discrete,
            Linear,
            Gamma,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for FunctionType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&FunctionType::Identity,) => {
                        let mut debug_trait_builder = f.debug_tuple("Identity");
                        debug_trait_builder.finish()
                    }
                    (&FunctionType::Table,) => {
                        let mut debug_trait_builder = f.debug_tuple("Table");
                        debug_trait_builder.finish()
                    }
                    (&FunctionType::Discrete,) => {
                        let mut debug_trait_builder = f.debug_tuple("Discrete");
                        debug_trait_builder.finish()
                    }
                    (&FunctionType::Linear,) => {
                        let mut debug_trait_builder = f.debug_tuple("Linear");
                        debug_trait_builder.finish()
                    }
                    (&FunctionType::Gamma,) => {
                        let mut debug_trait_builder = f.debug_tuple("Gamma");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for FunctionType {
            #[inline]
            fn clone(&self) -> FunctionType {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for FunctionType {}
        /// The `<feFuncX>` element (X is R, G, B or A).
        pub struct FuncX {
            channel: Channel,
            function_type: Cell<FunctionType>,
            table_values: RefCell<Vec<f64>>,
            slope: Cell<f64>,
            intercept: Cell<f64>,
            amplitude: Cell<f64>,
            exponent: Cell<f64>,
            offset: Cell<f64>,
        }
        /// The compute function parameters.
        struct FunctionParameters<'a> {
            table_values: Ref<'a, Vec<f64>>,
            slope: f64,
            intercept: f64,
            amplitude: f64,
            exponent: f64,
            offset: f64,
        }
        /// The compute function type.
        type Function = fn(&FunctionParameters, f64) -> f64;
        /// The identity component transfer function.
        fn identity(_: &FunctionParameters, value: f64) -> f64 {
            value
        }
        /// The table component transfer function.
        fn table(params: &FunctionParameters, value: f64) -> f64 {
            let n = params.table_values.len() - 1;
            let k = (value * (n as f64)).floor() as usize;
            let k = min(k, n);
            if k == n {
                return params.table_values[k];
            }
            let vk = params.table_values[k];
            let vk1 = params.table_values[k + 1];
            let k = k as f64;
            let n = n as f64;
            vk + (value - k / n) * n * (vk1 - vk)
        }
        /// The discrete component transfer function.
        fn discrete(params: &FunctionParameters, value: f64) -> f64 {
            let n = params.table_values.len();
            let k = (value * (n as f64)).floor() as usize;
            params.table_values[min(k, n - 1)]
        }
        /// The linear component transfer function.
        fn linear(params: &FunctionParameters, value: f64) -> f64 {
            params.slope * value + params.intercept
        }
        /// The gamma component transfer function.
        fn gamma(params: &FunctionParameters, value: f64) -> f64 {
            params.amplitude * value.powf(params.exponent) + params.offset
        }
        impl ComponentTransfer {
            /// Constructs a new `ComponentTransfer` with empty properties.
            #[inline]
            pub fn new() -> ComponentTransfer {
                ComponentTransfer {
                    base: PrimitiveWithInput::new::<Self>(),
                }
            }
        }
        impl Default for FuncX {
            #[inline]
            fn default() -> Self {
                Self {
                    channel: Channel::R,
                    function_type: Cell::new(FunctionType::Identity),
                    table_values: RefCell::new(Vec::new()),
                    slope: Cell::new(1f64),
                    intercept: Cell::new(0f64),
                    amplitude: Cell::new(1f64),
                    exponent: Cell::new(1f64),
                    offset: Cell::new(0f64),
                }
            }
        }
        impl FuncX {
            /// Constructs a new `FuncR` with empty properties.
            #[inline]
            pub fn new_r() -> Self {
                Self {
                    channel: Channel::R,
                    ..Default::default()
                }
            }
            /// Constructs a new `FuncG` with empty properties.
            #[inline]
            pub fn new_g() -> Self {
                Self {
                    channel: Channel::G,
                    ..Default::default()
                }
            }
            /// Constructs a new `FuncB` with empty properties.
            #[inline]
            pub fn new_b() -> Self {
                Self {
                    channel: Channel::B,
                    ..Default::default()
                }
            }
            /// Constructs a new `FuncA` with empty properties.
            #[inline]
            pub fn new_a() -> Self {
                Self {
                    channel: Channel::A,
                    ..Default::default()
                }
            }
            /// Returns the component transfer function parameters.
            #[inline]
            fn function_parameters(&self) -> FunctionParameters {
                FunctionParameters {
                    table_values: self.table_values.borrow(),
                    slope: self.slope.get(),
                    intercept: self.intercept.get(),
                    amplitude: self.amplitude.get(),
                    exponent: self.exponent.get(),
                    offset: self.offset.get(),
                }
            }
            /// Returns the component transfer function.
            #[inline]
            fn function(&self) -> Function {
                match self.function_type.get() {
                    FunctionType::Identity => identity,
                    FunctionType::Table => table,
                    FunctionType::Discrete => discrete,
                    FunctionType::Linear => linear,
                    FunctionType::Gamma => gamma,
                }
            }
        }
        impl NodeTrait for ComponentTransfer {
            #[inline]
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl NodeTrait for FuncX {
            #[inline]
            fn set_atts(
                &self,
                _node: &RsvgNode,
                _handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::Type => {
                            self.function_type.set(FunctionType::parse(attr, value)?)
                        }
                        Attribute::TableValues => {
                            self.table_values.replace(
                                parsers::number_list_from_str(value, ListLength::Unbounded)
                                    .map_err(|err| {
                                        if let NumberListError::Parse(err) = err {
                                            NodeError::parse_error(attr, err)
                                        } else {
                                            {
                                                ::rt::begin_panic("unexpected number list error",
                                                                                                                                                     &("rsvg_internals/src/filters/component_transfer.rs",
                                                                                                                                                       239u32,
                                                                                                                                                       37u32))
                                            };
                                        }
                                    })?,
                            );
                        }
                        Attribute::Slope => self.slope.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::Intercept => self.intercept.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::Amplitude => self.amplitude.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::Exponent => self.exponent.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::Offset => self.offset.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        _ => (),
                    }
                }
                match self.function_type.get() {
                    FunctionType::Table | FunctionType::Discrete => {
                        if self.table_values.borrow().is_empty() {
                            self.function_type.set(FunctionType::Identity);
                        }
                    }
                    _ => (),
                }
                Ok(())
            }
        }
        impl Filter for ComponentTransfer {
            fn render(
                &self,
                node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .into_irect(draw_ctx);
                let mut output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let functions = node
                    .children()
                    .rev()
                    .filter(|c| c.get_type() == NodeType::ComponentTransferFunction);
                let get_node = |channel| {
                    functions
                        .clone()
                        .find(|c| c.get_impl::<FuncX>().unwrap().channel == channel)
                };
                let func_r = get_node(Channel::R);
                let func_g = get_node(Channel::G);
                let func_b = get_node(Channel::B);
                let func_a = get_node(Channel::A);
                let func_default = FuncX::default();
                #[inline]
                fn func_or_default<'a>(
                    func: &'a Option<RsvgNode>,
                    default: &'a FuncX,
                ) -> &'a FuncX {
                    func.as_ref()
                        .map(|c| c.get_impl::<FuncX>().unwrap())
                        .unwrap_or(default)
                }
                #[inline]
                fn compute_func<'a>(func: &'a FuncX) -> impl Fn(u8, f64, f64) -> u8 + 'a {
                    let compute = func.function();
                    let params = func.function_parameters();
                    move |value, alpha, new_alpha| {
                        let value = f64::from(value) / 255f64;
                        let unpremultiplied = if alpha == 0f64 { 0f64 } else { value / alpha };
                        let new_value = compute(&params, unpremultiplied);
                        let new_value = clamp(new_value, 0f64, 1f64);
                        (new_value * new_alpha * 255f64).round() as u8
                    }
                }
                let compute_r = compute_func(func_or_default(&func_r, &func_default));
                let compute_g = compute_func(func_or_default(&func_g, &func_default));
                let compute_b = compute_func(func_or_default(&func_b, &func_default));
                let func_a = func_or_default(&func_a, &func_default);
                let compute_a = func_a.function();
                let params_a = func_a.function_parameters();
                let compute_a = |alpha| compute_a(&params_a, alpha);
                let output_stride = output_surface.get_stride() as usize;
                {
                    let mut output_data = output_surface.get_data().unwrap();
                    for (x, y, pixel) in Pixels::new(input.surface(), bounds) {
                        let alpha = f64::from(pixel.a) / 255f64;
                        let new_alpha = compute_a(alpha);
                        let output_pixel = Pixel {
                            r: compute_r(pixel.r, alpha, new_alpha),
                            g: compute_g(pixel.g, alpha, new_alpha),
                            b: compute_b(pixel.b, alpha, new_alpha),
                            a: (new_alpha * 255f64).round() as u8,
                        };
                        output_data.set_pixel(output_stride, output_pixel, x, y);
                    }
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
        impl FunctionType {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "identity" => Ok(FunctionType::Identity),
                    "table" => Ok(FunctionType::Table),
                    "discrete" => Ok(FunctionType::Discrete),
                    "linear" => Ok(FunctionType::Linear),
                    "gamma" => Ok(FunctionType::Gamma),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
    }
    pub mod composite {
        use super::context::{FilterContext, FilterOutput, FilterResult};
        use super::input::Input;
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::{self, ImageSurface};
        use cssparser::{CowRcStr, Parser, Token};
        use drawing_ctx::DrawingCtx;
        use error::{AttributeError, NodeError};
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::{self, parse, Parse};
        use property_bag::PropertyBag;
        use std::cell::{Cell, RefCell};
        use surface_utils::{
            iterators::Pixels, shared_surface::SharedImageSurface, ImageSurfaceDataExt, Pixel,
        };
        use util::clamp;
        /// Enumeration of the possible compositing operations.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum Operator {
            Over,
            In,
            Out,
            Atop,
            Xor,
            Arithmetic,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Operator {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&Operator::Over,) => {
                        let mut debug_trait_builder = f.debug_tuple("Over");
                        debug_trait_builder.finish()
                    }
                    (&Operator::In,) => {
                        let mut debug_trait_builder = f.debug_tuple("In");
                        debug_trait_builder.finish()
                    }
                    (&Operator::Out,) => {
                        let mut debug_trait_builder = f.debug_tuple("Out");
                        debug_trait_builder.finish()
                    }
                    (&Operator::Atop,) => {
                        let mut debug_trait_builder = f.debug_tuple("Atop");
                        debug_trait_builder.finish()
                    }
                    (&Operator::Xor,) => {
                        let mut debug_trait_builder = f.debug_tuple("Xor");
                        debug_trait_builder.finish()
                    }
                    (&Operator::Arithmetic,) => {
                        let mut debug_trait_builder = f.debug_tuple("Arithmetic");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Operator {
            #[inline]
            fn clone(&self) -> Operator {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Operator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Operator {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Operator {
            #[inline]
            fn eq(&self, other: &Operator) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::hash::Hash for Operator {
            fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    _ => ::std::hash::Hash::hash(
                        &unsafe { ::std::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        /// The `feComposite` filter primitive.
        pub struct Composite {
            base: PrimitiveWithInput,
            in2: RefCell<Option<Input>>,
            operator: Cell<Operator>,
            k1: Cell<f64>,
            k2: Cell<f64>,
            k3: Cell<f64>,
            k4: Cell<f64>,
        }
        impl Composite {
            /// Constructs a new `Composite` with empty properties.
            #[inline]
            pub fn new() -> Composite {
                Composite {
                    base: PrimitiveWithInput::new::<Self>(),
                    in2: RefCell::new(None),
                    operator: Cell::new(Operator::Over),
                    k1: Cell::new(0f64),
                    k2: Cell::new(0f64),
                    k3: Cell::new(0f64),
                    k4: Cell::new(0f64),
                }
            }
        }
        impl NodeTrait for Composite {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::In2 => {
                            self.in2.replace(Some(Input::parse(Attribute::In2, value)?));
                        }
                        Attribute::Operator => self.operator.set(parse("operator", value, ())?),
                        Attribute::K1 => self.k1.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::K2 => self.k2.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::K3 => self.k3.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::K4 => self.k4.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        _ => (),
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for Composite {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let input_2 = ctx.get_input(draw_ctx, self.in2.borrow().as_ref())?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .add_input(&input_2)
                    .into_irect(draw_ctx);
                let output_surface = if self.operator.get() == Operator::Arithmetic {
                    let mut output_surface = ImageSurface::create(
                        cairo::Format::ARgb32,
                        input.surface().width(),
                        input.surface().height(),
                    ).map_err(FilterError::IntermediateSurfaceCreation)?;
                    let output_stride = output_surface.get_stride() as usize;
                    {
                        let mut output_data = output_surface.get_data().unwrap();
                        let k1 = self.k1.get();
                        let k2 = self.k2.get();
                        let k3 = self.k3.get();
                        let k4 = self.k4.get();
                        for (x, y, pixel, pixel_2) in Pixels::new(input.surface(), bounds)
                            .map(|(x, y, p)| (x, y, p, input_2.surface().get_pixel(x, y)))
                        {
                            let i1a = f64::from(pixel.a) / 255f64;
                            let i2a = f64::from(pixel_2.a) / 255f64;
                            let oa = k1 * i1a * i2a + k2 * i1a + k3 * i2a + k4;
                            let oa = clamp(oa, 0f64, 1f64);
                            if oa > 0f64 {
                                let compute = |i1, i2| {
                                    let i1 = f64::from(i1) / 255f64;
                                    let i2 = f64::from(i2) / 255f64;
                                    let o = k1 * i1 * i2 + k2 * i1 + k3 * i2 + k4;
                                    let o = clamp(o, 0f64, oa);
                                    (o * 255f64).round() as u8
                                };
                                let output_pixel = Pixel {
                                    r: compute(pixel.r, pixel_2.r),
                                    g: compute(pixel.g, pixel_2.g),
                                    b: compute(pixel.b, pixel_2.b),
                                    a: (oa * 255f64).round() as u8,
                                };
                                output_data.set_pixel(output_stride, output_pixel, x, y);
                            }
                        }
                    }
                    output_surface
                } else {
                    let output_surface = input_2
                        .surface()
                        .copy_surface(bounds)
                        .map_err(FilterError::IntermediateSurfaceCreation)?;
                    let cr = cairo::Context::new(&output_surface);
                    cr.rectangle(
                        bounds.x0 as f64,
                        bounds.y0 as f64,
                        (bounds.x1 - bounds.x0) as f64,
                        (bounds.y1 - bounds.y0) as f64,
                    );
                    cr.clip();
                    input.surface().set_as_source_surface(&cr, 0f64, 0f64);
                    cr.set_operator(self.operator.get().into());
                    cr.paint();
                    output_surface
                };
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
        impl Parse for Operator {
            type Data = ();
            type Err = AttributeError;
            fn parse(parser: &mut Parser, _data: Self::Data) -> Result<Self, Self::Err> {
                let loc = parser.current_source_location();
                parser
                    .expect_ident()
                    .and_then(|cow| match cow.as_ref() {
                        "over" => Ok(Operator::Over),
                        "in" => Ok(Operator::In),
                        "out" => Ok(Operator::Out),
                        "atop" => Ok(Operator::Atop),
                        "xor" => Ok(Operator::Xor),
                        "arithmetic" => Ok(Operator::Arithmetic),
                        _ => Err(loc.new_basic_unexpected_token_error(Token::Ident(
                            CowRcStr::from(cow.as_ref().to_string()),
                        ))),
                    })
                    .map_err(|_| AttributeError::Value("invalid operator value".to_string()))
            }
        }
        impl From<Operator> for cairo::Operator {
            #[inline]
            fn from(x: Operator) -> Self {
                match x {
                    Operator::Over => cairo::Operator::Over,
                    Operator::In => cairo::Operator::In,
                    Operator::Out => cairo::Operator::Out,
                    Operator::Atop => cairo::Operator::Atop,
                    Operator::Xor => cairo::Operator::Xor,
                    _ => ::rt::begin_panic(
                        "can\'t convert Operator::Arithmetic to a cairo::Operator",
                        &("rsvg_internals/src/filters/composite.rs", 242u32, 18u32),
                    ),
                }
            }
        }
    }
    pub mod convolve_matrix {
        use super::context::{FilterContext, FilterOutput, FilterResult, IRect};
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::{self, ImageSurface, MatrixTrait};
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::{self, ListLength, NumberListError, ParseError};
        use property_bag::PropertyBag;
        use rulinalg::matrix::{BaseMatrix, Matrix};
        use std::cell::{Cell, RefCell};
        use surface_utils::{
            iterators::{PixelRectangle, Pixels},
            shared_surface::SharedImageSurface,
            EdgeMode, ImageSurfaceDataExt, Pixel,
        };
        use util::clamp;
        /// The `feConvolveMatrix` filter primitive.
        pub struct ConvolveMatrix {
            base: PrimitiveWithInput,
            order: Cell<(u32, u32)>,
            kernel_matrix: RefCell<Option<Matrix<f64>>>,
            divisor: Cell<Option<f64>>,
            bias: Cell<f64>,
            target_x: Cell<Option<u32>>,
            target_y: Cell<Option<u32>>,
            edge_mode: Cell<EdgeMode>,
            kernel_unit_length: Cell<Option<(f64, f64)>>,
            preserve_alpha: Cell<bool>,
        }
        impl ConvolveMatrix {
            /// Constructs a new `ConvolveMatrix` with empty properties.
            #[inline]
            pub fn new() -> ConvolveMatrix {
                ConvolveMatrix {
                    base: PrimitiveWithInput::new::<Self>(),
                    order: Cell::new((3, 3)),
                    kernel_matrix: RefCell::new(None),
                    divisor: Cell::new(None),
                    bias: Cell::new(0.0),
                    target_x: Cell::new(None),
                    target_y: Cell::new(None),
                    edge_mode: Cell::new(EdgeMode::Duplicate),
                    kernel_unit_length: Cell::new(None),
                    preserve_alpha: Cell::new(false),
                }
            }
        }
        impl NodeTrait for ConvolveMatrix {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::Order => self.order.set(
                            parsers::integer_optional_integer(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|(x, y)| {
                                    if x > 0 && y > 0 {
                                        Ok((x as u32, y as u32))
                                    } else {
                                        Err(NodeError::value_error(
                                            attr,
                                            "values must be greater than 0",
                                        ))
                                    }
                                })?,
                        ),
                        Attribute::Divisor => self.divisor.set(Some(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|x| {
                                    if x != 0.0 {
                                        Ok(x)
                                    } else {
                                        Err(NodeError::value_error(
                                            attr,
                                            "divisor cannot be equal to 0",
                                        ))
                                    }
                                })?,
                        )),
                        Attribute::Bias => self.bias.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::EdgeMode => self.edge_mode.set(EdgeMode::parse(attr, value)?),
                        Attribute::KernelUnitLength => self.kernel_unit_length.set(Some(
                            parsers::number_optional_number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|(x, y)| {
                                    if x > 0.0 && y > 0.0 {
                                        Ok((x, y))
                                    } else {
                                        Err(NodeError::value_error(
                                            attr,
                                            "kernelUnitLength can\'t be less or equal to zero",
                                        ))
                                    }
                                })?,
                        )),
                        Attribute::PreserveAlpha => self.preserve_alpha.set(match value {
                            "false" => false,
                            "true" => true,
                            _ => {
                                return Err(NodeError::parse_error(
                                    attr,
                                    ParseError::new("expected false or true"),
                                ))
                            }
                        }),
                        _ => (),
                    }
                }
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::TargetX => self.target_x.set(Some(
                            parsers::integer(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|x| {
                                    if x >= 0 && x < self.order.get().0 as i32 {
                                        Ok(x as u32)
                                    } else {
                                        Err(NodeError::value_error(attr,
                                                                                                                                                                "targetX must be greater or equal to zero and less than orderX"))
                                    }
                                })?,
                        )),
                        Attribute::TargetY => self.target_y.set(Some(
                            parsers::integer(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|x| {
                                    if x >= 0 && x < self.order.get().1 as i32 {
                                        Ok(x as u32)
                                    } else {
                                        Err(NodeError::value_error(attr,
                                                                                                                                                                "targetY must be greater or equal to zero and less than orderY"))
                                    }
                                })?,
                        )),
                        _ => (),
                    }
                }
                if self.target_x.get().is_none() {
                    self.target_x.set(Some(self.order.get().0 / 2));
                }
                if self.target_y.get().is_none() {
                    self.target_y.set(Some(self.order.get().1 / 2));
                }
                for (_, attr, value) in pbag
                    .iter()
                    .filter(|(_, attr, _)| *attr == Attribute::KernelMatrix)
                {
                    self.kernel_matrix.replace(Some({
                        let number_of_elements =
                            self.order.get().0 as usize * self.order.get().1 as usize;
                        Matrix::new(
                            self.order.get().1 as usize,
                            self.order.get().0 as usize,
                            parsers::number_list_from_str(
                                value,
                                ListLength::Exact(number_of_elements),
                            ).map_err(|err| {
                                NodeError::parse_error(attr,
                                                                                                                                                                                match err
                                                                                                                                                                                    {
                                                                                                                                                                                    NumberListError::IncorrectNumberOfElements
                                                                                                                                                                                    =>
                                                                                                                                                                                    {
                                                                                                                                                                                        ParseError::new(::fmt::format(::std::fmt::Arguments::new_v1_formatted(&["incorrect number of elements: expected "],
                                                                                                                                                                                                                                                              &match (&number_of_elements,)
                                                                                                                                                                                                                                                                   {
                                                                                                                                                                                                                                                                   (arg0,)
                                                                                                                                                                                                                                                                   =>
                                                                                                                                                                                                                                                                   [::std::fmt::ArgumentV1::new(arg0,
                                                                                                                                                                                                                                                                                                ::std::fmt::Display::fmt)],
                                                                                                                                                                                                                                                               },
                                                                                                                                                                                                                                                              &[::std::fmt::rt::v1::Argument{position:
                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::Position::At(0usize),
                                                                                                                                                                                                                                                                                             format:
                                                                                                                                                                                                                                                                                                 ::std::fmt::rt::v1::FormatSpec{fill:
                                                                                                                                                                                                                                                                                                                                    ' ',
                                                                                                                                                                                                                                                                                                                                align:
                                                                                                                                                                                                                                                                                                                                    ::std::fmt::rt::v1::Alignment::Unknown,
                                                                                                                                                                                                                                                                                                                                flags:
                                                                                                                                                                                                                                                                                                                                    0u32,
                                                                                                                                                                                                                                                                                                                                precision:
                                                                                                                                                                                                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,
                                                                                                                                                                                                                                                                                                                                width:
                                                                                                                                                                                                                                                                                                                                    ::std::fmt::rt::v1::Count::Implied,},}])))
                                                                                                                                                                                    }
                                                                                                                                                                                    NumberListError::Parse(err)
                                                                                                                                                                                    =>
                                                                                                                                                                                    err,
                                                                                                                                                                                })
                            })?,
                        )
                    }));
                }
                if self.divisor.get().is_none() {
                    self.divisor
                        .set(Some(self.kernel_matrix.borrow().as_ref().unwrap().sum()));
                    if self.divisor.get().unwrap() == 0.0 {
                        self.divisor.set(Some(1.0));
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for ConvolveMatrix {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let mut bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .into_irect(draw_ctx);
                let original_bounds = bounds;
                let mut input_surface = if self.preserve_alpha.get() {
                    let unpremultiplied_surface = input
                        .surface()
                        .unpremultiply(bounds)
                        .map_err(FilterError::IntermediateSurfaceCreation)?;
                    SharedImageSurface::new(unpremultiplied_surface)
                        .map_err(FilterError::BadIntermediateSurfaceStatus)?
                } else {
                    input.surface().clone()
                };
                let scale = self
                    .kernel_unit_length
                    .get()
                    .map(|(dx, dy)| ctx.paffine().transform_distance(dx, dy));
                if let Some((ox, oy)) = scale {
                    let (new_surface, new_bounds) = input_surface
                        .scale(bounds, 1.0 / ox, 1.0 / oy)
                        .map_err(FilterError::IntermediateSurfaceCreation)?;
                    input_surface = new_surface;
                    bounds = new_bounds;
                }
                let matrix = self.kernel_matrix.borrow();
                let matrix = matrix.as_ref().unwrap();
                let mut output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    input_surface.width(),
                    input_surface.height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let output_stride = output_surface.get_stride() as usize;
                {
                    let mut output_data = output_surface.get_data().unwrap();
                    for (x, y, pixel) in Pixels::new(&input_surface, bounds) {
                        let kernel_bounds = IRect {
                            x0: x as i32 - self.target_x.get().unwrap() as i32,
                            y0: y as i32 - self.target_y.get().unwrap() as i32,
                            x1: x as i32 - self.target_x.get().unwrap() as i32
                                + self.order.get().0 as i32,
                            y1: y as i32 - self.target_y.get().unwrap() as i32
                                + self.order.get().1 as i32,
                        };
                        let mut r = 0.0;
                        let mut g = 0.0;
                        let mut b = 0.0;
                        let mut a = 0.0;
                        for (x, y, pixel) in PixelRectangle::new(
                            &input_surface,
                            bounds,
                            kernel_bounds,
                            self.edge_mode.get(),
                        ) {
                            let kernel_x = (kernel_bounds.x1 - x - 1) as usize;
                            let kernel_y = (kernel_bounds.y1 - y - 1) as usize;
                            r += f64::from(pixel.r) / 255.0 * matrix[[kernel_y, kernel_x]];
                            g += f64::from(pixel.g) / 255.0 * matrix[[kernel_y, kernel_x]];
                            b += f64::from(pixel.b) / 255.0 * matrix[[kernel_y, kernel_x]];
                            if !self.preserve_alpha.get() {
                                a += f64::from(pixel.a) / 255.0 * matrix[[kernel_y, kernel_x]];
                            }
                        }
                        if self.preserve_alpha.get() {
                            a = f64::from(pixel.a) / 255.0;
                        } else {
                            a = a / self.divisor.get().unwrap() + self.bias.get();
                        }
                        let clamped_a = clamp(a, 0.0, 1.0);
                        let compute = |x| {
                            let x = x / self.divisor.get().unwrap() + self.bias.get() * a;
                            let x = if self.preserve_alpha.get() {
                                clamp(x, 0.0, 1.0) * clamped_a
                            } else {
                                clamp(x, 0.0, clamped_a)
                            };
                            (x * 255.0).round() as u8
                        };
                        let output_pixel = Pixel {
                            r: compute(r),
                            g: compute(g),
                            b: compute(b),
                            a: (clamped_a * 255.0).round() as u8,
                        };
                        output_data.set_pixel(output_stride, output_pixel, x, y);
                    }
                }
                let mut output_surface = SharedImageSurface::new(output_surface)
                    .map_err(FilterError::BadIntermediateSurfaceStatus)?;
                if let Some((ox, oy)) = scale {
                    output_surface = output_surface
                        .scale_to(
                            ctx.source_graphic().width(),
                            ctx.source_graphic().height(),
                            original_bounds,
                            ox,
                            oy,
                        )
                        .map_err(FilterError::IntermediateSurfaceCreation)?;
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: output_surface,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
        impl EdgeMode {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "duplicate" => Ok(EdgeMode::Duplicate),
                    "wrap" => Ok(EdgeMode::Wrap),
                    "none" => Ok(EdgeMode::None),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
    }
    pub mod displacement_map {
        use super::context::{FilterContext, FilterOutput, FilterResult};
        use super::{Filter, FilterError, Input, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::{self, ImageSurface, MatrixTrait};
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::{self, ParseError};
        use property_bag::PropertyBag;
        use std::cell::{Cell, RefCell};
        use surface_utils::{iterators::Pixels, shared_surface::SharedImageSurface};
        /// Enumeration of the color channels the displacement map can source.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum ColorChannel {
            R,
            G,
            B,
            A,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for ColorChannel {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&ColorChannel::R,) => {
                        let mut debug_trait_builder = f.debug_tuple("R");
                        debug_trait_builder.finish()
                    }
                    (&ColorChannel::G,) => {
                        let mut debug_trait_builder = f.debug_tuple("G");
                        debug_trait_builder.finish()
                    }
                    (&ColorChannel::B,) => {
                        let mut debug_trait_builder = f.debug_tuple("B");
                        debug_trait_builder.finish()
                    }
                    (&ColorChannel::A,) => {
                        let mut debug_trait_builder = f.debug_tuple("A");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for ColorChannel {
            #[inline]
            fn clone(&self) -> ColorChannel {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for ColorChannel {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for ColorChannel {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for ColorChannel {
            #[inline]
            fn eq(&self, other: &ColorChannel) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::hash::Hash for ColorChannel {
            fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    _ => ::std::hash::Hash::hash(
                        &unsafe { ::std::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        /// The `feDisplacementMap` filter primitive.
        pub struct DisplacementMap {
            base: PrimitiveWithInput,
            in2: RefCell<Option<Input>>,
            scale: Cell<f64>,
            x_channel_selector: Cell<ColorChannel>,
            y_channel_selector: Cell<ColorChannel>,
        }
        impl DisplacementMap {
            /// Constructs a new `DisplacementMap` with empty properties.
            #[inline]
            pub fn new() -> DisplacementMap {
                DisplacementMap {
                    base: PrimitiveWithInput::new::<Self>(),
                    in2: RefCell::new(None),
                    scale: Cell::new(0.0),
                    x_channel_selector: Cell::new(ColorChannel::A),
                    y_channel_selector: Cell::new(ColorChannel::A),
                }
            }
        }
        impl NodeTrait for DisplacementMap {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::In2 => {
                            self.in2.replace(Some(Input::parse(Attribute::In2, value)?));
                        }
                        Attribute::Scale => self.scale.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::XChannelSelector => self
                            .x_channel_selector
                            .set(ColorChannel::parse(attr, value)?),
                        Attribute::YChannelSelector => self
                            .y_channel_selector
                            .set(ColorChannel::parse(attr, value)?),
                        _ => (),
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for DisplacementMap {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let displacement_input = ctx.get_input(draw_ctx, self.in2.borrow().as_ref())?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .add_input(&displacement_input)
                    .into_irect(draw_ctx);
                let displacement_surface = displacement_input
                    .surface()
                    .unpremultiply(bounds)
                    .map_err(FilterError::IntermediateSurfaceCreation)?;
                let displacement_surface = SharedImageSurface::new(displacement_surface)
                    .map_err(FilterError::BadIntermediateSurfaceStatus)?;
                let scale = self.scale.get();
                let (sx, sy) = ctx.paffine().transform_distance(scale, scale);
                let x_channel = self.x_channel_selector.get();
                let y_channel = self.y_channel_selector.get();
                let output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                {
                    let cr = cairo::Context::new(&output_surface);
                    for (x, y, displacement_pixel) in Pixels::new(&displacement_surface, bounds) {
                        let get_value = |channel| match channel {
                            ColorChannel::R => displacement_pixel.r,
                            ColorChannel::G => displacement_pixel.g,
                            ColorChannel::B => displacement_pixel.b,
                            ColorChannel::A => displacement_pixel.a,
                        };
                        let process = |x| f64::from(x) / 255.0 - 0.5;
                        let dx = process(get_value(x_channel));
                        let dy = process(get_value(y_channel));
                        let x = f64::from(x);
                        let y = f64::from(y);
                        let ox = sx * dx;
                        let oy = sy * dy;
                        cr.rectangle(x, y, 1.0, 1.0);
                        cr.reset_clip();
                        cr.clip();
                        input.surface().set_as_source_surface(&cr, -ox, -oy);
                        cr.paint();
                    }
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
        impl ColorChannel {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "R" => Ok(ColorChannel::R),
                    "G" => Ok(ColorChannel::G),
                    "B" => Ok(ColorChannel::B),
                    "A" => Ok(ColorChannel::A),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
    }
    pub mod flood {
        use super::context::{FilterContext, FilterOutput, FilterResult};
        use super::{Filter, FilterError, Primitive};
        use cairo::{self, ImageSurface};
        use cssparser;
        use drawing_ctx::DrawingCtx;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use property_bag::PropertyBag;
        use surface_utils::shared_surface::SharedImageSurface;
        /// The `feFlood` filter primitive.
        pub struct Flood {
            base: Primitive,
        }
        impl Flood {
            /// Constructs a new `Flood` with empty properties.
            #[inline]
            pub fn new() -> Flood {
                Flood {
                    base: Primitive::new::<Self>(),
                }
            }
        }
        impl NodeTrait for Flood {
            #[inline]
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for Flood {
            fn render(
                &self,
                node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let bounds = self.base.get_bounds(ctx).into_irect(draw_ctx);
                let output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let cascaded = node.get_cascaded_values();
                let values = cascaded.get();
                let color = match values.flood_color.0 {
                    cssparser::Color::CurrentColor => values.color.0,
                    cssparser::Color::RGBA(rgba) => rgba,
                };
                let opacity = (values.flood_opacity.0).0;
                if opacity > 0f64 {
                    let cr = cairo::Context::new(&output_surface);
                    cr.rectangle(
                        bounds.x0 as f64,
                        bounds.y0 as f64,
                        (bounds.x1 - bounds.x0) as f64,
                        (bounds.y1 - bounds.y0) as f64,
                    );
                    cr.clip();
                    cr.set_source_rgba(
                        f64::from(color.red) / 255f64,
                        f64::from(color.green) / 255f64,
                        f64::from(color.blue) / 255f64,
                        opacity,
                    );
                    cr.paint();
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                false
            }
        }
    }
    pub mod gaussian_blur {
        use super::context::{FilterContext, FilterOutput, FilterResult, IRect};
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::MatrixTrait;
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers;
        use property_bag::PropertyBag;
        use rulinalg::matrix::Matrix;
        use std::cell::Cell;
        use std::cmp::{max, min};
        use std::f64;
        use surface_utils::{shared_surface::SharedImageSurface, EdgeMode};
        /// The maximum gaussian blur kernel size.
        ///
        /// The value of 500 is used in webkit.
        const MAXIMUM_KERNEL_SIZE: usize = 500;
        /// The `feGaussianBlur` filter primitive.
        pub struct GaussianBlur {
            base: PrimitiveWithInput,
            std_deviation: Cell<(f64, f64)>,
        }
        impl GaussianBlur {
            /// Constructs a new `GaussianBlur` with empty properties.
            #[inline]
            pub fn new() -> GaussianBlur {
                GaussianBlur {
                    base: PrimitiveWithInput::new::<Self>(),
                    std_deviation: Cell::new((0.0, 0.0)),
                }
            }
        }
        impl NodeTrait for GaussianBlur {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::StdDeviation => self.std_deviation.set(
                            parsers::number_optional_number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|(x, y)| {
                                    if x >= 0.0 && y >= 0.0 {
                                        Ok((x, y))
                                    } else {
                                        Err(NodeError::value_error(
                                            attr,
                                            "values can\'t be negative",
                                        ))
                                    }
                                })?,
                        ),
                        _ => (),
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        /// Computes a gaussian kernel line for the given standard deviation.
        fn gaussian_kernel(std_deviation: f64) -> Vec<f64> {
            if !(std_deviation > 0.0) {
                {
                    ::rt::begin_panic(
                        "assertion failed: std_deviation > 0.0",
                        &("rsvg_internals/src/filters/gaussian_blur.rs", 79u32, 5u32),
                    )
                }
            };
            let maximal_deviation = (MAXIMUM_KERNEL_SIZE / 2) as f64 / 3.0;
            let radius = (std_deviation.min(maximal_deviation) * 3.0).round() as usize;
            let radius = min(radius, (MAXIMUM_KERNEL_SIZE - 1) / 2);
            let diameter = radius * 2 + 1;
            let mut kernel = Vec::with_capacity(diameter);
            let gauss_point = |x: f64| (-x.powi(2) / (2.0 * std_deviation.powi(2))).exp();
            for i in 0..diameter / 2 {
                let base_x = (diameter / 2 + 1 - i) as f64 - 0.5;
                let mut sum = 0.0;
                for j in 1..=50 {
                    let r = base_x + 0.02 * f64::from(j);
                    sum += gauss_point(r);
                }
                kernel.push(sum / 50.0);
            }
            kernel.push(0.0);
            for i in 0..diameter / 2 {
                let x = kernel[diameter / 2 - 1 - i];
                kernel.push(x);
            }
            let mut sum = 0.0;
            for j in 0..=50 {
                let r = -0.5 + 0.02 * f64::from(j);
                sum += gauss_point(r);
            }
            kernel[diameter / 2] = sum / 51.0;
            let sum = kernel.iter().sum::<f64>();
            kernel.iter_mut().for_each(|x| *x /= sum);
            kernel
        }
        /// Returns a size of the box blur kernel to approximate the gaussian blur.
        fn box_blur_kernel_size(std_deviation: f64) -> usize {
            let d = (std_deviation * 3.0 * (2.0 * f64::consts::PI).sqrt() / 4.0 + 0.5).floor();
            let d = d.min(MAXIMUM_KERNEL_SIZE as f64);
            d as usize
        }
        /// Returns a box blur kernel with the given size.
        fn box_blur_kernel(size: usize) -> Vec<f64> {
            ::vec::from_elem(1.0 / size as f64, size)
        }
        /// Applies three box blurs to approximate the gaussian blur.
        ///
        /// This is intended to be used in two steps, horizontal and vertical.
        fn three_box_blurs(
            input_surface: &SharedImageSurface,
            bounds: IRect,
            std_deviation: f64,
            vertical: bool,
        ) -> Result<SharedImageSurface, FilterError> {
            let d = box_blur_kernel_size(std_deviation);
            let (rows, cols) = if vertical { (d, 1) } else { (1, d) };
            let kernel = Matrix::new(rows, cols, box_blur_kernel(d));
            let surface = if d % 2 == 1 {
                let mut surface = input_surface.clone();
                for _ in 0..3 {
                    surface = SharedImageSurface::new(
                        surface
                            .convolve(
                                bounds,
                                ((cols / 2) as i32, (rows / 2) as i32),
                                &kernel,
                                EdgeMode::None,
                            )
                            .map_err(FilterError::IntermediateSurfaceCreation)?,
                    ).map_err(FilterError::BadInputSurfaceStatus)?;
                }
                surface
            } else {
                let surface = SharedImageSurface::new(
                    input_surface
                        .convolve(
                            bounds,
                            ((cols / 2) as i32, (rows / 2) as i32),
                            &kernel,
                            EdgeMode::None,
                        )
                        .map_err(FilterError::IntermediateSurfaceCreation)?,
                ).map_err(FilterError::BadInputSurfaceStatus)?;
                let surface = SharedImageSurface::new(
                    surface
                        .convolve(
                            bounds,
                            (max((cols / 2) as i32 - 1, 0), max((rows / 2) as i32 - 1, 0)),
                            &kernel,
                            EdgeMode::None,
                        )
                        .map_err(FilterError::IntermediateSurfaceCreation)?,
                ).map_err(FilterError::BadInputSurfaceStatus)?;
                let d = d + 1;
                let (rows, cols) = if vertical { (d, 1) } else { (1, d) };
                let kernel = Matrix::new(rows, cols, box_blur_kernel(d));
                SharedImageSurface::new(
                    surface
                        .convolve(
                            bounds,
                            ((cols / 2) as i32, (rows / 2) as i32),
                            &kernel,
                            EdgeMode::None,
                        )
                        .map_err(FilterError::IntermediateSurfaceCreation)?,
                ).map_err(FilterError::BadInputSurfaceStatus)?
            };
            Ok(surface)
        }
        /// Applies the gaussian blur.
        ///
        /// This is intended to be used in two steps, horizontal and vertical.
        fn gaussian_blur(
            input_surface: &SharedImageSurface,
            bounds: IRect,
            std_deviation: f64,
            vertical: bool,
        ) -> Result<SharedImageSurface, FilterError> {
            let kernel = gaussian_kernel(std_deviation);
            let (rows, cols) = if vertical {
                (kernel.len(), 1)
            } else {
                (1, kernel.len())
            };
            let kernel = Matrix::new(rows, cols, kernel);
            SharedImageSurface::new(
                input_surface
                    .convolve(
                        bounds,
                        ((cols / 2) as i32, (rows / 2) as i32),
                        &kernel,
                        EdgeMode::None,
                    )
                    .map_err(FilterError::IntermediateSurfaceCreation)?,
            ).map_err(FilterError::BadIntermediateSurfaceStatus)
        }
        impl Filter for GaussianBlur {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .into_irect(draw_ctx);
                let (std_x, std_y) = self.std_deviation.get();
                let (std_x, std_y) = ctx.paffine().transform_distance(std_x, std_y);
                let std_x = std_x.abs();
                let std_y = std_y.abs();
                let horiz_result_surface = if std_x != 0.0 {
                    if std_x >= 2.0 {
                        three_box_blurs(input.surface(), bounds, std_x, false)?
                    } else {
                        gaussian_blur(input.surface(), bounds, std_x, false)?
                    }
                } else {
                    input.surface().clone()
                };
                let output_surface = if std_y != 0.0 {
                    if std_y >= 2.0 {
                        three_box_blurs(&horiz_result_surface, bounds, std_y, true)?
                    } else {
                        gaussian_blur(&horiz_result_surface, bounds, std_y, true)?
                    }
                } else {
                    horiz_result_surface
                };
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: output_surface,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
    }
    pub mod image {
        use super::bounds::BoundsBuilder;
        use super::context::{FilterContext, FilterOutput, FilterResult, IRect};
        use super::{Filter, FilterError, Primitive};
        use aspect_ratio::AspectRatio;
        use attributes::Attribute;
        use cairo::{self, ImageSurface, MatrixTrait, Pattern};
        use cairo_sys;
        use drawing_ctx::DrawingCtx;
        use glib;
        use glib::translate::{from_glib_full, ToGlibPtr};
        use glib_sys;
        use handle::RsvgHandle;
        use libc;
        use node::{CascadedValues, NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::parse;
        use property_bag::PropertyBag;
        use std::cell::{Cell, RefCell};
        use std::ptr;
        use surface_utils::shared_surface::SharedImageSurface;
        /// The `feImage` filter primitive.
        pub struct Image {
            base: Primitive,
            aspect: Cell<AspectRatio>,
            href: RefCell<Option<String>>,
            handle: Cell<*const RsvgHandle>,
        }
        impl Image {
            /// Constructs a new `Image` with empty properties.
            #[inline]
            pub fn new() -> Image {
                Image {
                    base: Primitive::new::<Self>(),
                    aspect: Cell::new(AspectRatio::default()),
                    href: RefCell::new(None),
                    handle: Cell::new(ptr::null()),
                }
            }
            /// Renders the filter if the source is an existing node.
            fn render_node(
                &self,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
                bounds: IRect,
                href: &str,
            ) -> Result<ImageSurface, FilterError> {
                let acquired_drawable = draw_ctx
                    .get_acquired_node(href)
                    .ok_or(FilterError::InvalidInput)?;
                let drawable = acquired_drawable.get();
                let surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                draw_ctx.get_cairo_context().set_matrix(ctx.paffine());
                let node_being_filtered = ctx.get_node_being_filtered();
                let node_being_filtered_cascaded = node_being_filtered.get_cascaded_values();
                let node_being_filtered_values = node_being_filtered_cascaded.get();
                let cascaded =
                    CascadedValues::new_from_values(&drawable, node_being_filtered_values);
                draw_ctx.draw_node_on_surface(
                    &drawable,
                    &cascaded,
                    &surface,
                    f64::from(ctx.source_graphic().width()),
                    f64::from(ctx.source_graphic().height()),
                );
                let output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let cr = cairo::Context::new(&output_surface);
                cr.rectangle(
                    f64::from(bounds.x0),
                    f64::from(bounds.y0),
                    f64::from(bounds.x1 - bounds.x0),
                    f64::from(bounds.y1 - bounds.y0),
                );
                cr.clip();
                cr.set_source_surface(&surface, 0f64, 0f64);
                cr.paint();
                Ok(output_surface)
            }
            /// Renders the filter if the source is an external image.
            fn render_external_image(
                &self,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
                bounds_builder: BoundsBuilder,
                href: &str,
            ) -> Result<ImageSurface, FilterError> {
                let surface = {
                    extern "C" {
                        fn rsvg_cairo_surface_new_from_href(
                            handle: *const RsvgHandle,
                            href: *const libc::c_char,
                            error: *mut *mut glib_sys::GError,
                        ) -> *mut cairo_sys::cairo_surface_t;
                    }
                    let mut error = ptr::null_mut();
                    let raw_surface = unsafe {
                        rsvg_cairo_surface_new_from_href(
                            self.handle.get(),
                            href.to_glib_none().0,
                            &mut error,
                        )
                    };
                    if !raw_surface.is_null() {
                        unsafe { cairo::ImageSurface::from_raw_full(raw_surface).unwrap() }
                    } else {
                        let _: glib::Error = unsafe { from_glib_full(error) };
                        return Err(FilterError::InvalidInput);
                    }
                };
                let output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let render_bounds = bounds_builder.into_irect_without_clipping(draw_ctx);
                let aspect = self.aspect.get();
                let (x, y, w, h) = aspect.compute(
                    f64::from(surface.get_width()),
                    f64::from(surface.get_height()),
                    f64::from(render_bounds.x0),
                    f64::from(render_bounds.y0),
                    f64::from(render_bounds.x1 - render_bounds.x0),
                    f64::from(render_bounds.y1 - render_bounds.y0),
                );
                if w != 0f64 && h != 0f64 {
                    let ptn = cairo::SurfacePattern::create(&surface);
                    let mut matrix = cairo::Matrix::new(
                        w / f64::from(surface.get_width()),
                        0f64,
                        0f64,
                        h / f64::from(surface.get_height()),
                        x,
                        y,
                    );
                    matrix.invert();
                    ptn.set_matrix(matrix);
                    let bounds = bounds_builder.into_irect(draw_ctx);
                    let cr = cairo::Context::new(&output_surface);
                    cr.rectangle(
                        f64::from(bounds.x0),
                        f64::from(bounds.y0),
                        f64::from(bounds.x1 - bounds.x0),
                        f64::from(bounds.y1 - bounds.y0),
                    );
                    cr.clip();
                    cr.set_source(&ptn);
                    cr.paint();
                }
                Ok(output_surface)
            }
        }
        impl NodeTrait for Image {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::PreserveAspectRatio => {
                            self.aspect.set(parse("preserveAspectRatio", value, ())?)
                        }
                        Attribute::XlinkHref | Attribute::Path => {
                            drop(self.href.replace(Some(value.to_string())))
                        }
                        _ => (),
                    }
                }
                self.handle.set(handle);
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for Image {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let href = self.href.borrow();
                let href = href.as_ref().ok_or(FilterError::InvalidInput)?;
                let bounds_builder = self.base.get_bounds(ctx);
                let bounds = bounds_builder.into_irect(draw_ctx);
                let output_surface = match self.render_node(ctx, draw_ctx, bounds, href) {
                    Err(FilterError::InvalidInput) => {
                        self.render_external_image(ctx, draw_ctx, bounds_builder, href)?
                    }
                    Err(err) => return Err(err),
                    Ok(surface) => surface,
                };
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                false
            }
        }
    }
    pub mod light {
        //! Light filters and nodes.
        use filters::context::IRect;
        use rulinalg::{norm::Euclidean, vector::Vector};
        use surface_utils::{
            iterators::PixelRectangle, shared_surface::SharedImageSurface, EdgeMode,
        };
        pub mod diffuse_lighting {
            use attributes::Attribute;
            use cairo::{self, ImageSurface, MatrixTrait};
            use cssparser;
            use drawing_ctx::DrawingCtx;
            use error::NodeError;
            use filters::{
                context::{FilterContext, FilterOutput, FilterResult},
                light::{light_source::LightSource, normal},
                Filter, FilterError, PrimitiveWithInput,
            };
            use handle::RsvgHandle;
            use node::{NodeResult, NodeTrait, NodeType, RsvgCNodeImpl, RsvgNode};
            use parsers;
            use property_bag::PropertyBag;
            use std::cell::Cell;
            use surface_utils::{
                iterators::Pixels, shared_surface::SharedImageSurface, ImageSurfaceDataExt, Pixel,
            };
            use util::clamp;
            /// The `feDiffuseLighting` filter primitive.
            pub struct DiffuseLighting {
                base: PrimitiveWithInput,
                surface_scale: Cell<f64>,
                diffuse_constant: Cell<f64>,
                kernel_unit_length: Cell<Option<(f64, f64)>>,
            }
            impl DiffuseLighting {
                /// Constructs a new `DiffuseLighting` with empty properties.
                #[inline]
                pub fn new() -> DiffuseLighting {
                    DiffuseLighting {
                        base: PrimitiveWithInput::new::<Self>(),
                        surface_scale: Cell::new(1.0),
                        diffuse_constant: Cell::new(1.0),
                        kernel_unit_length: Cell::new(None),
                    }
                }
            }
            impl NodeTrait for DiffuseLighting {
                fn set_atts(
                    &self,
                    node: &RsvgNode,
                    handle: *const RsvgHandle,
                    pbag: &PropertyBag,
                ) -> NodeResult {
                    self.base.set_atts(node, handle, pbag)?;
                    for (_key, attr, value) in pbag.iter() {
                        match attr {
                            Attribute::SurfaceScale => self.surface_scale.set(
                                parsers::number(value)
                                    .map_err(|err| NodeError::parse_error(attr, err))?,
                            ),
                            Attribute::DiffuseConstant => self.diffuse_constant.set(
                                parsers::number(value)
                                    .map_err(|err| NodeError::parse_error(attr, err))
                                    .and_then(|x| {
                                        if x >= 0.0 {
                                            Ok(x)
                                        } else {
                                            Err(NodeError::value_error(
                                                attr,
                                                "diffuseConstant can\'t be negative",
                                            ))
                                        }
                                    })?,
                            ),
                            Attribute::KernelUnitLength => {
                                self.kernel_unit_length.set(Some(
                                    parsers::number_optional_number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))
                                        .and_then(|(x, y)| {
                                            if x > 0.0 && y > 0.0 {
                                                Ok((x, y))
                                            } else {
                                                Err(NodeError::value_error(attr,
                                                                                                                                                                                             "kernelUnitLength can\'t be less or equal to zero"))
                                            }
                                        })?,
                                ))
                            }
                            _ => (),
                        }
                    }
                    Ok(())
                }
                #[inline]
                fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                    self.base.get_c_impl()
                }
            }
            impl Filter for DiffuseLighting {
                fn render(
                    &self,
                    node: &RsvgNode,
                    ctx: &FilterContext,
                    draw_ctx: &mut DrawingCtx,
                ) -> Result<FilterResult, FilterError> {
                    let input = self.base.get_input(ctx, draw_ctx)?;
                    let mut bounds = self
                        .base
                        .get_bounds(ctx)
                        .add_input(&input)
                        .into_irect(draw_ctx);
                    let original_bounds = bounds;
                    let scale = self
                        .kernel_unit_length
                        .get()
                        .map(|(dx, dy)| ctx.paffine().transform_distance(dx, dy));
                    let surface_scale = self.surface_scale.get();
                    let diffuse_constant = self.diffuse_constant.get();
                    let cascaded = node.get_cascaded_values();
                    let values = cascaded.get();
                    let lighting_color = match values.lighting_color.0 {
                        cssparser::Color::CurrentColor => values.color.0,
                        cssparser::Color::RGBA(rgba) => rgba,
                    };
                    let mut light_sources = node
                        .children()
                        .rev()
                        .filter(|c| c.get_type() == NodeType::LightSource);
                    let light_source = light_sources.next();
                    if light_source.is_none() || light_sources.next().is_some() {
                        return Err(FilterError::InvalidLightSourceCount);
                    }
                    let light_source = light_source.unwrap();
                    let light_source = light_source.get_impl::<LightSource>().unwrap();
                    let mut input_surface = input.surface().clone();
                    if let Some((ox, oy)) = scale {
                        let (new_surface, new_bounds) = input_surface
                            .scale(bounds, 1.0 / ox, 1.0 / oy)
                            .map_err(FilterError::IntermediateSurfaceCreation)?;
                        input_surface = new_surface;
                        bounds = new_bounds;
                    }
                    let mut output_surface = ImageSurface::create(
                        cairo::Format::ARgb32,
                        input_surface.width(),
                        input_surface.height(),
                    ).map_err(FilterError::IntermediateSurfaceCreation)?;
                    let output_stride = output_surface.get_stride() as usize;
                    {
                        let mut output_data = output_surface.get_data().unwrap();
                        for (x, y, _pixel) in Pixels::new(&input_surface, bounds) {
                            let normal = normal(&input_surface, bounds, x, y, surface_scale);
                            let light_vector =
                                light_source.vector(&input_surface, x, y, surface_scale, ctx);
                            let light_color =
                                light_source.color(lighting_color, &light_vector, ctx);
                            let n_dot_l = normal.dot(&light_vector);
                            let compute = |x| {
                                clamp(diffuse_constant * n_dot_l * f64::from(x), 0.0, 255.0).round()
                                    as u8
                            };
                            let output_pixel = Pixel {
                                r: compute(light_color.red),
                                g: compute(light_color.green),
                                b: compute(light_color.blue),
                                a: 255,
                            }.premultiply();
                            output_data.set_pixel(output_stride, output_pixel, x, y);
                        }
                    }
                    let mut output_surface = SharedImageSurface::new(output_surface)
                        .map_err(FilterError::BadIntermediateSurfaceStatus)?;
                    if let Some((ox, oy)) = scale {
                        output_surface = output_surface
                            .scale_to(
                                ctx.source_graphic().width(),
                                ctx.source_graphic().height(),
                                original_bounds,
                                ox,
                                oy,
                            )
                            .map_err(FilterError::IntermediateSurfaceCreation)?;
                    }
                    Ok(FilterResult {
                        name: self.base.result.borrow().clone(),
                        output: FilterOutput {
                            surface: output_surface,
                            bounds,
                        },
                    })
                }
                #[inline]
                fn is_affected_by_color_interpolation_filters() -> bool {
                    true
                }
            }
        }
        pub mod light_source {
            use attributes::Attribute;
            use cairo::MatrixTrait;
            use cssparser;
            use error::NodeError;
            use filters::{context::FilterContext, light::normalize};
            use handle::RsvgHandle;
            use node::{NodeResult, NodeTrait, RsvgNode};
            use parsers;
            use property_bag::PropertyBag;
            use rulinalg::vector::Vector;
            use std::cell::Cell;
            use surface_utils::shared_surface::SharedImageSurface;
            use util::clamp;
            /// A light source node (`feDistantLight`, `fePointLight` or `feSpotLight`).
            pub enum LightSource {
                Distant {
                    azimuth: Cell<f64>,
                    elevation: Cell<f64>,
                },
                Point {
                    x: Cell<f64>,
                    y: Cell<f64>,
                    z: Cell<f64>,
                },
                Spot {
                    x: Cell<f64>,
                    y: Cell<f64>,
                    z: Cell<f64>,
                    points_at_x: Cell<f64>,
                    points_at_y: Cell<f64>,
                    points_at_z: Cell<f64>,
                    specular_exponent: Cell<f64>,
                    limiting_cone_angle: Cell<Option<f64>>,
                },
            }
            impl LightSource {
                /// Constructs a new `feDistantLight` with empty properties.
                #[inline]
                pub fn new_distant_light() -> LightSource {
                    LightSource::Distant {
                        azimuth: Cell::new(0.0),
                        elevation: Cell::new(0.0),
                    }
                }
                /// Constructs a new `fePointLight` with empty properties.
                #[inline]
                pub fn new_point_light() -> LightSource {
                    LightSource::Point {
                        x: Cell::new(0.0),
                        y: Cell::new(0.0),
                        z: Cell::new(0.0),
                    }
                }
                /// Constructs a new `feSpotLight` with empty properties.
                #[inline]
                pub fn new_spot_light() -> LightSource {
                    LightSource::Spot {
                        x: Cell::new(0.0),
                        y: Cell::new(0.0),
                        z: Cell::new(0.0),
                        points_at_x: Cell::new(0.0),
                        points_at_y: Cell::new(0.0),
                        points_at_z: Cell::new(0.0),
                        specular_exponent: Cell::new(0.0),
                        limiting_cone_angle: Cell::new(None),
                    }
                }
                /// Returns the unit (or null) vector from the image sample to the light.
                #[inline]
                pub fn vector(
                    &self,
                    surface: &SharedImageSurface,
                    x: u32,
                    y: u32,
                    surface_scale: f64,
                    ctx: &FilterContext,
                ) -> Vector<f64> {
                    match self {
                        LightSource::Distant { azimuth, elevation } => {
                            let azimuth = azimuth.get().to_radians();
                            let elevation = elevation.get().to_radians();
                            {
                                use vector::Vector;
                                Vector::new(<[_]>::into_vec(box [
                                    azimuth.cos() * elevation.cos(),
                                    azimuth.sin() * elevation.cos(),
                                    elevation.sin(),
                                ]))
                            }
                        }
                        LightSource::Point {
                            x: light_x,
                            y: light_y,
                            z: light_z,
                        }
                        | LightSource::Spot {
                            x: light_x,
                            y: light_y,
                            z: light_z,
                            ..
                        } => {
                            let (light_x_, light_y_) =
                                ctx.paffine().transform_point(light_x.get(), light_y.get());
                            let light_z_ = ctx.transform_dist(light_z.get());
                            let z = f64::from(surface.get_pixel(x, y).a) / 255.0;
                            let mut v = {
                                use vector::Vector;
                                Vector::new(<[_]>::into_vec(box [
                                    light_x_ - f64::from(x),
                                    light_y_ - f64::from(y),
                                    light_z_ - z * surface_scale,
                                ]))
                            };
                            let _ = normalize(&mut v);
                            v
                        }
                    }
                }
                /// Returns the color of the light.
                #[inline]
                pub fn color(
                    &self,
                    lighting_color: cssparser::RGBA,
                    light_vector: &Vector<f64>,
                    ctx: &FilterContext,
                ) -> cssparser::RGBA {
                    match self {
                        LightSource::Spot {
                            x: light_x,
                            y: light_y,
                            z: light_z,
                            points_at_x,
                            points_at_y,
                            points_at_z,
                            specular_exponent,
                            limiting_cone_angle,
                            ..
                        } => {
                            let (light_x, light_y) =
                                ctx.paffine().transform_point(light_x.get(), light_y.get());
                            let light_z = ctx.transform_dist(light_z.get());
                            let (points_at_x, points_at_y) = ctx
                                .paffine()
                                .transform_point(points_at_x.get(), points_at_y.get());
                            let points_at_z = ctx.transform_dist(points_at_z.get());
                            let mut s = {
                                use vector::Vector;
                                Vector::new(<[_]>::into_vec(box [
                                    points_at_x - light_x,
                                    points_at_y - light_y,
                                    points_at_z - light_z,
                                ]))
                            };
                            if normalize(&mut s).is_err() {
                                return cssparser::RGBA::transparent();
                            }
                            let minus_l_dot_s = -light_vector.dot(&s);
                            if minus_l_dot_s <= 0.0 {
                                return cssparser::RGBA::transparent();
                            }
                            if let Some(limiting_cone_angle) = limiting_cone_angle.get() {
                                if minus_l_dot_s < limiting_cone_angle.to_radians().cos() {
                                    return cssparser::RGBA::transparent();
                                }
                            }
                            let factor = minus_l_dot_s.powf(specular_exponent.get());
                            let compute =
                                |x| clamp(f64::from(x) * factor, 0.0, 255.0).round() as u8;
                            cssparser::RGBA {
                                red: compute(lighting_color.red),
                                green: compute(lighting_color.green),
                                blue: compute(lighting_color.blue),
                                alpha: 255,
                            }
                        }
                        _ => lighting_color,
                    }
                }
            }
            impl NodeTrait for LightSource {
                fn set_atts(
                    &self,
                    _node: &RsvgNode,
                    _handle: *const RsvgHandle,
                    pbag: &PropertyBag,
                ) -> NodeResult {
                    for (_key, attr, value) in pbag.iter() {
                        match self {
                            LightSource::Distant {
                                ref azimuth,
                                ref elevation,
                            } => match attr {
                                Attribute::Azimuth => azimuth.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::Elevation => elevation.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                _ => (),
                            },
                            LightSource::Point {
                                ref x,
                                ref y,
                                ref z,
                            } => match attr {
                                Attribute::X => x.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::Y => y.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::Z => z.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                _ => (),
                            },
                            LightSource::Spot {
                                ref x,
                                ref y,
                                ref z,
                                ref points_at_x,
                                ref points_at_y,
                                ref points_at_z,
                                ref specular_exponent,
                                ref limiting_cone_angle,
                            } => match attr {
                                Attribute::X => x.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::Y => y.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::Z => z.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::PointsAtX => points_at_x.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::PointsAtY => points_at_y.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::PointsAtZ => points_at_z.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::SpecularExponent => specular_exponent.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                ),
                                Attribute::LimitingConeAngle => limiting_cone_angle.set(Some(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))?,
                                )),
                                _ => (),
                            },
                        }
                    }
                    Ok(())
                }
            }
        }
        pub mod specular_lighting {
            use attributes::Attribute;
            use cairo::{self, ImageSurface, MatrixTrait};
            use cssparser;
            use drawing_ctx::DrawingCtx;
            use error::NodeError;
            use filters::{
                context::{FilterContext, FilterOutput, FilterResult},
                light::{light_source::LightSource, normal, normalize},
                Filter, FilterError, PrimitiveWithInput,
            };
            use handle::RsvgHandle;
            use node::{NodeResult, NodeTrait, NodeType, RsvgCNodeImpl, RsvgNode};
            use parsers;
            use property_bag::PropertyBag;
            use std::cell::Cell;
            use std::cmp::max;
            use surface_utils::{
                iterators::Pixels, shared_surface::SharedImageSurface, ImageSurfaceDataExt, Pixel,
            };
            use util::clamp;
            /// The `feSpecularLighting` filter primitive.
            pub struct SpecularLighting {
                base: PrimitiveWithInput,
                surface_scale: Cell<f64>,
                specular_constant: Cell<f64>,
                specular_exponent: Cell<f64>,
                kernel_unit_length: Cell<Option<(f64, f64)>>,
            }
            impl SpecularLighting {
                /// Constructs a new `SpecularLighting` with empty properties.
                #[inline]
                pub fn new() -> SpecularLighting {
                    SpecularLighting {
                        base: PrimitiveWithInput::new::<Self>(),
                        surface_scale: Cell::new(1.0),
                        specular_constant: Cell::new(1.0),
                        specular_exponent: Cell::new(1.0),
                        kernel_unit_length: Cell::new(None),
                    }
                }
            }
            impl NodeTrait for SpecularLighting {
                fn set_atts(
                    &self,
                    node: &RsvgNode,
                    handle: *const RsvgHandle,
                    pbag: &PropertyBag,
                ) -> NodeResult {
                    self.base.set_atts(node, handle, pbag)?;
                    for (_key, attr, value) in pbag.iter() {
                        match attr {
                            Attribute::SurfaceScale => self.surface_scale.set(
                                parsers::number(value)
                                    .map_err(|err| NodeError::parse_error(attr, err))?,
                            ),
                            Attribute::SpecularConstant => self.specular_constant.set(
                                parsers::number(value)
                                    .map_err(|err| NodeError::parse_error(attr, err))
                                    .and_then(|x| {
                                        if x >= 0.0 {
                                            Ok(x)
                                        } else {
                                            Err(NodeError::value_error(
                                                attr,
                                                "diffuseConstant can\'t be negative",
                                            ))
                                        }
                                    })?,
                            ),
                            Attribute::SpecularExponent => {
                                self.specular_exponent.set(
                                    parsers::number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))
                                        .and_then(|x| {
                                            if x >= 1.0 && x <= 128.0 {
                                                Ok(x)
                                            } else {
                                                Err(NodeError::value_error(attr,
                                                                                                                                                                       "specularExponent should be between 1.0 and 128.0"))
                                            }
                                        })?,
                                )
                            }
                            Attribute::KernelUnitLength => {
                                self.kernel_unit_length.set(Some(
                                    parsers::number_optional_number(value)
                                        .map_err(|err| NodeError::parse_error(attr, err))
                                        .and_then(|(x, y)| {
                                            if x > 0.0 && y > 0.0 {
                                                Ok((x, y))
                                            } else {
                                                Err(NodeError::value_error(attr,
                                                                                                                                                                                             "kernelUnitLength can\'t be less or equal to zero"))
                                            }
                                        })?,
                                ))
                            }
                            _ => (),
                        }
                    }
                    Ok(())
                }
                #[inline]
                fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                    self.base.get_c_impl()
                }
            }
            impl Filter for SpecularLighting {
                fn render(
                    &self,
                    node: &RsvgNode,
                    ctx: &FilterContext,
                    draw_ctx: &mut DrawingCtx,
                ) -> Result<FilterResult, FilterError> {
                    let input = self.base.get_input(ctx, draw_ctx)?;
                    let mut bounds = self
                        .base
                        .get_bounds(ctx)
                        .add_input(&input)
                        .into_irect(draw_ctx);
                    let original_bounds = bounds;
                    let scale = self
                        .kernel_unit_length
                        .get()
                        .map(|(dx, dy)| ctx.paffine().transform_distance(dx, dy));
                    let surface_scale = self.surface_scale.get();
                    let specular_constant = self.specular_constant.get();
                    let specular_exponent = self.specular_exponent.get();
                    let cascaded = node.get_cascaded_values();
                    let values = cascaded.get();
                    let lighting_color = match values.lighting_color.0 {
                        cssparser::Color::CurrentColor => values.color.0,
                        cssparser::Color::RGBA(rgba) => rgba,
                    };
                    let mut light_sources = node
                        .children()
                        .rev()
                        .filter(|c| c.get_type() == NodeType::LightSource);
                    let light_source = light_sources.next();
                    if light_source.is_none() || light_sources.next().is_some() {
                        return Err(FilterError::InvalidLightSourceCount);
                    }
                    let light_source = light_source.unwrap();
                    let light_source = light_source.get_impl::<LightSource>().unwrap();
                    let mut input_surface = input.surface().clone();
                    if let Some((ox, oy)) = scale {
                        let (new_surface, new_bounds) = input_surface
                            .scale(bounds, 1.0 / ox, 1.0 / oy)
                            .map_err(FilterError::IntermediateSurfaceCreation)?;
                        input_surface = new_surface;
                        bounds = new_bounds;
                    }
                    let mut output_surface = ImageSurface::create(
                        cairo::Format::ARgb32,
                        input_surface.width(),
                        input_surface.height(),
                    ).map_err(FilterError::IntermediateSurfaceCreation)?;
                    let output_stride = output_surface.get_stride() as usize;
                    {
                        let mut output_data = output_surface.get_data().unwrap();
                        for (x, y, _pixel) in Pixels::new(&input_surface, bounds) {
                            let normal = normal(&input_surface, bounds, x, y, surface_scale);
                            let light_vector =
                                light_source.vector(&input_surface, x, y, surface_scale, ctx);
                            let light_color =
                                light_source.color(lighting_color, &light_vector, ctx);
                            let mut h = light_vector + {
                                use vector::Vector;
                                Vector::new(<[_]>::into_vec(box [0.0, 0.0, 1.0]))
                            };
                            let _ = normalize(&mut h);
                            let n_dot_h = normal.dot(&h);
                            let factor = specular_constant * n_dot_h.powf(specular_exponent);
                            let compute =
                                |x| clamp(factor * f64::from(x), 0.0, 255.0).round() as u8;
                            let mut output_pixel = Pixel {
                                r: compute(light_color.red),
                                g: compute(light_color.green),
                                b: compute(light_color.blue),
                                a: 0,
                            };
                            output_pixel.a =
                                max(max(output_pixel.r, output_pixel.g), output_pixel.b);
                            output_data.set_pixel(output_stride, output_pixel, x, y);
                        }
                    }
                    let mut output_surface = SharedImageSurface::new(output_surface)
                        .map_err(FilterError::BadIntermediateSurfaceStatus)?;
                    if let Some((ox, oy)) = scale {
                        output_surface = output_surface
                            .scale_to(
                                ctx.source_graphic().width(),
                                ctx.source_graphic().height(),
                                original_bounds,
                                ox,
                                oy,
                            )
                            .map_err(FilterError::IntermediateSurfaceCreation)?;
                    }
                    Ok(FilterResult {
                        name: self.base.result.borrow().clone(),
                        output: FilterOutput {
                            surface: output_surface,
                            bounds,
                        },
                    })
                }
                #[inline]
                fn is_affected_by_color_interpolation_filters() -> bool {
                    true
                }
            }
        }
        /// Normalizes a `Vector`. Returns `Err(())` if the vector has a length of zero.
        fn normalize(v: &mut Vector<f64>) -> Result<(), ()> {
            let norm = v.norm(Euclidean);
            if norm == 0.0 {
                return Err(());
            }
            *v /= norm;
            Ok(())
        }
        /// Computes and returns the normal vector for the light filters.
        fn normal(
            surface: &SharedImageSurface,
            bounds: IRect,
            x: u32,
            y: u32,
            surface_scale: f64,
        ) -> Vector<f64> {
            if !(x as i32 >= bounds.x0) {
                {
                    ::rt::begin_panic(
                        "assertion failed: x as i32 >= bounds.x0",
                        &("rsvg_internals/src/filters/light/mod.rs", 30u32, 5u32),
                    )
                }
            };
            if !(y as i32 >= bounds.y0) {
                {
                    ::rt::begin_panic(
                        "assertion failed: y as i32 >= bounds.y0",
                        &("rsvg_internals/src/filters/light/mod.rs", 31u32, 5u32),
                    )
                }
            };
            if !((x as i32) < bounds.x1) {
                {
                    ::rt::begin_panic(
                        "assertion failed: (x as i32) < bounds.x1",
                        &("rsvg_internals/src/filters/light/mod.rs", 32u32, 5u32),
                    )
                }
            };
            if !((y as i32) < bounds.y1) {
                {
                    ::rt::begin_panic(
                        "assertion failed: (y as i32) < bounds.y1",
                        &("rsvg_internals/src/filters/light/mod.rs", 33u32, 5u32),
                    )
                }
            };
            let (factor_x, kx, factor_y, ky) = match (x as i32, y as i32) {
                (x, y) if (x, y) == (bounds.x0, bounds.y0) => (
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., 0., 0.], [0., -2., 2.], [0., -1., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., 0., 0.], [0., -2., -1.], [0., 2., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                (x, y) if (x + 1, y) == (bounds.x1, bounds.y0) => (
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., 0., 0.], [-2., 2., 0.], [-1., 1., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., 0., 0.], [-1., -2., 0.], [1., 2., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                (x, y) if (x, y + 1) == (bounds.x0, bounds.y1) => (
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., -1., 1.], [0., -2., 2.], [0., 0., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., -2., -1.], [0., 2., 1.], [0., 0., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                (x, y) if (x + 1, y + 1) == (bounds.x1, bounds.y1) => (
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., 1., 0.], [-2., 2., 0.], [0., 0., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    2. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., -2., 0.], [1., 2., 0.], [0., 0., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                (_, y) if y == bounds.y0 => (
                    1. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., 0., 0.], [-2., 0., 2.], [-1., 0., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    1. / 2.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., 0., 0.], [-1., -2., -1.], [1., 2., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                (x, _) if x == bounds.x0 => (
                    1. / 2.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., -1., 1.], [0., -2., 2.], [0., -1., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    1. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[0., -2., -1.], [0., 0., 0.], [0., 2., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                (x, _) if x + 1 == bounds.x1 => (
                    1. / 2.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., 1., 0.], [-2., 2., 0.], [-1., 1., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    1. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., -2., 0.], [0., 0., 0.], [1., 2., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                (_, y) if y + 1 == bounds.y1 => (
                    1. / 3.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., 0., 1.], [-2., 0., 2.], [0., 0., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    1. / 2.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., -2., -1.], [1., 2., 1.], [0., 0., 0.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
                _ => (
                    1. / 4.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., 0., 1.], [-2., 0., 2.], [-1., 0., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                    1. / 4.,
                    {
                        use matrix::Matrix;
                        let data_as_nested_array = [[-1., -2., -1.], [0., 0., 0.], [1., 2., 1.]];
                        let rows = data_as_nested_array.len();
                        let cols = data_as_nested_array[0].len();
                        let data_as_flat_array: Vec<_> = data_as_nested_array
                            .into_iter()
                            .flat_map(|row| row.into_iter())
                            .cloned()
                            .collect();
                        Matrix::new(rows, cols, data_as_flat_array)
                    },
                ),
            };
            let kernel_bounds = IRect {
                x0: x as i32 - 1,
                y0: y as i32 - 1,
                x1: x as i32 + 2,
                y1: y as i32 + 2,
            };
            let mut nx = 0.0;
            let mut ny = 0.0;
            for (x, y, pixel) in PixelRectangle::new(surface, bounds, kernel_bounds, EdgeMode::None)
            {
                let kernel_x = (x - kernel_bounds.x0) as usize;
                let kernel_y = (y - kernel_bounds.y0) as usize;
                let alpha = f64::from(pixel.a) / 255.0;
                nx += alpha * kx[[kernel_y, kernel_x]];
                ny += alpha * ky[[kernel_y, kernel_x]];
            }
            nx *= factor_x * surface_scale;
            ny *= factor_y * surface_scale;
            let mut n = {
                use vector::Vector;
                Vector::new(<[_]>::into_vec(box [-nx, -ny, 1.0]))
            };
            normalize(&mut n).unwrap();
            n
        }
    }
    pub mod merge {
        use super::context::{FilterContext, FilterOutput, FilterResult, IRect};
        use super::input::Input;
        use super::{Filter, FilterError, Primitive};
        use attributes::Attribute;
        use cairo::{self, ImageSurface};
        use drawing_ctx::DrawingCtx;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, NodeType, RsvgCNodeImpl, RsvgNode};
        use property_bag::PropertyBag;
        use std::cell::RefCell;
        use surface_utils::shared_surface::SharedImageSurface;
        /// The `feMerge` filter primitive.
        pub struct Merge {
            base: Primitive,
        }
        /// The `<feMergeNode>` element.
        pub struct MergeNode {
            in_: RefCell<Option<Input>>,
        }
        impl Merge {
            /// Constructs a new `Merge` with empty properties.
            #[inline]
            pub fn new() -> Merge {
                Merge {
                    base: Primitive::new::<Self>(),
                }
            }
        }
        impl MergeNode {
            /// Constructs a new `MergeNode` with empty properties.
            #[inline]
            pub fn new() -> MergeNode {
                MergeNode {
                    in_: RefCell::new(None),
                }
            }
        }
        impl NodeTrait for Merge {
            #[inline]
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl NodeTrait for MergeNode {
            #[inline]
            fn set_atts(
                &self,
                _node: &RsvgNode,
                _handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::In => {
                            self.in_.replace(Some(Input::parse(Attribute::In, value)?));
                        }
                        _ => (),
                    }
                }
                Ok(())
            }
        }
        impl MergeNode {
            fn render(
                &self,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
                bounds: IRect,
                output_surface: Option<ImageSurface>,
            ) -> Result<ImageSurface, FilterError> {
                let input = ctx.get_input(draw_ctx, self.in_.borrow().as_ref())?;
                if output_surface.is_none() {
                    return input
                        .surface()
                        .copy_surface(bounds)
                        .map_err(FilterError::IntermediateSurfaceCreation);
                }
                let output_surface = output_surface.unwrap();
                let cr = cairo::Context::new(&output_surface);
                cr.rectangle(
                    bounds.x0 as f64,
                    bounds.y0 as f64,
                    (bounds.x1 - bounds.x0) as f64,
                    (bounds.y1 - bounds.y0) as f64,
                );
                cr.clip();
                input.surface().set_as_source_surface(&cr, 0f64, 0f64);
                cr.set_operator(cairo::Operator::Over);
                cr.paint();
                Ok(output_surface)
            }
        }
        impl Filter for Merge {
            fn render(
                &self,
                node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let mut bounds = self.base.get_bounds(ctx);
                for child in node
                    .children()
                    .filter(|c| c.get_type() == NodeType::FilterPrimitiveMergeNode)
                {
                    bounds = bounds.add_input(&child.with_impl(|c: &MergeNode| {
                        ctx.get_input(draw_ctx, c.in_.borrow().as_ref())
                    })?);
                }
                let bounds = bounds.into_irect(draw_ctx);
                let mut output_surface = None;
                for child in node
                    .children()
                    .filter(|c| c.get_type() == NodeType::FilterPrimitiveMergeNode)
                {
                    output_surface = Some(child.with_impl(|c: &MergeNode| {
                        c.render(ctx, draw_ctx, bounds, output_surface)
                    })?);
                }
                let output_surface = match output_surface {
                    Some(surface) => surface,
                    None => ImageSurface::create(
                        cairo::Format::ARgb32,
                        ctx.source_graphic().width(),
                        ctx.source_graphic().height(),
                    ).map_err(FilterError::IntermediateSurfaceCreation)?,
                };
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
    }
    pub mod morphology {
        use super::context::{FilterContext, FilterOutput, FilterResult, IRect};
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::{self, ImageSurface, MatrixTrait};
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::{self, ParseError};
        use property_bag::PropertyBag;
        use std::cell::Cell;
        use std::cmp::{max, min};
        use surface_utils::{
            iterators::{PixelRectangle, Pixels},
            shared_surface::SharedImageSurface,
            EdgeMode, ImageSurfaceDataExt, Pixel,
        };
        /// Enumeration of the possible morphology operations.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum Operator {
            Erode,
            Dilate,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for Operator {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&Operator::Erode,) => {
                        let mut debug_trait_builder = f.debug_tuple("Erode");
                        debug_trait_builder.finish()
                    }
                    (&Operator::Dilate,) => {
                        let mut debug_trait_builder = f.debug_tuple("Dilate");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for Operator {
            #[inline]
            fn clone(&self) -> Operator {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for Operator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for Operator {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for Operator {
            #[inline]
            fn eq(&self, other: &Operator) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::hash::Hash for Operator {
            fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    _ => ::std::hash::Hash::hash(
                        &unsafe { ::std::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        /// The `feMorphology` filter primitive.
        pub struct Morphology {
            base: PrimitiveWithInput,
            operator: Cell<Operator>,
            radius: Cell<(f64, f64)>,
        }
        impl Morphology {
            /// Constructs a new `Morphology` with empty properties.
            #[inline]
            pub fn new() -> Morphology {
                Morphology {
                    base: PrimitiveWithInput::new::<Self>(),
                    operator: Cell::new(Operator::Erode),
                    radius: Cell::new((0.0, 0.0)),
                }
            }
        }
        impl NodeTrait for Morphology {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::Operator => self.operator.set(Operator::parse(attr, value)?),
                        Attribute::Radius => self.radius.set(
                            parsers::number_optional_number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|(x, y)| {
                                    if x >= 0.0 && y >= 0.0 {
                                        Ok((x, y))
                                    } else {
                                        Err(NodeError::value_error(
                                            attr,
                                            "radius cannot be negative",
                                        ))
                                    }
                                })?,
                        ),
                        _ => (),
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for Morphology {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .into_irect(draw_ctx);
                let (rx, ry) = self.radius.get();
                let (rx, ry) = ctx.paffine().transform_distance(rx, ry);
                let operator = self.operator.get();
                let mut output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let output_stride = output_surface.get_stride() as usize;
                {
                    let mut output_data = output_surface.get_data().unwrap();
                    for (x, y, _pixel) in Pixels::new(input.surface(), bounds) {
                        let kernel_bounds = IRect {
                            x0: (f64::from(x) - rx).floor() as i32,
                            y0: (f64::from(y) - ry).floor() as i32,
                            x1: (f64::from(x) + rx).ceil() as i32 + 1,
                            y1: (f64::from(y) + ry).ceil() as i32 + 1,
                        };
                        let initial = match operator {
                            Operator::Erode => u8::max_value(),
                            Operator::Dilate => u8::min_value(),
                        };
                        let mut output_pixel = Pixel {
                            r: initial,
                            g: initial,
                            b: initial,
                            a: initial,
                        };
                        for (_x, _y, pixel) in PixelRectangle::new(
                            &input.surface(),
                            bounds,
                            kernel_bounds,
                            EdgeMode::None,
                        ) {
                            let op = match operator {
                                Operator::Erode => min,
                                Operator::Dilate => max,
                            };
                            output_pixel.r = op(output_pixel.r, pixel.r);
                            output_pixel.g = op(output_pixel.g, pixel.g);
                            output_pixel.b = op(output_pixel.b, pixel.b);
                            output_pixel.a = op(output_pixel.a, pixel.a);
                        }
                        output_data.set_pixel(output_stride, output_pixel, x, y);
                    }
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                false
            }
        }
        impl Operator {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "erode" => Ok(Operator::Erode),
                    "dilate" => Ok(Operator::Dilate),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
    }
    pub mod offset {
        use super::context::{FilterContext, FilterOutput, FilterResult, IRect};
        use super::{Filter, FilterError, PrimitiveWithInput};
        use attributes::Attribute;
        use cairo::{self, ImageSurface, MatrixTrait};
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers;
        use property_bag::PropertyBag;
        use std::cell::Cell;
        use surface_utils::shared_surface::SharedImageSurface;
        use util::clamp;
        /// The `feOffset` filter primitive.
        pub struct Offset {
            base: PrimitiveWithInput,
            dx: Cell<f64>,
            dy: Cell<f64>,
        }
        impl Offset {
            /// Constructs a new `Offset` with empty properties.
            #[inline]
            pub fn new() -> Offset {
                Offset {
                    base: PrimitiveWithInput::new::<Self>(),
                    dx: Cell::new(0f64),
                    dy: Cell::new(0f64),
                }
            }
        }
        impl NodeTrait for Offset {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::Dx => self.dx.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::Dy => self.dy.set(
                            parsers::number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        _ => (),
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for Offset {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let bounds = self
                    .base
                    .get_bounds(ctx)
                    .add_input(&input)
                    .into_irect(draw_ctx);
                let dx = self.dx.get();
                let dy = self.dy.get();
                let (ox, oy) = ctx.paffine().transform_distance(dx, dy);
                let output_bounds = IRect {
                    x0: clamp(bounds.x0 + ox as i32, bounds.x0, bounds.x1),
                    y0: clamp(bounds.y0 + oy as i32, bounds.y0, bounds.y1),
                    x1: clamp(bounds.x1 + ox as i32, bounds.x0, bounds.x1),
                    y1: clamp(bounds.y1 + oy as i32, bounds.y0, bounds.y1),
                };
                let output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                {
                    let cr = cairo::Context::new(&output_surface);
                    cr.rectangle(
                        output_bounds.x0 as f64,
                        output_bounds.y0 as f64,
                        (output_bounds.x1 - output_bounds.x0) as f64,
                        (output_bounds.y1 - output_bounds.y0) as f64,
                    );
                    cr.clip();
                    input.surface().set_as_source_surface(&cr, ox, oy);
                    cr.paint();
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                false
            }
        }
    }
    pub mod tile {
        use super::context::{FilterContext, FilterInput, FilterOutput, FilterResult};
        use super::{Filter, FilterError, PrimitiveWithInput};
        use cairo::{self, ImageSurface, Matrix, MatrixTrait, Pattern};
        use drawing_ctx::DrawingCtx;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use property_bag::PropertyBag;
        use surface_utils::shared_surface::SharedImageSurface;
        /// The `feTile` filter primitive.
        pub struct Tile {
            base: PrimitiveWithInput,
        }
        impl Tile {
            /// Constructs a new `Tile` with empty properties.
            #[inline]
            pub fn new() -> Tile {
                Tile {
                    base: PrimitiveWithInput::new::<Self>(),
                }
            }
        }
        impl NodeTrait for Tile {
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        impl Filter for Tile {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let input = self.base.get_input(ctx, draw_ctx)?;
                let bounds = self.base.get_bounds(ctx).into_irect(draw_ctx);
                let output_surface = match input {
                    FilterInput::StandardInput(surface) => surface,
                    FilterInput::PrimitiveOutput(FilterOutput {
                        surface,
                        bounds: input_bounds,
                    }) => {
                        let bounded_input_surface =
                            ImageSurface::create(
                                cairo::Format::ARgb32,
                                input_bounds.x1 - input_bounds.x0,
                                input_bounds.y1 - input_bounds.y0,
                            ).map_err(FilterError::IntermediateSurfaceCreation)?;
                        {
                            let cr = cairo::Context::new(&bounded_input_surface);
                            surface.set_as_source_surface(
                                &cr,
                                f64::from(-input_bounds.x0),
                                f64::from(-input_bounds.y0),
                            );
                            cr.paint();
                        }
                        let ptn = cairo::SurfacePattern::create(&bounded_input_surface);
                        ptn.set_extend(cairo::Extend::Repeat);
                        let mut mat = Matrix::identity();
                        mat.translate(f64::from(-input_bounds.x0), f64::from(-input_bounds.y0));
                        ptn.set_matrix(mat);
                        let output_surface = ImageSurface::create(
                            cairo::Format::ARgb32,
                            ctx.source_graphic().width(),
                            ctx.source_graphic().height(),
                        ).map_err(FilterError::IntermediateSurfaceCreation)?;
                        {
                            let cr = cairo::Context::new(&output_surface);
                            cr.rectangle(
                                bounds.x0 as f64,
                                bounds.y0 as f64,
                                (bounds.x1 - bounds.x0) as f64,
                                (bounds.y1 - bounds.y0) as f64,
                            );
                            cr.clip();
                            cr.set_source(&ptn);
                            cr.paint();
                        }
                        SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?
                    }
                };
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: output_surface,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                false
            }
        }
    }
    pub mod turbulence {
        use super::context::{FilterContext, FilterOutput, FilterResult};
        use super::{Filter, FilterError, Primitive};
        use attributes::Attribute;
        use cairo::{self, ImageSurface, MatrixTrait};
        use drawing_ctx::DrawingCtx;
        use error::NodeError;
        use handle::RsvgHandle;
        use node::{NodeResult, NodeTrait, RsvgCNodeImpl, RsvgNode};
        use parsers::{self, ParseError};
        use property_bag::PropertyBag;
        use std::cell::Cell;
        use surface_utils::{shared_surface::SharedImageSurface, ImageSurfaceDataExt, Pixel};
        use util::clamp;
        /// Enumeration of the tile stitching modes.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum StitchTiles {
            Stitch,
            NoStitch,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for StitchTiles {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&StitchTiles::Stitch,) => {
                        let mut debug_trait_builder = f.debug_tuple("Stitch");
                        debug_trait_builder.finish()
                    }
                    (&StitchTiles::NoStitch,) => {
                        let mut debug_trait_builder = f.debug_tuple("NoStitch");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for StitchTiles {
            #[inline]
            fn clone(&self) -> StitchTiles {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for StitchTiles {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for StitchTiles {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for StitchTiles {
            #[inline]
            fn eq(&self, other: &StitchTiles) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::hash::Hash for StitchTiles {
            fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    _ => ::std::hash::Hash::hash(
                        &unsafe { ::std::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        /// Enumeration of the noise types.
        #[structural_match]
        #[rustc_copy_clone_marker]
        enum NoiseType {
            FractalNoise,
            Turbulence,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for NoiseType {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match (&*self,) {
                    (&NoiseType::FractalNoise,) => {
                        let mut debug_trait_builder = f.debug_tuple("FractalNoise");
                        debug_trait_builder.finish()
                    }
                    (&NoiseType::Turbulence,) => {
                        let mut debug_trait_builder = f.debug_tuple("Turbulence");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for NoiseType {
            #[inline]
            fn clone(&self) -> NoiseType {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for NoiseType {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::Eq for NoiseType {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::cmp::PartialEq for NoiseType {
            #[inline]
            fn eq(&self, other: &NoiseType) -> bool {
                {
                    let __self_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                    let __arg_1_vi =
                        unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                    if true && __self_vi == __arg_1_vi {
                        match (&*self, &*other) {
                            _ => true,
                        }
                    } else {
                        false
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::hash::Hash for NoiseType {
            fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
                match (&*self,) {
                    _ => ::std::hash::Hash::hash(
                        &unsafe { ::std::intrinsics::discriminant_value(self) },
                        state,
                    ),
                }
            }
        }
        /// The `feTurbulence` filter primitive.
        pub struct Turbulence {
            base: Primitive,
            base_frequency: Cell<(f64, f64)>,
            num_octaves: Cell<i32>,
            seed: Cell<i32>,
            stitch_tiles: Cell<StitchTiles>,
            type_: Cell<NoiseType>,
        }
        impl Turbulence {
            /// Constructs a new `Turbulence` with empty properties.
            #[inline]
            pub fn new() -> Turbulence {
                Turbulence {
                    base: Primitive::new::<Self>(),
                    base_frequency: Cell::new((0.0, 0.0)),
                    num_octaves: Cell::new(1),
                    seed: Cell::new(0),
                    stitch_tiles: Cell::new(StitchTiles::NoStitch),
                    type_: Cell::new(NoiseType::Turbulence),
                }
            }
        }
        impl NodeTrait for Turbulence {
            #[inline]
            fn set_atts(
                &self,
                node: &RsvgNode,
                handle: *const RsvgHandle,
                pbag: &PropertyBag,
            ) -> NodeResult {
                self.base.set_atts(node, handle, pbag)?;
                for (_key, attr, value) in pbag.iter() {
                    match attr {
                        Attribute::BaseFrequency => self.base_frequency.set(
                            parsers::number_optional_number(value)
                                .map_err(|err| NodeError::parse_error(attr, err))
                                .and_then(|(x, y)| {
                                    if x >= 0.0 && y >= 0.0 {
                                        Ok((x, y))
                                    } else {
                                        Err(NodeError::value_error(
                                            attr,
                                            "values can\'t be negative",
                                        ))
                                    }
                                })?,
                        ),
                        Attribute::NumOctaves => self.num_octaves.set(
                            parsers::integer(value)
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::Seed => self.seed.set(
                            parsers::number(value)
                                .map(|x| {
                                    clamp(
                                        x.trunc(),
                                        f64::from(i32::min_value()),
                                        f64::from(i32::max_value()),
                                    ) as i32
                                })
                                .map_err(|err| NodeError::parse_error(attr, err))?,
                        ),
                        Attribute::StitchTiles => {
                            self.stitch_tiles.set(StitchTiles::parse(attr, value)?)
                        }
                        Attribute::Type => self.type_.set(NoiseType::parse(attr, value)?),
                        _ => (),
                    }
                }
                Ok(())
            }
            #[inline]
            fn get_c_impl(&self) -> *const RsvgCNodeImpl {
                self.base.get_c_impl()
            }
        }
        const RAND_M: i32 = 2147483647;
        const RAND_A: i32 = 16807;
        const RAND_Q: i32 = 127773;
        const RAND_R: i32 = 2836;
        fn setup_seed(mut seed: i32) -> i32 {
            if seed <= 0 {
                seed = -(seed % (RAND_M - 1)) + 1;
            }
            if seed > RAND_M - 1 {
                seed = RAND_M - 1;
            }
            seed
        }
        fn random(seed: i32) -> i32 {
            let mut result = RAND_A * (seed % RAND_Q) - RAND_R * (seed / RAND_Q);
            if result <= 0 {
                result += RAND_M;
            }
            result
        }
        const B_SIZE: usize = 256;
        const PERLIN_N: i32 = 4096;
        #[rustc_copy_clone_marker]
        struct NoiseGenerator {
            base_frequency: (f64, f64),
            num_octaves: i32,
            stitch_tiles: StitchTiles,
            type_: NoiseType,
            tile_width: f64,
            tile_height: f64,
            lattice_selector: [usize; B_SIZE + B_SIZE + 2],
            gradient: [[[f64; 2]; B_SIZE + B_SIZE + 2]; 4],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for NoiseGenerator {
            #[inline]
            fn clone(&self) -> NoiseGenerator {
                {
                    let _: ::std::clone::AssertParamIsClone<(f64, f64)>;
                    let _: ::std::clone::AssertParamIsClone<i32>;
                    let _: ::std::clone::AssertParamIsClone<StitchTiles>;
                    let _: ::std::clone::AssertParamIsClone<NoiseType>;
                    let _: ::std::clone::AssertParamIsClone<f64>;
                    let _: ::std::clone::AssertParamIsClone<f64>;
                    let _: ::std::clone::AssertParamIsClone<
                        [usize; B_SIZE + B_SIZE + 2],
                    >;
                    let _: ::std::clone::AssertParamIsClone<
                        [[[f64; 2]; B_SIZE + B_SIZE + 2]; 4],
                    >;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for NoiseGenerator {}
        #[rustc_copy_clone_marker]
        struct StitchInfo {
            width: usize,
            height: usize,
            wrap_x: usize,
            wrap_y: usize,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for StitchInfo {
            #[inline]
            fn clone(&self) -> StitchInfo {
                {
                    let _: ::std::clone::AssertParamIsClone<usize>;
                    let _: ::std::clone::AssertParamIsClone<usize>;
                    let _: ::std::clone::AssertParamIsClone<usize>;
                    let _: ::std::clone::AssertParamIsClone<usize>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::marker::Copy for StitchInfo {}
        impl NoiseGenerator {
            fn new(
                seed: i32,
                base_frequency: (f64, f64),
                num_octaves: i32,
                type_: NoiseType,
                stitch_tiles: StitchTiles,
                tile_width: f64,
                tile_height: f64,
            ) -> Self {
                let mut rv = Self {
                    base_frequency,
                    num_octaves,
                    type_,
                    stitch_tiles,
                    tile_width,
                    tile_height,
                    lattice_selector: [0; B_SIZE + B_SIZE + 2],
                    gradient: [[[0.0; 2]; B_SIZE + B_SIZE + 2]; 4],
                };
                let mut seed = setup_seed(seed);
                for k in 0..4 {
                    for i in 0..B_SIZE {
                        rv.lattice_selector[i] = i;
                        for j in 0..2 {
                            seed = random(seed);
                            rv.gradient[k][i][j] =
                                ((seed % (B_SIZE + B_SIZE) as i32) - B_SIZE as i32) as f64
                                    / B_SIZE as f64;
                        }
                        let s = (rv.gradient[k][i][0] * rv.gradient[k][i][0]
                            + rv.gradient[k][i][1] * rv.gradient[k][i][1])
                            .sqrt();
                        rv.gradient[k][i][0] /= s;
                        rv.gradient[k][i][1] /= s;
                    }
                }
                for i in (1..B_SIZE).rev() {
                    let k = rv.lattice_selector[i];
                    seed = random(seed);
                    let j = seed as usize % B_SIZE;
                    rv.lattice_selector[i] = rv.lattice_selector[j];
                    rv.lattice_selector[j] = k;
                }
                for i in 0..B_SIZE + 2 {
                    rv.lattice_selector[B_SIZE + i] = rv.lattice_selector[i];
                    for k in 0..4 {
                        for j in 0..2 {
                            rv.gradient[k][B_SIZE + i][j] = rv.gradient[k][i][j];
                        }
                    }
                }
                rv
            }
            fn noise2(
                self,
                color_channel: usize,
                vec: [f64; 2],
                stitch_info: Option<StitchInfo>,
            ) -> f64 {
                const BM: usize = 255;
                let s_curve = |t| t * t * (3. - 2. * t);
                let lerp = |t, a, b| a + t * (b - a);
                let t = vec[0] + f64::from(PERLIN_N);
                let mut bx0 = t as usize;
                let mut bx1 = bx0 + 1;
                let rx0 = t.fract();
                let rx1 = rx0 - 1.0;
                let t = vec[1] + f64::from(PERLIN_N);
                let mut by0 = t as usize;
                let mut by1 = by0 + 1;
                let ry0 = t.fract();
                let ry1 = ry0 - 1.0;
                if let Some(stitch_info) = stitch_info {
                    if bx0 >= stitch_info.wrap_x {
                        bx0 -= stitch_info.width;
                    }
                    if bx1 >= stitch_info.wrap_x {
                        bx1 -= stitch_info.width;
                    }
                    if by0 >= stitch_info.wrap_y {
                        by0 -= stitch_info.height;
                    }
                    if by1 >= stitch_info.wrap_y {
                        by1 -= stitch_info.height;
                    }
                }
                bx0 &= BM;
                bx1 &= BM;
                by0 &= BM;
                by1 &= BM;
                let i = self.lattice_selector[bx0];
                let j = self.lattice_selector[bx1];
                let b00 = self.lattice_selector[i + by0];
                let b10 = self.lattice_selector[j + by0];
                let b01 = self.lattice_selector[i + by1];
                let b11 = self.lattice_selector[j + by1];
                let sx = f64::from(s_curve(rx0));
                let sy = f64::from(s_curve(ry0));
                let q = self.gradient[color_channel][b00];
                let u = rx0 * q[0] + ry0 * q[1];
                let q = self.gradient[color_channel][b10];
                let v = rx1 * q[0] + ry0 * q[1];
                let a = lerp(sx, u, v);
                let q = self.gradient[color_channel][b01];
                let u = rx0 * q[0] + ry1 * q[1];
                let q = self.gradient[color_channel][b11];
                let v = rx1 * q[0] + ry1 * q[1];
                let b = lerp(sx, u, v);
                lerp(sy, a, b)
            }
            fn turbulence(
                self,
                color_channel: usize,
                point: [f64; 2],
                tile_x: f64,
                tile_y: f64,
            ) -> f64 {
                let mut stitch_info = None;
                let mut base_frequency = self.base_frequency;
                if self.stitch_tiles == StitchTiles::Stitch {
                    if base_frequency.0 != 0.0 {
                        let freq_lo =
                            (self.tile_width * base_frequency.0).floor() / self.tile_width;
                        let freq_hi = (self.tile_width * base_frequency.0).ceil() / self.tile_width;
                        if base_frequency.0 / freq_lo < freq_hi / base_frequency.0 {
                            base_frequency.0 = freq_lo;
                        } else {
                            base_frequency.0 = freq_hi;
                        }
                    }
                    if base_frequency.1 != 0.0 {
                        let freq_lo =
                            (self.tile_height * base_frequency.1).floor() / self.tile_height;
                        let freq_hi =
                            (self.tile_height * base_frequency.1).ceil() / self.tile_height;
                        if base_frequency.1 / freq_lo < freq_hi / base_frequency.1 {
                            base_frequency.1 = freq_lo;
                        } else {
                            base_frequency.1 = freq_hi;
                        }
                    }
                    let width = (self.tile_width * base_frequency.0 + 0.5) as usize;
                    let height = (self.tile_height * base_frequency.1 + 0.5) as usize;
                    stitch_info = Some(StitchInfo {
                        width,
                        wrap_x: (tile_x * base_frequency.0) as usize + PERLIN_N as usize + width,
                        height,
                        wrap_y: (tile_y * base_frequency.1) as usize + PERLIN_N as usize + height,
                    });
                }
                let mut sum = 0.0;
                let mut vec = [point[0] * base_frequency.0, point[1] * base_frequency.1];
                let mut ratio = 1.0;
                for _ in 0..self.num_octaves {
                    if self.type_ == NoiseType::FractalNoise {
                        sum += self.noise2(color_channel, vec, stitch_info) / ratio;
                    } else {
                        sum += (self.noise2(color_channel, vec, stitch_info)).abs() / ratio;
                    }
                    vec[0] *= 2.0;
                    vec[1] *= 2.0;
                    ratio *= 2.0;
                    if let Some(stitch_info) = stitch_info.as_mut() {
                        stitch_info.width *= 2;
                        stitch_info.wrap_x = 2 * stitch_info.wrap_x - PERLIN_N as usize;
                        stitch_info.height *= 2;
                        stitch_info.wrap_y = 2 * stitch_info.wrap_y - PERLIN_N as usize;
                    }
                }
                sum
            }
        }
        impl Filter for Turbulence {
            fn render(
                &self,
                _node: &RsvgNode,
                ctx: &FilterContext,
                draw_ctx: &mut DrawingCtx,
            ) -> Result<FilterResult, FilterError> {
                let bounds = self.base.get_bounds(ctx).into_irect(draw_ctx);
                let mut affine = ctx.paffine();
                affine.invert();
                let type_ = self.type_.get();
                let noise_generator = NoiseGenerator::new(
                    self.seed.get(),
                    self.base_frequency.get(),
                    self.num_octaves.get(),
                    type_,
                    self.stitch_tiles.get(),
                    f64::from(bounds.x1 - bounds.x0),
                    f64::from(bounds.y1 - bounds.y0),
                );
                let mut output_surface = ImageSurface::create(
                    cairo::Format::ARgb32,
                    ctx.source_graphic().width(),
                    ctx.source_graphic().height(),
                ).map_err(FilterError::IntermediateSurfaceCreation)?;
                let output_stride = output_surface.get_stride() as usize;
                {
                    let mut output_data = output_surface.get_data().unwrap();
                    for y in bounds.y0..bounds.y1 {
                        for x in bounds.x0..bounds.x1 {
                            let point = affine.transform_point(f64::from(x), f64::from(y));
                            let point = [point.0, point.1];
                            let generate = |color_channel| {
                                let v = noise_generator.turbulence(
                                    color_channel,
                                    point,
                                    f64::from(x - bounds.x0),
                                    f64::from(y - bounds.y0),
                                );
                                let v = match type_ {
                                    NoiseType::FractalNoise => (v * 255.0 + 255.0) / 2.0,
                                    NoiseType::Turbulence => v * 255.0,
                                };
                                clamp(v, 0.0, 255.0).round() as u8
                            };
                            let pixel = Pixel {
                                r: generate(0),
                                g: generate(1),
                                b: generate(2),
                                a: generate(3),
                            }.premultiply();
                            output_data.set_pixel(output_stride, pixel, x as u32, y as u32);
                        }
                    }
                }
                Ok(FilterResult {
                    name: self.base.result.borrow().clone(),
                    output: FilterOutput {
                        surface: SharedImageSurface::new(output_surface)
                            .map_err(FilterError::BadIntermediateSurfaceStatus)?,
                        bounds,
                    },
                })
            }
            #[inline]
            fn is_affected_by_color_interpolation_filters() -> bool {
                true
            }
        }
        impl StitchTiles {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "stitch" => Ok(StitchTiles::Stitch),
                    "noStitch" => Ok(StitchTiles::NoStitch),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
        impl NoiseType {
            fn parse(attr: Attribute, s: &str) -> Result<Self, NodeError> {
                match s {
                    "fractalNoise" => Ok(NoiseType::FractalNoise),
                    "turbulence" => Ok(NoiseType::Turbulence),
                    _ => Err(NodeError::parse_error(
                        attr,
                        ParseError::new("invalid value"),
                    )),
                }
            }
        }
    }
    /// A filter primitive interface.
    trait Filter: NodeTrait {
        /// Renders this filter primitive.
        ///
        /// If this filter primitive can't be rendered for whatever reason (for instance, a required
        /// property hasn't been provided), an error is returned.
        fn render(
            &self,
            node: &RsvgNode,
            ctx: &FilterContext,
            draw_ctx: &mut DrawingCtx,
        ) -> Result<FilterResult, FilterError>;
        /// Returns `true` if this filter primitive is affected by the `color-interpolation-filters`
        /// property.
        ///
        /// Primitives that do color blending (like `feComposite` or `feBlend`) should return `true`
        /// here, whereas primitives that don't (like `feOffset`) should return `false`.
        fn is_affected_by_color_interpolation_filters() -> bool;
    }
    /// The base filter primitive node containing common properties.
    struct Primitive {
        filter_function_pointers: FilterFunctionPointers,
        x: Cell<Option<RsvgLength>>,
        y: Cell<Option<RsvgLength>>,
        width: Cell<Option<RsvgLength>>,
        height: Cell<Option<RsvgLength>>,
        result: RefCell<Option<String>>,
    }
    /// The base node for filter primitives which accept input.
    struct PrimitiveWithInput {
        base: Primitive,
        in_: RefCell<Option<Input>>,
    }
    impl Primitive {
        /// Constructs a new `Primitive` with empty properties.
        #[inline]
        fn new<T: Filter>() -> Primitive {
            Primitive {
                filter_function_pointers: FilterFunctionPointers::new::<T>(),
                x: Cell::new(None),
                y: Cell::new(None),
                width: Cell::new(None),
                height: Cell::new(None),
                result: RefCell::new(None),
            }
        }
        /// Returns the `BoundsBuilder` for bounds computation.
        #[inline]
        fn get_bounds<'a>(&self, ctx: &'a FilterContext) -> BoundsBuilder<'a> {
            BoundsBuilder::new(
                ctx,
                self.x.get(),
                self.y.get(),
                self.width.get(),
                self.height.get(),
            )
        }
    }
    impl NodeTrait for Primitive {
        fn set_atts(
            &self,
            node: &RsvgNode,
            _: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            let primitiveunits = node
                .get_parent()
                .and_then(|parent| {
                    if parent.get_type() == NodeType::Filter {
                        Some(parent.with_impl(|f: &NodeFilter| f.primitiveunits.get()))
                    } else {
                        None
                    }
                })
                .unwrap_or(CoordUnits::UserSpaceOnUse);
            let no_units_allowed = primitiveunits == CoordUnits::ObjectBoundingBox;
            let check_units = |length: RsvgLength| {
                if !no_units_allowed {
                    return Ok(length);
                }
                match length.unit {
                            LengthUnit::Default | LengthUnit::Percent =>
                            Ok(length),
                            _ =>
                            Err(AttributeError::Parse(ParseError::new("unit identifiers are not allowed with primitiveUnits set to objectBoundingBox"))),
                        }
            };
            let check_units_and_ensure_nonnegative =
                |length: RsvgLength| check_units(length).and_then(RsvgLength::check_nonnegative);
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::X => self.x.set(Some(parse_and_validate(
                        "x",
                        value,
                        LengthDir::Horizontal,
                        check_units,
                    )?)),
                    Attribute::Y => self.y.set(Some(parse_and_validate(
                        "y",
                        value,
                        LengthDir::Vertical,
                        check_units,
                    )?)),
                    Attribute::Width => self.width.set(Some(parse_and_validate(
                        "width",
                        value,
                        LengthDir::Horizontal,
                        check_units_and_ensure_nonnegative,
                    )?)),
                    Attribute::Height => self.height.set(Some(parse_and_validate(
                        "height",
                        value,
                        LengthDir::Vertical,
                        check_units_and_ensure_nonnegative,
                    )?)),
                    Attribute::Result => *self.result.borrow_mut() = Some(value.to_string()),
                    _ => (),
                }
            }
            Ok(())
        }
        #[inline]
        fn get_c_impl(&self) -> *const RsvgCNodeImpl {
            &self.filter_function_pointers as *const FilterFunctionPointers as *const RsvgCNodeImpl
        }
    }
    impl PrimitiveWithInput {
        /// Constructs a new `PrimitiveWithInput` with empty properties.
        #[inline]
        fn new<T: Filter>() -> PrimitiveWithInput {
            PrimitiveWithInput {
                base: Primitive::new::<T>(),
                in_: RefCell::new(None),
            }
        }
        /// Returns the input Cairo surface for this filter primitive.
        #[inline]
        fn get_input(
            &self,
            ctx: &FilterContext,
            draw_ctx: &mut DrawingCtx,
        ) -> Result<FilterInput, FilterError> {
            ctx.get_input(draw_ctx, self.in_.borrow().as_ref())
        }
    }
    impl NodeTrait for PrimitiveWithInput {
        fn set_atts(
            &self,
            node: &RsvgNode,
            handle: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            self.base.set_atts(node, handle, pbag)?;
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::In => {
                        drop(self.in_.replace(Some(Input::parse(Attribute::In, value)?)))
                    }
                    _ => (),
                }
            }
            Ok(())
        }
        #[inline]
        fn get_c_impl(&self) -> *const RsvgCNodeImpl {
            self.base.get_c_impl()
        }
    }
    impl Deref for PrimitiveWithInput {
        type Target = Primitive;
        #[inline]
        fn deref(&self) -> &Self::Target {
            &self.base
        }
    }
}
mod gradient {
    use attributes::Attribute;
    use bbox::*;
    use cairo::{self, MatrixTrait};
    use coord_units::CoordUnits;
    use cssparser::{self, CowRcStr, Parser, Token};
    use drawing_ctx::{AcquiredNode, DrawingCtx};
    use error::*;
    use handle::RsvgHandle;
    use length::*;
    use node::*;
    use parsers::{parse, Parse, ParseError};
    use property_bag::PropertyBag;
    use rect::RectangleExt;
    use state::{ComputedValues, StopColor};
    use std::cell::RefCell;
    use stop::*;
    use unitinterval::UnitInterval;
    use util::clone_fallback_name;
    #[rustc_copy_clone_marker]
    struct ColorStop {
        pub offset: f64,
        pub rgba: cssparser::RGBA,
        pub opacity: UnitInterval,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ColorStop {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ColorStop {
        #[inline]
        fn clone(&self) -> ColorStop {
            {
                let _: ::std::clone::AssertParamIsClone<f64>;
                let _: ::std::clone::AssertParamIsClone<cssparser::RGBA>;
                let _: ::std::clone::AssertParamIsClone<UnitInterval>;
                *self
            }
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct GradientUnits(pub CoordUnits);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for GradientUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                GradientUnits(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("GradientUnits");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for GradientUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for GradientUnits {
        #[inline]
        fn clone(&self) -> GradientUnits {
            {
                let _: ::std::clone::AssertParamIsClone<CoordUnits>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for GradientUnits {
        #[inline]
        fn eq(&self, other: &GradientUnits) -> bool {
            match *other {
                GradientUnits(ref __self_1_0) => match *self {
                    GradientUnits(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &GradientUnits) -> bool {
            match *other {
                GradientUnits(ref __self_1_0) => match *self {
                    GradientUnits(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for GradientUnits {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<CoordUnits>;
            }
        }
    }
    impl Default for GradientUnits {
        fn default() -> Self {
            GradientUnits(CoordUnits::ObjectBoundingBox)
        }
    }
    impl From<GradientUnits> for CoordUnits {
        fn from(u: GradientUnits) -> Self {
            u.0
        }
    }
    impl ::parsers::Parse for GradientUnits {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(parser: &mut ::cssparser::Parser, _: ()) -> Result<Self, ::error::AttributeError> {
            Ok(GradientUnits(::coord_units::CoordUnits::parse(parser, ())?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum SpreadMethod {
        Pad,
        Reflect,
        Repeat,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for SpreadMethod {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&SpreadMethod::Pad,) => {
                    let mut debug_trait_builder = f.debug_tuple("Pad");
                    debug_trait_builder.finish()
                }
                (&SpreadMethod::Reflect,) => {
                    let mut debug_trait_builder = f.debug_tuple("Reflect");
                    debug_trait_builder.finish()
                }
                (&SpreadMethod::Repeat,) => {
                    let mut debug_trait_builder = f.debug_tuple("Repeat");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for SpreadMethod {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SpreadMethod {
        #[inline]
        fn clone(&self) -> SpreadMethod {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for SpreadMethod {
        #[inline]
        fn eq(&self, other: &SpreadMethod) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Parse for SpreadMethod {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<SpreadMethod, AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "pad" => Ok(SpreadMethod::Pad),
                    "reflect" => Ok(SpreadMethod::Reflect),
                    "repeat" => Ok(SpreadMethod::Repeat),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(Token::Ident(CowRcStr::from(
                            cow.as_ref().to_string(),
                        ))),
                    ),
                })
                .map_err(|_| {
                    AttributeError::Parse(ParseError::new(
                        "expected \'pad\' | \'reflect\' | \'repeat\'",
                    ))
                })
        }
    }
    impl Default for SpreadMethod {
        fn default() -> SpreadMethod {
            SpreadMethod::Pad
        }
    }
    impl From<SpreadMethod> for cairo::enums::Extend {
        fn from(s: SpreadMethod) -> cairo::enums::Extend {
            match s {
                SpreadMethod::Pad => cairo::enums::Extend::Pad,
                SpreadMethod::Reflect => cairo::enums::Extend::Reflect,
                SpreadMethod::Repeat => cairo::enums::Extend::Repeat,
            }
        }
    }
    struct GradientCommon {
        pub units: Option<GradientUnits>,
        pub affine: Option<cairo::Matrix>,
        pub spread: Option<SpreadMethod>,
        pub fallback: Option<String>,
        pub stops: Option<Vec<ColorStop>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for GradientCommon {
        #[inline]
        fn clone(&self) -> GradientCommon {
            match *self {
                GradientCommon {
                    units: ref __self_0_0,
                    affine: ref __self_0_1,
                    spread: ref __self_0_2,
                    fallback: ref __self_0_3,
                    stops: ref __self_0_4,
                } => GradientCommon {
                    units: ::std::clone::Clone::clone(&(*__self_0_0)),
                    affine: ::std::clone::Clone::clone(&(*__self_0_1)),
                    spread: ::std::clone::Clone::clone(&(*__self_0_2)),
                    fallback: ::std::clone::Clone::clone(&(*__self_0_3)),
                    stops: ::std::clone::Clone::clone(&(*__self_0_4)),
                },
            }
        }
    }
    #[rustc_copy_clone_marker]
    enum GradientVariant {
        Linear {
            x1: Option<RsvgLength>,
            y1: Option<RsvgLength>,
            x2: Option<RsvgLength>,
            y2: Option<RsvgLength>,
        },
        Radial {
            cx: Option<RsvgLength>,
            cy: Option<RsvgLength>,
            r: Option<RsvgLength>,
            fx: Option<RsvgLength>,
            fy: Option<RsvgLength>,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for GradientVariant {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for GradientVariant {
        #[inline]
        fn clone(&self) -> GradientVariant {
            {
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                let _: ::std::clone::AssertParamIsClone<Option<RsvgLength>>;
                *self
            }
        }
    }
    struct Gradient {
        pub common: GradientCommon,
        pub variant: GradientVariant,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Gradient {
        #[inline]
        fn clone(&self) -> Gradient {
            match *self {
                Gradient {
                    common: ref __self_0_0,
                    variant: ref __self_0_1,
                } => Gradient {
                    common: ::std::clone::Clone::clone(&(*__self_0_0)),
                    variant: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl Default for GradientCommon {
        fn default() -> GradientCommon {
            GradientCommon {
                units: Some(GradientUnits::default()),
                affine: Some(cairo::Matrix::identity()),
                spread: Some(SpreadMethod::default()),
                fallback: None,
                stops: Some(Vec::<ColorStop>::new()),
            }
        }
    }
    macro_rules! fallback_to(( $ dest : expr , $ default : expr ) => (
                             $ dest = $ dest . take (  ) . or ( $ default ) )
                             ;);
    impl GradientCommon {
        fn unresolved() -> GradientCommon {
            GradientCommon {
                units: None,
                affine: None,
                spread: None,
                fallback: None,
                stops: None,
            }
        }
        fn clone_stops(&self) -> Option<Vec<ColorStop>> {
            if let Some(ref stops) = self.stops {
                Some(stops.clone())
            } else {
                None
            }
        }
        fn is_resolved(&self) -> bool {
            self.units.is_some()
                && self.affine.is_some()
                && self.spread.is_some()
                && self.stops.is_some()
        }
        fn resolve_from_defaults(&mut self) {
            self.resolve_from_fallback(&GradientCommon::default());
        }
        fn resolve_from_fallback(&mut self, fallback: &GradientCommon) {
            self.units = self.units.take().or(fallback.units);
            self.affine = self.affine.take().or(fallback.affine);
            self.spread = self.spread.take().or(fallback.spread);
            self.stops = self.stops.take().or(fallback.clone_stops());
            self.fallback = clone_fallback_name(&fallback.fallback);
        }
        fn add_color_stop(
            &mut self,
            mut offset: f64,
            rgba: cssparser::RGBA,
            opacity: UnitInterval,
        ) {
            if self.stops.is_none() {
                self.stops = Some(Vec::<ColorStop>::new());
            }
            if let Some(ref mut stops) = self.stops {
                let last_offset: f64 = if !stops.is_empty() {
                    stops[stops.len() - 1].offset
                } else {
                    0.0
                };
                if last_offset > offset {
                    offset = last_offset;
                }
                stops.push(ColorStop {
                    offset,
                    rgba,
                    opacity,
                });
            } else {
                {
                    {
                        ::rt::begin_panic(
                            "internal error: entered unreachable code",
                            &("rsvg_internals/src/gradient.rs", 211u32, 13u32),
                        )
                    }
                };
            }
        }
    }
    impl GradientVariant {
        fn unresolved_linear() -> Self {
            GradientVariant::Linear {
                x1: None,
                y1: None,
                x2: None,
                y2: None,
            }
        }
        fn unresolved_radial() -> Self {
            GradientVariant::Radial {
                cx: None,
                cy: None,
                r: None,
                fx: None,
                fy: None,
            }
        }
        fn is_resolved(&self) -> bool {
            match *self {
                GradientVariant::Linear { x1, y1, x2, y2 } => {
                    x1.is_some() && y1.is_some() && x2.is_some() && y2.is_some()
                }
                GradientVariant::Radial { cx, cy, r, fx, fy } => {
                    cx.is_some() && cy.is_some() && r.is_some() && fx.is_some() && fy.is_some()
                }
            }
        }
        fn default_linear() -> Self {
            GradientVariant::Linear {
                x1: Some(RsvgLength::parse_str("0%", LengthDir::Horizontal).unwrap()),
                y1: Some(RsvgLength::parse_str("0%", LengthDir::Vertical).unwrap()),
                x2: Some(RsvgLength::parse_str("100%", LengthDir::Horizontal).unwrap()),
                y2: Some(RsvgLength::parse_str("0%", LengthDir::Vertical).unwrap()),
            }
        }
        fn default_radial() -> Self {
            GradientVariant::Radial {
                cx: Some(RsvgLength::parse_str("50%", LengthDir::Horizontal).unwrap()),
                cy: Some(RsvgLength::parse_str("50%", LengthDir::Vertical).unwrap()),
                r: Some(RsvgLength::parse_str("50%", LengthDir::Both).unwrap()),
                fx: None,
                fy: None,
            }
        }
        fn resolve_from_defaults(&mut self) {
            match *self {
                GradientVariant::Linear { .. } => {
                    self.resolve_from_fallback(&GradientVariant::default_linear())
                }
                GradientVariant::Radial { .. } => {
                    self.resolve_from_fallback(&GradientVariant::default_radial());
                }
            }
            if let GradientVariant::Radial {
                cx,
                cy,
                ref mut fx,
                ref mut fy,
                ..
            } = *self
            {
                *fx = (*fx).take().or(cx);
                *fy = (*fy).take().or(cy);
            }
        }
        fn resolve_from_fallback(&mut self, fallback: &GradientVariant) {
            match *self {
                GradientVariant::Linear {
                    ref mut x1,
                    ref mut y1,
                    ref mut x2,
                    ref mut y2,
                } => {
                    if let GradientVariant::Linear {
                        x1: x1f,
                        y1: y1f,
                        x2: x2f,
                        y2: y2f,
                    } = *fallback
                    {
                        *x1 = (*x1).take().or(x1f);
                        *y1 = (*y1).take().or(y1f);
                        *x2 = (*x2).take().or(x2f);
                        *y2 = (*y2).take().or(y2f);
                    }
                }
                GradientVariant::Radial {
                    ref mut cx,
                    ref mut cy,
                    ref mut r,
                    ref mut fx,
                    ref mut fy,
                } => {
                    if let GradientVariant::Radial {
                        cx: cxf,
                        cy: cyf,
                        r: rf,
                        fx: fxf,
                        fy: fyf,
                    } = *fallback
                    {
                        *cx = (*cx).take().or(cxf);
                        *cy = (*cy).take().or(cyf);
                        *r = (*r).take().or(rf);
                        *fx = (*fx).take().or(fxf);
                        *fy = (*fy).take().or(fyf);
                    }
                }
            }
        }
    }
    impl Gradient {
        fn is_resolved(&self) -> bool {
            self.common.is_resolved() && self.variant.is_resolved()
        }
        fn resolve_from_defaults(&mut self) {
            self.common.resolve_from_defaults();
            self.variant.resolve_from_defaults();
        }
        fn resolve_from_fallback(&mut self, fallback: &Gradient) {
            self.common.resolve_from_fallback(&fallback.common);
            self.variant.resolve_from_fallback(&fallback.variant);
        }
        fn add_color_stops_from_node(&mut self, node: &RsvgNode) {
            if !(node.get_type() == NodeType::LinearGradient
                || node.get_type() == NodeType::RadialGradient)
            {
                {
                    ::rt::begin_panic("assertion failed: node.get_type() == NodeType::LinearGradient ||\n    node.get_type() == NodeType::RadialGradient",
                                      &("rsvg_internals/src/gradient.rs",
                                        362u32, 9u32))
                }
            };
            node.children()
                .into_iter()
                .filter(|child| child.get_type() == NodeType::Stop)
                .take_while(|child| child.get_result().is_ok())
                .for_each(|child| {
                    child.with_impl(|stop: &NodeStop| {
                        let cascaded = child.get_cascaded_values();
                        let values = cascaded.get();
                        let rgba = match values.stop_color {
                            StopColor(cssparser::Color::CurrentColor) => values.color.0,
                            StopColor(cssparser::Color::RGBA(ref rgba)) => *rgba,
                        };
                        self.add_color_stop(stop.get_offset(), rgba, values.stop_opacity.0);
                    })
                });
        }
        fn add_color_stop(&mut self, offset: f64, rgba: cssparser::RGBA, opacity: UnitInterval) {
            self.common.add_color_stop(offset, rgba, opacity);
        }
        fn add_color_stops_to_pattern(
            &self,
            pattern: &mut cairo::Gradient,
            opacity: &UnitInterval,
        ) {
            if let Some(stops) = self.common.stops.as_ref() {
                for stop in stops {
                    let &UnitInterval(o) = opacity;
                    let UnitInterval(stop_opacity) = stop.opacity;
                    pattern.add_color_stop_rgba(
                        stop.offset,
                        f64::from(stop.rgba.red_f32()),
                        f64::from(stop.rgba.green_f32()),
                        f64::from(stop.rgba.blue_f32()),
                        f64::from(stop.rgba.alpha_f32()) * stop_opacity * o,
                    );
                }
            }
        }
    }
    fn acquire_gradient<'a>(draw_ctx: &'a mut DrawingCtx, name: &str) -> Option<AcquiredNode> {
        draw_ctx.get_acquired_node(name).and_then(|acquired| {
            let node = acquired.get();
            if node.get_type() == NodeType::LinearGradient
                || node.get_type() == NodeType::RadialGradient
            {
                Some(acquired)
            } else {
                None
            }
        })
    }
    fn resolve_gradient(gradient: &Gradient, draw_ctx: &mut DrawingCtx) -> Gradient {
        let mut result = gradient.clone();
        while !result.is_resolved() {
            result
                .common
                .fallback
                .as_ref()
                .and_then(|fallback_name| acquire_gradient(draw_ctx, fallback_name))
                .and_then(|acquired| {
                    let fallback_node = acquired.get();
                    fallback_node.with_impl(|i: &NodeGradient| {
                        let fallback_grad =
                            i.get_gradient_with_color_stops_from_node(&fallback_node);
                        result.resolve_from_fallback(&fallback_grad)
                    });
                    Some(())
                })
                .or_else(|| {
                    result.resolve_from_defaults();
                    Some(())
                });
        }
        result
    }
    fn set_common_on_pattern<P: cairo::Pattern + cairo::Gradient>(
        gradient: &Gradient,
        draw_ctx: &mut DrawingCtx,
        pattern: &mut P,
        bbox: &BoundingBox,
        opacity: &UnitInterval,
    ) {
        let cr = draw_ctx.get_cairo_context();
        let mut affine = gradient.common.affine.unwrap();
        let units = gradient.common.units.unwrap();
        if units == GradientUnits(CoordUnits::ObjectBoundingBox) {
            let bbox_rect = bbox.rect.unwrap();
            let bbox_matrix = cairo::Matrix::new(
                bbox_rect.width,
                0.0,
                0.0,
                bbox_rect.height,
                bbox_rect.x,
                bbox_rect.y,
            );
            affine = cairo::Matrix::multiply(&affine, &bbox_matrix);
        }
        affine.invert();
        pattern.set_matrix(affine);
        pattern.set_extend(cairo::enums::Extend::from(
            gradient.common.spread.unwrap_or_default(),
        ));
        gradient.add_color_stops_to_pattern(pattern, opacity);
        cr.set_source(pattern);
    }
    fn set_linear_gradient_on_pattern(
        gradient: &Gradient,
        values: &ComputedValues,
        draw_ctx: &mut DrawingCtx,
        bbox: &BoundingBox,
        opacity: &UnitInterval,
    ) -> bool {
        if let GradientVariant::Linear { x1, y1, x2, y2 } = gradient.variant {
            let units = gradient.common.units.unwrap();
            if units == GradientUnits(CoordUnits::ObjectBoundingBox) {
                draw_ctx.push_view_box(1.0, 1.0);
            }
            let mut pattern = cairo::LinearGradient::new(
                x1.as_ref().unwrap().normalize(values, draw_ctx),
                y1.as_ref().unwrap().normalize(values, draw_ctx),
                x2.as_ref().unwrap().normalize(values, draw_ctx),
                y2.as_ref().unwrap().normalize(values, draw_ctx),
            );
            if units == GradientUnits(CoordUnits::ObjectBoundingBox) {
                draw_ctx.pop_view_box();
            }
            set_common_on_pattern(gradient, draw_ctx, &mut pattern, bbox, opacity);
        } else {
            {
                {
                    ::rt::begin_panic(
                        "internal error: entered unreachable code",
                        &("rsvg_internals/src/gradient.rs", 514u32, 9u32),
                    )
                }
            };
        }
        true
    }
    fn fix_focus_point(mut fx: f64, mut fy: f64, cx: f64, cy: f64, radius: f64) -> (f64, f64) {
        if (fx - cx) * (fx - cx) + (fy - cy) * (fy - cy) <= radius * radius {
            return (fx, fy);
        }
        fx -= cx;
        fy -= cy;
        let mut vx = fx;
        let mut vy = fy;
        let mag = (vx * vx + vy * vy).sqrt();
        let scale = mag / radius;
        vx /= scale;
        vy /= scale;
        (vx + cx, vy + cy)
    }
    fn set_radial_gradient_on_pattern(
        gradient: &Gradient,
        values: &ComputedValues,
        draw_ctx: &mut DrawingCtx,
        bbox: &BoundingBox,
        opacity: &UnitInterval,
    ) -> bool {
        if let GradientVariant::Radial { cx, cy, r, fx, fy } = gradient.variant {
            let units = gradient.common.units.unwrap();
            if units == GradientUnits(CoordUnits::ObjectBoundingBox) {
                draw_ctx.push_view_box(1.0, 1.0);
            }
            let n_cx = cx.as_ref().unwrap().normalize(values, draw_ctx);
            let n_cy = cy.as_ref().unwrap().normalize(values, draw_ctx);
            let n_r = r.as_ref().unwrap().normalize(values, draw_ctx);
            let n_fx = fx.as_ref().unwrap().normalize(values, draw_ctx);
            let n_fy = fy.as_ref().unwrap().normalize(values, draw_ctx);
            let (new_fx, new_fy) = fix_focus_point(n_fx, n_fy, n_cx, n_cy, n_r);
            let mut pattern = cairo::RadialGradient::new(new_fx, new_fy, 0.0, n_cx, n_cy, n_r);
            if units == GradientUnits(CoordUnits::ObjectBoundingBox) {
                draw_ctx.pop_view_box();
            }
            set_common_on_pattern(gradient, draw_ctx, &mut pattern, bbox, opacity);
        } else {
            {
                {
                    ::rt::begin_panic(
                        "internal error: entered unreachable code",
                        &("rsvg_internals/src/gradient.rs", 597u32, 9u32),
                    )
                }
            };
        }
        true
    }
    fn set_pattern_on_draw_context(
        gradient: &Gradient,
        values: &ComputedValues,
        draw_ctx: &mut DrawingCtx,
        opacity: &UnitInterval,
        bbox: &BoundingBox,
    ) -> bool {
        if !gradient.is_resolved() {
            {
                ::rt::begin_panic(
                    "assertion failed: gradient.is_resolved()",
                    &("rsvg_internals/src/gradient.rs", 610u32, 5u32),
                )
            }
        };
        match gradient.variant {
            GradientVariant::Linear { .. } => {
                set_linear_gradient_on_pattern(gradient, values, draw_ctx, bbox, opacity)
            }
            GradientVariant::Radial { .. } => {
                set_radial_gradient_on_pattern(gradient, values, draw_ctx, bbox, opacity)
            }
        }
    }
    pub struct NodeGradient {
        gradient: RefCell<Gradient>,
    }
    impl NodeGradient {
        pub fn new_linear() -> NodeGradient {
            NodeGradient {
                gradient: RefCell::new(Gradient {
                    common: GradientCommon::unresolved(),
                    variant: GradientVariant::unresolved_linear(),
                }),
            }
        }
        pub fn new_radial() -> NodeGradient {
            NodeGradient {
                gradient: RefCell::new(Gradient {
                    common: GradientCommon::unresolved(),
                    variant: GradientVariant::unresolved_radial(),
                }),
            }
        }
        fn get_gradient_with_color_stops_from_node(&self, node: &RsvgNode) -> Gradient {
            let mut gradient = self.gradient.borrow().clone();
            gradient.add_color_stops_from_node(node);
            gradient
        }
    }
    impl NodeTrait for NodeGradient {
        fn set_atts(
            &self,
            node: &RsvgNode,
            _: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            let mut g = self.gradient.borrow_mut();
            let mut x1 = None;
            let mut y1 = None;
            let mut x2 = None;
            let mut y2 = None;
            let mut cx = None;
            let mut cy = None;
            let mut r = None;
            let mut fx = None;
            let mut fy = None;
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::GradientUnits => {
                        g.common.units = Some(parse("gradientUnits", value, ())?)
                    }
                    Attribute::GradientTransform => {
                        g.common.affine = Some(parse("gradientTransform", value, ())?)
                    }
                    Attribute::SpreadMethod => {
                        g.common.spread = Some(parse("spreadMethod", value, ())?)
                    }
                    Attribute::XlinkHref => g.common.fallback = Some(value.to_owned()),
                    Attribute::X1 => x1 = Some(parse("x1", value, LengthDir::Horizontal)?),
                    Attribute::Y1 => y1 = Some(parse("y1", value, LengthDir::Vertical)?),
                    Attribute::X2 => x2 = Some(parse("x2", value, LengthDir::Horizontal)?),
                    Attribute::Y2 => y2 = Some(parse("y2", value, LengthDir::Vertical)?),
                    Attribute::Cx => cx = Some(parse("cx", value, LengthDir::Horizontal)?),
                    Attribute::Cy => cy = Some(parse("cy", value, LengthDir::Vertical)?),
                    Attribute::R => r = Some(parse("r", value, LengthDir::Both)?),
                    Attribute::Fx => fx = Some(parse("fx", value, LengthDir::Horizontal)?),
                    Attribute::Fy => fy = Some(parse("fy", value, LengthDir::Vertical)?),
                    _ => (),
                }
            }
            match node.get_type() {
                NodeType::LinearGradient => {
                    g.variant = GradientVariant::Linear { x1, y1, x2, y2 };
                }
                NodeType::RadialGradient => {
                    g.variant = GradientVariant::Radial { cx, cy, r, fx, fy };
                }
                _ => ::rt::begin_panic(
                    "internal error: entered unreachable code",
                    &("rsvg_internals/src/gradient.rs", 711u32, 18u32),
                ),
            }
            Ok(())
        }
    }
    fn resolve_fallbacks_and_set_pattern(
        gradient: &Gradient,
        values: &ComputedValues,
        draw_ctx: &mut DrawingCtx,
        opacity: &UnitInterval,
        bbox: &BoundingBox,
    ) -> bool {
        match bbox.rect {
            Some(r) if !r.is_empty() => {
                let resolved = resolve_gradient(gradient, draw_ctx);
                set_pattern_on_draw_context(&resolved, values, draw_ctx, opacity, bbox)
            }
            _ => true,
        }
    }
    pub fn gradient_resolve_fallbacks_and_set_pattern(
        node: &RsvgNode,
        draw_ctx: &mut DrawingCtx,
        opacity: &UnitInterval,
        bbox: &BoundingBox,
    ) -> bool {
        if !(node.get_type() == NodeType::LinearGradient
            || node.get_type() == NodeType::RadialGradient)
        {
            {
                ::rt::begin_panic("assertion failed: node.get_type() == NodeType::LinearGradient ||\n    node.get_type() == NodeType::RadialGradient",
                                  &("rsvg_internals/src/gradient.rs", 741u32,
                                    5u32))
            }
        };
        let mut did_set_gradient = false;
        node.with_impl(|node_gradient: &NodeGradient| {
            let gradient = node_gradient.get_gradient_with_color_stops_from_node(node);
            let cascaded = node.get_cascaded_values();
            let values = cascaded.get();
            did_set_gradient =
                resolve_fallbacks_and_set_pattern(&gradient, &values, draw_ctx, opacity, bbox);
        });
        did_set_gradient
    }
}
mod handle {
    pub enum RsvgHandle {}
}
mod image {
    use aspect_ratio::AspectRatio;
    use attributes::Attribute;
    use bbox::BoundingBox;
    use cairo;
    use cairo::{MatrixTrait, Pattern};
    use cairo_sys;
    use drawing_ctx::DrawingCtx;
    use glib;
    use glib::translate::*;
    use glib_sys;
    use handle::RsvgHandle;
    use length::*;
    use libc;
    use node::*;
    use parsers::{parse, parse_and_validate};
    use property_bag::PropertyBag;
    use std::cell::{Cell, RefCell};
    use std::ptr;
    pub struct NodeImage {
        aspect: Cell<AspectRatio>,
        x: Cell<RsvgLength>,
        y: Cell<RsvgLength>,
        w: Cell<RsvgLength>,
        h: Cell<RsvgLength>,
        surface: RefCell<Option<cairo::ImageSurface>>,
    }
    impl NodeImage {
        pub fn new() -> NodeImage {
            NodeImage {
                aspect: Cell::new(AspectRatio::default()),
                x: Cell::new(RsvgLength::default()),
                y: Cell::new(RsvgLength::default()),
                w: Cell::new(RsvgLength::default()),
                h: Cell::new(RsvgLength::default()),
                surface: RefCell::new(None),
            }
        }
    }
    impl NodeTrait for NodeImage {
        fn set_atts(
            &self,
            node: &RsvgNode,
            handle: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            node.set_overflow_hidden();
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::X => self.x.set(parse("x", value, LengthDir::Horizontal)?),
                    Attribute::Y => self.y.set(parse("y", value, LengthDir::Vertical)?),
                    Attribute::Width => self.w.set(parse_and_validate(
                        "width",
                        value,
                        LengthDir::Horizontal,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::Height => self.h.set(parse_and_validate(
                        "height",
                        value,
                        LengthDir::Vertical,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::PreserveAspectRatio => {
                        self.aspect.set(parse("preserveAspectRatio", value, ())?)
                    }
                    Attribute::XlinkHref | Attribute::Path => {
                        extern "C" {
                            fn rsvg_cairo_surface_new_from_href(
                                handle: *const RsvgHandle,
                                href: *const libc::c_char,
                                error: *mut *mut glib_sys::GError,
                            ) -> *mut cairo_sys::cairo_surface_t;
                        }
                        let mut error = ptr::null_mut();
                        let raw_surface = unsafe {
                            rsvg_cairo_surface_new_from_href(
                                handle,
                                value.to_glib_none().0,
                                &mut error,
                            )
                        };
                        if !raw_surface.is_null() {
                            *self.surface.borrow_mut() = Some(unsafe {
                                cairo::ImageSurface::from_raw_full(raw_surface).unwrap()
                            });
                        } else {
                            let _: glib::Error = unsafe { from_glib_full(error) };
                        }
                    }
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            if let Some(ref surface) = *self.surface.borrow() {
                let x = self.x.get().normalize(values, draw_ctx);
                let y = self.y.get().normalize(values, draw_ctx);
                let w = self.w.get().normalize(values, draw_ctx);
                let h = self.h.get().normalize(values, draw_ctx);
                draw_ctx.with_discrete_layer(
                    node,
                    values,
                    clipping,
                    &mut (|dc| {
                        let aspect = self.aspect.get();
                        if !values.is_overflow() && aspect.is_slice() {
                            dc.clip(x, y, w, h);
                        }
                        let bbox = BoundingBox::new(&dc.get_cairo_context().get_matrix())
                            .with_rect(Some(cairo::Rectangle {
                                x,
                                y,
                                width: w,
                                height: h,
                            }));
                        let width = surface.get_width();
                        let height = surface.get_height();
                        if clipping || width == 0 || height == 0 {
                            return;
                        }
                        let width = f64::from(width);
                        let height = f64::from(height);
                        let (x, y, w, h) = aspect.compute(width, height, x, y, w, h);
                        let cr = dc.get_cairo_context();
                        cr.save();
                        dc.set_affine_on_cr(&cr);
                        cr.scale(w / width, h / height);
                        let x = x * width / w;
                        let y = y * height / h;
                        cr.set_operator(cairo::Operator::from(values.comp_op));
                        let ptn = cairo::SurfacePattern::create(&surface);
                        let mut matrix = cairo::Matrix::identity();
                        matrix.translate(-x, -y);
                        ptn.set_matrix(matrix);
                        ptn.set_extend(cairo::Extend::Pad);
                        cr.set_source(&ptn);
                        cr.rectangle(x, y, width, height);
                        cr.clip();
                        cr.paint();
                        cr.restore();
                        dc.insert_bbox(&bbox);
                    }),
                );
            }
        }
    }
}
mod iri {
    use cssparser::Parser;
    use parsers::Parse;
    use parsers::ParseError;
    pub enum IRI {
        None,
        Resource(String),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for IRI {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&IRI::None,) => {
                    let mut debug_trait_builder = f.debug_tuple("None");
                    debug_trait_builder.finish()
                }
                (&IRI::Resource(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Resource");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for IRI {
        #[inline]
        fn clone(&self) -> IRI {
            match (&*self,) {
                (&IRI::None,) => IRI::None,
                (&IRI::Resource(ref __self_0),) => {
                    IRI::Resource(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for IRI {
        #[inline]
        fn eq(&self, other: &IRI) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&IRI::Resource(ref __self_0), &IRI::Resource(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &IRI) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&IRI::Resource(ref __self_0), &IRI::Resource(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    impl Default for IRI {
        fn default() -> IRI {
            IRI::None
        }
    }
    impl IRI {
        /// Returns the contents of an `IRI::Resource`, or `None`
        pub fn get(&self) -> Option<&str> {
            match *self {
                IRI::None => None,
                IRI::Resource(ref s) => Some(s.as_ref()),
            }
        }
    }
    impl Parse for IRI {
        type Data = ();
        type Err = ParseError;
        fn parse(parser: &mut Parser, _: Self::Data) -> Result<IRI, ParseError> {
            if parser.try(|i| i.expect_ident_matching("none")).is_ok() {
                Ok(IRI::None)
            } else {
                let url = parser
                    .expect_url()
                    .map_err(|_| ParseError::new("expected url"))?;
                parser
                    .expect_exhausted()
                    .map_err(|_| ParseError::new("expected url"))?;
                Ok(IRI::Resource(url.as_ref().to_owned()))
            }
        }
    }
}
mod length {
    use cssparser::{Parser, Token};
    use drawing_ctx::{DrawingCtx, RsvgDrawingCtx};
    use error::*;
    use libc;
    use parsers::Parse;
    use parsers::ParseError;
    use state::{ComputedValues, RsvgComputedValues};
    use std::f64::consts::*;
    use util::utf8_cstr;
    #[repr(C)]
    #[rustc_copy_clone_marker]
    pub enum LengthUnit {
        Default,
        Percent,
        FontEm,
        FontEx,
        Inch,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for LengthUnit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&LengthUnit::Default,) => {
                    let mut debug_trait_builder = f.debug_tuple("Default");
                    debug_trait_builder.finish()
                }
                (&LengthUnit::Percent,) => {
                    let mut debug_trait_builder = f.debug_tuple("Percent");
                    debug_trait_builder.finish()
                }
                (&LengthUnit::FontEm,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontEm");
                    debug_trait_builder.finish()
                }
                (&LengthUnit::FontEx,) => {
                    let mut debug_trait_builder = f.debug_tuple("FontEx");
                    debug_trait_builder.finish()
                }
                (&LengthUnit::Inch,) => {
                    let mut debug_trait_builder = f.debug_tuple("Inch");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for LengthUnit {
        #[inline]
        fn eq(&self, other: &LengthUnit) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for LengthUnit {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for LengthUnit {
        #[inline]
        fn clone(&self) -> LengthUnit {
            {
                *self
            }
        }
    }
    #[repr(C)]
    #[rustc_copy_clone_marker]
    pub enum LengthDir {
        Horizontal,
        Vertical,
        Both,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for LengthDir {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&LengthDir::Horizontal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Horizontal");
                    debug_trait_builder.finish()
                }
                (&LengthDir::Vertical,) => {
                    let mut debug_trait_builder = f.debug_tuple("Vertical");
                    debug_trait_builder.finish()
                }
                (&LengthDir::Both,) => {
                    let mut debug_trait_builder = f.debug_tuple("Both");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for LengthDir {
        #[inline]
        fn eq(&self, other: &LengthDir) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for LengthDir {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for LengthDir {
        #[inline]
        fn clone(&self) -> LengthDir {
            {
                *self
            }
        }
    }
    #[repr(C)]
    #[rustc_copy_clone_marker]
    pub struct RsvgLength {
        pub length: f64,
        pub unit: LengthUnit,
        dir: LengthDir,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for RsvgLength {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                RsvgLength {
                    length: ref __self_0_0,
                    unit: ref __self_0_1,
                    dir: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("RsvgLength");
                    let _ = debug_trait_builder.field("length", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("unit", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("dir", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for RsvgLength {
        #[inline]
        fn eq(&self, other: &RsvgLength) -> bool {
            match *other {
                RsvgLength {
                    length: ref __self_1_0,
                    unit: ref __self_1_1,
                    dir: ref __self_1_2,
                } => match *self {
                    RsvgLength {
                        length: ref __self_0_0,
                        unit: ref __self_0_1,
                        dir: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &RsvgLength) -> bool {
            match *other {
                RsvgLength {
                    length: ref __self_1_0,
                    unit: ref __self_1_1,
                    dir: ref __self_1_2,
                } => match *self {
                    RsvgLength {
                        length: ref __self_0_0,
                        unit: ref __self_0_1,
                        dir: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for RsvgLength {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for RsvgLength {
        #[inline]
        fn clone(&self) -> RsvgLength {
            {
                let _: ::std::clone::AssertParamIsClone<f64>;
                let _: ::std::clone::AssertParamIsClone<LengthUnit>;
                let _: ::std::clone::AssertParamIsClone<LengthDir>;
                *self
            }
        }
    }
    impl Default for RsvgLength {
        fn default() -> RsvgLength {
            RsvgLength {
                length: 0.0,
                unit: LengthUnit::Default,
                dir: LengthDir::Both,
            }
        }
    }
    const POINTS_PER_INCH: f64 = 72.0;
    const CM_PER_INCH: f64 = 2.54;
    const MM_PER_INCH: f64 = 25.4;
    const PICA_PER_INCH: f64 = 6.0;
    #[no_mangle]
    pub extern "C" fn rsvg_length_parse(string: *const libc::c_char, dir: LengthDir) -> RsvgLength {
        let my_string = unsafe { utf8_cstr(string) };
        RsvgLength::parse_str(my_string, dir).unwrap_or_else(|_| RsvgLength::default())
    }
    fn make_err() -> AttributeError {
        AttributeError::Parse(ParseError::new("expected length: number(\"em\" | \"ex\" | \"px\" | \"in\" | \"cm\" | \"mm\" | \"pt\" | \"pc\" | \"%\")?"))
    }
    impl Parse for RsvgLength {
        type Data = LengthDir;
        type Err = AttributeError;
        fn parse(parser: &mut Parser, dir: LengthDir) -> Result<RsvgLength, AttributeError> {
            let length = RsvgLength::from_cssparser(parser, dir)?;
            parser.expect_exhausted().map_err(|_| make_err())?;
            Ok(length)
        }
    }
    impl RsvgLength {
        pub fn new(l: f64, unit: LengthUnit, dir: LengthDir) -> RsvgLength {
            RsvgLength {
                length: l,
                unit,
                dir,
            }
        }
        pub fn check_nonnegative(self) -> Result<RsvgLength, AttributeError> {
            if self.length >= 0.0 {
                Ok(self)
            } else {
                Err(AttributeError::Value(
                    "value must be non-negative".to_string(),
                ))
            }
        }
        pub fn normalize(&self, values: &ComputedValues, draw_ctx: &DrawingCtx) -> f64 {
            match self.unit {
                LengthUnit::Default => self.length,
                LengthUnit::Percent => {
                    let (width, height) = draw_ctx.get_view_box_size();
                    match self.dir {
                        LengthDir::Horizontal => self.length * width,
                        LengthDir::Vertical => self.length * height,
                        LengthDir::Both => self.length * viewport_percentage(width, height),
                    }
                }
                LengthUnit::FontEm => self.length * font_size_from_values(values, draw_ctx),
                LengthUnit::FontEx => self.length * font_size_from_values(values, draw_ctx) / 2.0,
                LengthUnit::Inch => font_size_from_inch(self.length, self.dir, draw_ctx),
            }
        }
        /// Returns the raw length after asserting units are either default or percent.
        #[inline]
        pub fn get_unitless(&self) -> f64 {
            if !(self.unit == LengthUnit::Default || self.unit == LengthUnit::Percent) {
                {
                    ::rt::begin_panic("assertion failed: self.unit == LengthUnit::Default || self.unit == LengthUnit::Percent",
                                      &("rsvg_internals/src/length.rs",
                                        142u32, 9u32))
                }
            };
            self.length
        }
        pub fn hand_normalize(
            &self,
            pixels_per_inch: f64,
            width_or_height: f64,
            font_size: f64,
        ) -> f64 {
            match self.unit {
                LengthUnit::Default => self.length,
                LengthUnit::Percent => self.length * width_or_height,
                LengthUnit::FontEm => self.length * font_size,
                LengthUnit::FontEx => self.length * font_size / 2.0,
                LengthUnit::Inch => self.length * pixels_per_inch,
            }
        }
        pub fn from_cssparser(
            parser: &mut Parser,
            dir: LengthDir,
        ) -> Result<RsvgLength, AttributeError> {
            let length = {
                let token = parser.next().map_err(|_| {
                    AttributeError::Parse(ParseError::new(
                        "expected number and optional symbol, or number and percentage",
                    ))
                })?;
                match *token {
                    Token::Number { value, .. } => RsvgLength {
                        length: f64::from(value),
                        unit: LengthUnit::Default,
                        dir,
                    },
                    Token::Percentage { unit_value, .. } => RsvgLength {
                        length: f64::from(unit_value),
                        unit: LengthUnit::Percent,
                        dir,
                    },
                    Token::Dimension {
                        value, ref unit, ..
                    } => {
                        let value = f64::from(value);
                        match unit.as_ref() {
                            "em" => RsvgLength {
                                length: value,
                                unit: LengthUnit::FontEm,
                                dir,
                            },
                            "ex" => RsvgLength {
                                length: value,
                                unit: LengthUnit::FontEx,
                                dir,
                            },
                            "pt" => RsvgLength {
                                length: value / POINTS_PER_INCH,
                                unit: LengthUnit::Inch,
                                dir,
                            },
                            "in" => RsvgLength {
                                length: value,
                                unit: LengthUnit::Inch,
                                dir,
                            },
                            "cm" => RsvgLength {
                                length: value / CM_PER_INCH,
                                unit: LengthUnit::Inch,
                                dir,
                            },
                            "mm" => RsvgLength {
                                length: value / MM_PER_INCH,
                                unit: LengthUnit::Inch,
                                dir,
                            },
                            "pc" => RsvgLength {
                                length: value / PICA_PER_INCH,
                                unit: LengthUnit::Inch,
                                dir,
                            },
                            "px" => RsvgLength {
                                length: value,
                                unit: LengthUnit::Default,
                                dir,
                            },
                            _ => return Err(make_err()),
                        }
                    }
                    _ => return Err(make_err()),
                }
            };
            Ok(length)
        }
    }
    fn font_size_from_inch(length: f64, dir: LengthDir, draw_ctx: &DrawingCtx) -> f64 {
        let (dpi_x, dpi_y) = draw_ctx.get_dpi();
        match dir {
            LengthDir::Horizontal => length * dpi_x,
            LengthDir::Vertical => length * dpi_y,
            LengthDir::Both => length * viewport_percentage(dpi_x, dpi_y),
        }
    }
    fn font_size_from_values(values: &ComputedValues, draw_ctx: &DrawingCtx) -> f64 {
        let v = &values.font_size.0.value();
        match v.unit {
            LengthUnit::Default => v.length,
            LengthUnit::Inch => font_size_from_inch(v.length, v.dir, draw_ctx),
            LengthUnit::Percent | LengthUnit::FontEm | LengthUnit::FontEx => ::rt::begin_panic_fmt(
                &::std::fmt::Arguments::new_v1_formatted(
                    &["internal error: entered unreachable code: "],
                    &match (&"ComputedValues can\'t have a relative font size",) {
                        (arg0,) => [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)],
                    },
                    &[::std::fmt::rt::v1::Argument {
                        position: ::std::fmt::rt::v1::Position::At(0usize),
                        format: ::std::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::std::fmt::rt::v1::Count::Implied,
                            width: ::std::fmt::rt::v1::Count::Implied,
                        },
                    }],
                ),
                &("rsvg_internals/src/length.rs", 274u32, 13u32),
            ),
        }
    }
    fn viewport_percentage(x: f64, y: f64) -> f64 {
        (x * x + y * y).sqrt() / SQRT_2
    }
    #[rustc_copy_clone_marker]
    pub enum FontSizeSpec {
        Smaller,
        Larger,
        XXSmall,
        XSmall,
        Small,
        Medium,
        Large,
        XLarge,
        XXLarge,
        Value(RsvgLength),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FontSizeSpec {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FontSizeSpec::Smaller,) => {
                    let mut debug_trait_builder = f.debug_tuple("Smaller");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::Larger,) => {
                    let mut debug_trait_builder = f.debug_tuple("Larger");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::XXSmall,) => {
                    let mut debug_trait_builder = f.debug_tuple("XXSmall");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::XSmall,) => {
                    let mut debug_trait_builder = f.debug_tuple("XSmall");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::Small,) => {
                    let mut debug_trait_builder = f.debug_tuple("Small");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::Medium,) => {
                    let mut debug_trait_builder = f.debug_tuple("Medium");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::Large,) => {
                    let mut debug_trait_builder = f.debug_tuple("Large");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::XLarge,) => {
                    let mut debug_trait_builder = f.debug_tuple("XLarge");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::XXLarge,) => {
                    let mut debug_trait_builder = f.debug_tuple("XXLarge");
                    debug_trait_builder.finish()
                }
                (&FontSizeSpec::Value(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Value");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FontSizeSpec {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FontSizeSpec {
        #[inline]
        fn clone(&self) -> FontSizeSpec {
            {
                let _: ::std::clone::AssertParamIsClone<RsvgLength>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FontSizeSpec {
        #[inline]
        fn eq(&self, other: &FontSizeSpec) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &FontSizeSpec::Value(ref __self_0),
                            &FontSizeSpec::Value(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &FontSizeSpec) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &FontSizeSpec::Value(ref __self_0),
                            &FontSizeSpec::Value(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    impl FontSizeSpec {
        pub fn value(&self) -> RsvgLength {
            match self {
                FontSizeSpec::Value(s) => s.clone(),
                _ => ::rt::begin_panic(
                    "internal error: entered unreachable code",
                    &("rsvg_internals/src/length.rs", 305u32, 18u32),
                ),
            }
        }
        pub fn compute(&self, v: &ComputedValues) -> Self {
            let compute_points = |p| 12.0 * 1.2f64.powf(p) / POINTS_PER_INCH;
            let size = v.font_size.0.value();
            let new_size = match self {
                FontSizeSpec::Smaller => {
                    RsvgLength::new(size.length / 1.2, size.unit, LengthDir::Both)
                }
                FontSizeSpec::Larger => {
                    RsvgLength::new(size.length * 1.2, size.unit, LengthDir::Both)
                }
                FontSizeSpec::XXSmall => {
                    RsvgLength::new(compute_points(-3.0), LengthUnit::Inch, LengthDir::Both)
                }
                FontSizeSpec::XSmall => {
                    RsvgLength::new(compute_points(-2.0), LengthUnit::Inch, LengthDir::Both)
                }
                FontSizeSpec::Small => {
                    RsvgLength::new(compute_points(-1.0), LengthUnit::Inch, LengthDir::Both)
                }
                FontSizeSpec::Medium => {
                    RsvgLength::new(compute_points(0.0), LengthUnit::Inch, LengthDir::Both)
                }
                FontSizeSpec::Large => {
                    RsvgLength::new(compute_points(1.0), LengthUnit::Inch, LengthDir::Both)
                }
                FontSizeSpec::XLarge => {
                    RsvgLength::new(compute_points(2.0), LengthUnit::Inch, LengthDir::Both)
                }
                FontSizeSpec::XXLarge => {
                    RsvgLength::new(compute_points(3.0), LengthUnit::Inch, LengthDir::Both)
                }
                FontSizeSpec::Value(s) if s.unit == LengthUnit::Percent => {
                    RsvgLength::new(size.length * s.length, size.unit, LengthDir::Both)
                }
                FontSizeSpec::Value(s) => s.clone(),
            };
            FontSizeSpec::Value(new_size)
        }
        pub fn normalize(&self, values: &ComputedValues, draw_ctx: &DrawingCtx) -> f64 {
            self.value().normalize(values, draw_ctx)
        }
    }
    impl Parse for FontSizeSpec {
        type Data = ();
        type Err = AttributeError;
        fn parse(
            parser: &mut Parser,
            _: Self::Data,
        ) -> Result<FontSizeSpec, ::error::AttributeError> {
            let parser_state = parser.state();
            RsvgLength::parse(parser, LengthDir::Both)
                .and_then(|s| Ok(FontSizeSpec::Value(s)))
                .or_else(|e| {
                    parser.reset(&parser_state);
                    {
                        let token = parser.next().map_err(|_| {
                            ::error::AttributeError::Parse(::parsers::ParseError::new(
                                "expected token",
                            ))
                        })?;
                        if let Token::Ident(ref cow) = token {
                            match cow.as_ref() {
                                "smaller" => return Ok(FontSizeSpec::Smaller),
                                "larger" => return Ok(FontSizeSpec::Larger),
                                "xx-small" => return Ok(FontSizeSpec::XXSmall),
                                "x-small" => return Ok(FontSizeSpec::XSmall),
                                "small" => return Ok(FontSizeSpec::Small),
                                "medium" => return Ok(FontSizeSpec::Medium),
                                "large" => return Ok(FontSizeSpec::Large),
                                "x-large" => return Ok(FontSizeSpec::XLarge),
                                "xx-large" => return Ok(FontSizeSpec::XXLarge),
                                _ => (),
                            };
                        }
                    }
                    parser.reset(&parser_state);
                    Err(e)
                })
        }
    }
    pub enum Dasharray {
        None,
        Array(Vec<RsvgLength>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Dasharray {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Dasharray::None,) => {
                    let mut debug_trait_builder = f.debug_tuple("None");
                    debug_trait_builder.finish()
                }
                (&Dasharray::Array(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Array");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Dasharray {
        #[inline]
        fn eq(&self, other: &Dasharray) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Dasharray::Array(ref __self_0), &Dasharray::Array(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Dasharray) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Dasharray::Array(ref __self_0), &Dasharray::Array(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Dasharray {
        #[inline]
        fn clone(&self) -> Dasharray {
            match (&*self,) {
                (&Dasharray::None,) => Dasharray::None,
                (&Dasharray::Array(ref __self_0),) => {
                    Dasharray::Array(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl Default for Dasharray {
        fn default() -> Dasharray {
            Dasharray::None
        }
    }
    impl Parse for Dasharray {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: Self::Data) -> Result<Dasharray, AttributeError> {
            if parser.try(|p| p.expect_ident_matching("none")).is_ok() {
                Ok(Dasharray::None)
            } else {
                Ok(Dasharray::Array(parse_dash_array(parser)?))
            }
        }
    }
    fn parse_dash_array(parser: &mut Parser) -> Result<Vec<RsvgLength>, AttributeError> {
        let mut dasharray = Vec::new();
        loop {
            dasharray.push(
                RsvgLength::from_cssparser(parser, LengthDir::Both)
                    .and_then(RsvgLength::check_nonnegative)?,
            );
            if parser.is_exhausted() {
                break;
            } else if parser.try(|p| p.expect_comma()).is_ok() {
                continue;
            }
        }
        Ok(dasharray)
    }
    #[no_mangle]
    pub extern "C" fn rsvg_length_normalize(
        raw_length: *const RsvgLength,
        values: RsvgComputedValues,
        draw_ctx: *const RsvgDrawingCtx,
    ) -> f64 {
        if !!raw_length.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_length.is_null()",
                    &("rsvg_internals/src/length.rs", 443u32, 5u32),
                )
            }
        };
        let length: &RsvgLength = unsafe { &*raw_length };
        if !!values.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !values.is_null()",
                    &("rsvg_internals/src/length.rs", 446u32, 5u32),
                )
            }
        };
        let values = unsafe { &*values };
        if !!draw_ctx.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !draw_ctx.is_null()",
                    &("rsvg_internals/src/length.rs", 449u32, 5u32),
                )
            }
        };
        let draw_ctx = unsafe { &*(draw_ctx as *const DrawingCtx) };
        length.normalize(values, draw_ctx)
    }
    #[no_mangle]
    pub extern "C" fn rsvg_length_hand_normalize(
        raw_length: *const RsvgLength,
        pixels_per_inch: f64,
        width_or_height: f64,
        font_size: f64,
    ) -> f64 {
        if !!raw_length.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_length.is_null()",
                    &("rsvg_internals/src/length.rs", 462u32, 5u32),
                )
            }
        };
        let length: &RsvgLength = unsafe { &*raw_length };
        length.hand_normalize(pixels_per_inch, width_or_height, font_size)
    }
}
mod link {
    use attributes::Attribute;
    use cairo;
    use cairo_sys;
    use drawing_ctx::DrawingCtx;
    use glib::translate::*;
    use handle::RsvgHandle;
    use libc;
    use node::*;
    use property_bag::PropertyBag;
    use regex::{Captures, Regex};
    use std::borrow::Cow;
    use std::cell::RefCell;
    pub struct NodeLink {
        link: RefCell<Option<String>>,
    }
    impl NodeLink {
        pub fn new() -> NodeLink {
            NodeLink {
                link: RefCell::new(None),
            }
        }
    }
    impl NodeTrait for NodeLink {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::XlinkHref => *self.link.borrow_mut() = Some(value.to_owned()),
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let link = self.link.borrow();
            let cascaded = CascadedValues::new(cascaded, node);
            let values = cascaded.get();
            draw_ctx.with_discrete_layer(
                node,
                values,
                clipping,
                &mut (|dc| {
                    if link.is_some() && link.as_ref().unwrap() != "" {
                        const CAIRO_TAG_LINK: &str = "Link";
                        let attributes = link.as_ref().map(|i| {
                            ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                                &["uri=\'", "\'"],
                                &match (&escape_value(i),) {
                                    (arg0,) => [::std::fmt::ArgumentV1::new(
                                        arg0,
                                        ::std::fmt::Display::fmt,
                                    )],
                                },
                                &[::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                }],
                            ))
                        });
                        let cr = dc.get_cairo_context();
                        cr.tag_begin(CAIRO_TAG_LINK, attributes.as_ref().map(|i| i.as_str()));
                        node.draw_children(&cascaded, dc, clipping);
                        cr.tag_end(CAIRO_TAG_LINK);
                    } else {
                        node.draw_children(&cascaded, dc, clipping)
                    }
                }),
            );
        }
    }
    /// escape quotes and backslashes with backslash
    fn escape_value(value: &str) -> Cow<str> {
        #[allow(missing_copy_implementations)]
        #[allow(non_camel_case_types)]
        #[allow(dead_code)]
        struct REGEX {
            __private_field: (),
        }
        #[doc(hidden)]
        static REGEX: REGEX = REGEX {
            __private_field: (),
        };
        impl ::__Deref for REGEX {
            type Target = Regex;
            #[allow(unsafe_code)]
            fn deref(&self) -> &Regex {
                unsafe {
                    #[inline(always)]
                    fn __static_ref_initialize() -> Regex {
                        Regex::new(r"['\\]").unwrap()
                    }
                    #[inline(always)]
                    unsafe fn __stability() -> &'static Regex {
                        static mut LAZY: ::lazy::Lazy<Regex> =
                            ::lazy::Lazy(0 as *const Regex, ::lazy::ONCE_INIT);
                        LAZY.get(__static_ref_initialize)
                    }
                    __stability()
                }
            }
        }
        impl ::LazyStatic for REGEX {
            fn initialize(lazy: &Self) {
                let _ = &**lazy;
            }
        }
        REGEX.replace_all(value, |caps: &Captures| {
            match caps.get(0).unwrap().as_str() {
                "\'" => "\\\'".to_owned(),
                "\\" => "\\\\".to_owned(),
                _ => ::rt::begin_panic(
                    "internal error: entered unreachable code",
                    &("rsvg_internals/src/link.rs", 81u32, 18u32),
                ),
            }
        })
    }
    extern "C" {
        fn cairo_tag_begin(
            cr: *mut cairo_sys::cairo_t,
            tag_name: *const libc::c_char,
            attibutes: *const libc::c_char,
        );
        fn cairo_tag_end(cr: *mut cairo_sys::cairo_t, tag_name: *const libc::c_char);
    }
    /// Bindings that aren't supported by `cairo-rs` for now
    trait CairoTagging {
        fn tag_begin(&self, tag_name: &str, attributes: Option<&str>);
        fn tag_end(&self, tag_name: &str);
    }
    impl CairoTagging for cairo::Context {
        fn tag_begin(&self, tag_name: &str, attributes: Option<&str>) {
            unsafe {
                cairo_tag_begin(
                    self.to_glib_none().0,
                    tag_name.to_glib_none().0,
                    attributes.to_glib_none().0,
                );
            }
        }
        fn tag_end(&self, tag_name: &str) {
            unsafe {
                cairo_tag_end(self.to_glib_none().0, tag_name.to_glib_none().0);
            }
        }
    }
}
mod load {
    use attributes::Attribute;
    use clip_path::NodeClipPath;
    use filters::{
        blend::Blend,
        color_matrix::ColorMatrix,
        component_transfer::{ComponentTransfer, FuncX},
        composite::Composite,
        convolve_matrix::ConvolveMatrix,
        displacement_map::DisplacementMap,
        flood::Flood,
        gaussian_blur::GaussianBlur,
        image::Image,
        light::{
            diffuse_lighting::DiffuseLighting, light_source::LightSource,
            specular_lighting::SpecularLighting,
        },
        merge::{Merge, MergeNode},
        morphology::Morphology,
        node::NodeFilter,
        offset::Offset,
        tile::Tile,
        turbulence::Turbulence,
    };
    use gradient::NodeGradient;
    use image::NodeImage;
    use libc;
    use link::NodeLink;
    use marker::NodeMarker;
    use mask::NodeMask;
    use node::*;
    use pattern::NodePattern;
    use property_bag::PropertyBag;
    use shapes::{NodeCircle, NodeEllipse, NodeLine, NodePath, NodePoly, NodeRect};
    use std::collections::HashMap;
    use stop::NodeStop;
    use structure::{NodeDefs, NodeGroup, NodeSvg, NodeSwitch, NodeSymbol, NodeUse};
    use text::{NodeTRef, NodeTSpan, NodeText};
    use util::utf8_cstr;
    macro_rules! node_create_fn((
                                $ name : ident , $ node_type : ident , $
                                new_fn : expr ) => {
                                fn $ name (
                                id : Option < & str > , class : Option < & str
                                > , parent : * const RsvgNode , ) -> * const
                                RsvgNode {
                                boxed_node_new (
                                NodeType :: $ node_type , parent , id , class
                                , Box :: new ( $ new_fn (  ) ) ) } } ;);
    fn create_circle(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Circle,
            parent,
            id,
            class,
            Box::new(NodeCircle::new()),
        )
    }
    fn create_clip_path(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::ClipPath,
            parent,
            id,
            class,
            Box::new(NodeClipPath::new()),
        )
    }
    fn create_blend(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveBlend,
            parent,
            id,
            class,
            Box::new(Blend::new()),
        )
    }
    fn create_color_matrix(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveColorMatrix,
            parent,
            id,
            class,
            Box::new(ColorMatrix::new()),
        )
    }
    fn create_component_transfer(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveComponentTransfer,
            parent,
            id,
            class,
            Box::new(ComponentTransfer::new()),
        )
    }
    fn create_component_transfer_func_r(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::ComponentTransferFunction,
            parent,
            id,
            class,
            Box::new(FuncX::new_r()),
        )
    }
    fn create_component_transfer_func_g(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::ComponentTransferFunction,
            parent,
            id,
            class,
            Box::new(FuncX::new_g()),
        )
    }
    fn create_component_transfer_func_b(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::ComponentTransferFunction,
            parent,
            id,
            class,
            Box::new(FuncX::new_b()),
        )
    }
    fn create_component_transfer_func_a(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::ComponentTransferFunction,
            parent,
            id,
            class,
            Box::new(FuncX::new_a()),
        )
    }
    fn create_composite(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveComposite,
            parent,
            id,
            class,
            Box::new(Composite::new()),
        )
    }
    fn create_convolve_matrix(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveConvolveMatrix,
            parent,
            id,
            class,
            Box::new(ConvolveMatrix::new()),
        )
    }
    fn create_defs(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Defs, parent, id, class, Box::new(NodeDefs::new()))
    }
    fn create_diffuse_lighting(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveDiffuseLighting,
            parent,
            id,
            class,
            Box::new(DiffuseLighting::new()),
        )
    }
    fn create_distant_light(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::LightSource,
            parent,
            id,
            class,
            Box::new(LightSource::new_distant_light()),
        )
    }
    fn create_displacement_map(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveDisplacementMap,
            parent,
            id,
            class,
            Box::new(DisplacementMap::new()),
        )
    }
    fn create_ellipse(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Ellipse,
            parent,
            id,
            class,
            Box::new(NodeEllipse::new()),
        )
    }
    fn create_filter(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Filter,
            parent,
            id,
            class,
            Box::new(NodeFilter::new()),
        )
    }
    fn create_flood(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveFlood,
            parent,
            id,
            class,
            Box::new(Flood::new()),
        )
    }
    fn create_gaussian_blur(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveGaussianBlur,
            parent,
            id,
            class,
            Box::new(GaussianBlur::new()),
        )
    }
    fn create_group(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Group,
            parent,
            id,
            class,
            Box::new(NodeGroup::new()),
        )
    }
    fn create_image(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Image,
            parent,
            id,
            class,
            Box::new(NodeImage::new()),
        )
    }
    fn create_fe_image(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveImage,
            parent,
            id,
            class,
            Box::new(Image::new()),
        )
    }
    fn create_linear_gradient(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::LinearGradient,
            parent,
            id,
            class,
            Box::new(NodeGradient::new_linear()),
        )
    }
    fn create_line(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Line, parent, id, class, Box::new(NodeLine::new()))
    }
    fn create_link(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Link, parent, id, class, Box::new(NodeLink::new()))
    }
    fn create_marker(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Marker,
            parent,
            id,
            class,
            Box::new(NodeMarker::new()),
        )
    }
    fn create_mask(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Mask, parent, id, class, Box::new(NodeMask::new()))
    }
    fn create_merge(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveMerge,
            parent,
            id,
            class,
            Box::new(Merge::new()),
        )
    }
    fn create_merge_node(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveMergeNode,
            parent,
            id,
            class,
            Box::new(MergeNode::new()),
        )
    }
    fn create_morphology(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveMorphology,
            parent,
            id,
            class,
            Box::new(Morphology::new()),
        )
    }
    fn create_offset(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveOffset,
            parent,
            id,
            class,
            Box::new(Offset::new()),
        )
    }
    fn create_path(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Path, parent, id, class, Box::new(NodePath::new()))
    }
    fn create_pattern(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Pattern,
            parent,
            id,
            class,
            Box::new(NodePattern::new()),
        )
    }
    fn create_point_light(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::LightSource,
            parent,
            id,
            class,
            Box::new(LightSource::new_point_light()),
        )
    }
    fn create_polygon(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Polygon,
            parent,
            id,
            class,
            Box::new(NodePoly::new_closed()),
        )
    }
    fn create_polyline(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Polyline,
            parent,
            id,
            class,
            Box::new(NodePoly::new_open()),
        )
    }
    fn create_radial_gradient(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::RadialGradient,
            parent,
            id,
            class,
            Box::new(NodeGradient::new_radial()),
        )
    }
    fn create_rect(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Rect, parent, id, class, Box::new(NodeRect::new()))
    }
    fn create_specular_lighting(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveSpecularLighting,
            parent,
            id,
            class,
            Box::new(SpecularLighting::new()),
        )
    }
    fn create_spot_light(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::LightSource,
            parent,
            id,
            class,
            Box::new(LightSource::new_spot_light()),
        )
    }
    fn create_stop(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Stop, parent, id, class, Box::new(NodeStop::new()))
    }
    fn create_svg(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Svg, parent, id, class, Box::new(NodeSvg::new()))
    }
    fn create_switch(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Switch,
            parent,
            id,
            class,
            Box::new(NodeSwitch::new()),
        )
    }
    fn create_symbol(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Symbol,
            parent,
            id,
            class,
            Box::new(NodeSymbol::new()),
        )
    }
    fn create_text(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Text, parent, id, class, Box::new(NodeText::new()))
    }
    fn create_tref(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::TRef, parent, id, class, Box::new(NodeTRef::new()))
    }
    fn create_tspan(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::TSpan,
            parent,
            id,
            class,
            Box::new(NodeTSpan::new()),
        )
    }
    fn create_tile(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveTile,
            parent,
            id,
            class,
            Box::new(Tile::new()),
        )
    }
    fn create_turbulence(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(
            NodeType::FilterPrimitiveTurbulence,
            parent,
            id,
            class,
            Box::new(Turbulence::new()),
        )
    }
    fn create_use(
        id: Option<&str>,
        class: Option<&str>,
        parent: *const RsvgNode,
    ) -> *const RsvgNode {
        boxed_node_new(NodeType::Use, parent, id, class, Box::new(NodeUse::new()))
    }
    type NodeCreateFn = fn(Option<&str>, Option<&str>, *const RsvgNode) -> *const RsvgNode;
    #[allow(missing_copy_implementations)]
    #[allow(non_camel_case_types)]
    #[allow(dead_code)]
    struct NODE_CREATORS {
        __private_field: (),
    }
    #[doc(hidden)]
    static NODE_CREATORS: NODE_CREATORS = NODE_CREATORS {
        __private_field: (),
    };
    impl ::__Deref for NODE_CREATORS {
        type Target = HashMap<&'static str, (bool, NodeCreateFn)>;
        #[allow(unsafe_code)]
        fn deref(&self) -> &HashMap<&'static str, (bool, NodeCreateFn)> {
            unsafe {
                #[inline(always)]
                fn __static_ref_initialize() -> HashMap<&'static str, (bool, NodeCreateFn)> {
                    {
                        let mut h = HashMap::new();
                        h.insert("a", (true, create_link as NodeCreateFn));
                        h.insert("circle", (true, create_circle as NodeCreateFn));
                        h.insert("clipPath", (true, create_clip_path as NodeCreateFn));
                        h.insert(
                            "conicalGradient",
                            (true, create_radial_gradient as NodeCreateFn),
                        );
                        h.insert("defs", (true, create_defs as NodeCreateFn));
                        h.insert("ellipse", (true, create_ellipse as NodeCreateFn));
                        h.insert("feBlend", (true, create_blend as NodeCreateFn));
                        h.insert("feColorMatrix", (true, create_color_matrix as NodeCreateFn));
                        h.insert(
                            "feComponentTransfer",
                            (true, create_component_transfer as NodeCreateFn),
                        );
                        h.insert("feComposite", (true, create_composite as NodeCreateFn));
                        h.insert(
                            "feConvolveMatrix",
                            (true, create_convolve_matrix as NodeCreateFn),
                        );
                        h.insert(
                            "feDiffuseLighting",
                            (true, create_diffuse_lighting as NodeCreateFn),
                        );
                        h.insert(
                            "feDisplacementMap",
                            (true, create_displacement_map as NodeCreateFn),
                        );
                        h.insert(
                            "feDistantLight",
                            (false, create_distant_light as NodeCreateFn),
                        );
                        h.insert(
                            "feFuncR",
                            (false, create_component_transfer_func_r as NodeCreateFn),
                        );
                        h.insert(
                            "feFuncG",
                            (false, create_component_transfer_func_g as NodeCreateFn),
                        );
                        h.insert(
                            "feFuncB",
                            (false, create_component_transfer_func_b as NodeCreateFn),
                        );
                        h.insert(
                            "feFuncA",
                            (false, create_component_transfer_func_a as NodeCreateFn),
                        );
                        h.insert("feFlood", (true, create_flood as NodeCreateFn));
                        h.insert(
                            "feGaussianBlur",
                            (true, create_gaussian_blur as NodeCreateFn),
                        );
                        h.insert("feImage", (true, create_fe_image as NodeCreateFn));
                        h.insert("feMerge", (true, create_merge as NodeCreateFn));
                        h.insert("feMergeNode", (false, create_merge_node as NodeCreateFn));
                        h.insert("feMorphology", (true, create_morphology as NodeCreateFn));
                        h.insert("feOffset", (true, create_offset as NodeCreateFn));
                        h.insert("fePointLight", (false, create_point_light as NodeCreateFn));
                        h.insert(
                            "feSpecularLighting",
                            (true, create_specular_lighting as NodeCreateFn),
                        );
                        h.insert("feSpotLight", (false, create_spot_light as NodeCreateFn));
                        h.insert("feTile", (true, create_tile as NodeCreateFn));
                        h.insert("feTurbulence", (true, create_turbulence as NodeCreateFn));
                        h.insert("filter", (true, create_filter as NodeCreateFn));
                        h.insert("g", (true, create_group as NodeCreateFn));
                        h.insert("image", (true, create_image as NodeCreateFn));
                        h.insert("line", (true, create_line as NodeCreateFn));
                        h.insert(
                            "linearGradient",
                            (true, create_linear_gradient as NodeCreateFn),
                        );
                        h.insert("marker", (true, create_marker as NodeCreateFn));
                        h.insert("mask", (true, create_mask as NodeCreateFn));
                        h.insert("multiImage", (false, create_switch as NodeCreateFn));
                        h.insert("path", (true, create_path as NodeCreateFn));
                        h.insert("pattern", (true, create_pattern as NodeCreateFn));
                        h.insert("polygon", (true, create_polygon as NodeCreateFn));
                        h.insert("polyline", (true, create_polyline as NodeCreateFn));
                        h.insert(
                            "radialGradient",
                            (true, create_radial_gradient as NodeCreateFn),
                        );
                        h.insert("rect", (true, create_rect as NodeCreateFn));
                        h.insert("stop", (true, create_stop as NodeCreateFn));
                        h.insert("subImage", (false, create_group as NodeCreateFn));
                        h.insert("subImageRef", (false, create_image as NodeCreateFn));
                        h.insert("svg", (true, create_svg as NodeCreateFn));
                        h.insert("switch", (true, create_switch as NodeCreateFn));
                        h.insert("symbol", (true, create_symbol as NodeCreateFn));
                        h.insert("text", (true, create_text as NodeCreateFn));
                        h.insert("tref", (true, create_tref as NodeCreateFn));
                        h.insert("tspan", (true, create_tspan as NodeCreateFn));
                        h.insert("use", (true, create_use as NodeCreateFn));
                        h
                    }
                }
                #[inline(always)]
                unsafe fn __stability() -> &'static HashMap<&'static str, (bool, NodeCreateFn)> {
                    static mut LAZY: ::lazy::Lazy<HashMap<&'static str, (bool, NodeCreateFn)>> =
                        ::lazy::Lazy(
                            0 as *const HashMap<&'static str, (bool, NodeCreateFn)>,
                            ::lazy::ONCE_INIT,
                        );
                    LAZY.get(__static_ref_initialize)
                }
                __stability()
            }
        }
    }
    impl ::LazyStatic for NODE_CREATORS {
        fn initialize(lazy: &Self) {
            let _ = &**lazy;
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_load_new_node(
        raw_name: *const libc::c_char,
        parent: *const RsvgNode,
        pbag: *const PropertyBag,
    ) -> *const RsvgNode {
        if !!raw_name.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_name.is_null()",
                    &("rsvg_internals/src/load.rs", 274u32, 5u32),
                )
            }
        };
        if !!pbag.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !pbag.is_null()",
                    &("rsvg_internals/src/load.rs", 275u32, 5u32),
                )
            }
        };
        let name = unsafe { utf8_cstr(raw_name) };
        let pbag = unsafe { &*pbag };
        let mut id = None;
        let mut class = None;
        for (_key, attr, value) in pbag.iter() {
            match attr {
                Attribute::Id => id = Some(value),
                Attribute::Class => class = Some(value),
                _ => (),
            }
        }
        let &(supports_class, create_fn) = match NODE_CREATORS.get(name) {
            Some(c) => c,
            None => &(true, create_defs as NodeCreateFn),
        };
        if !supports_class {
            class = None;
        };
        create_fn(id, class, parent)
    }
}
mod marker {
    use aspect_ratio::*;
    use attributes::Attribute;
    use cairo::MatrixTrait;
    use cssparser::{CowRcStr, Parser, Token};
    use drawing_ctx::DrawingCtx;
    use error::*;
    use float_eq_cairo::ApproxEqCairo;
    use handle::RsvgHandle;
    use iri::IRI;
    use length::{LengthDir, RsvgLength};
    use node::*;
    use parsers;
    use parsers::ParseError;
    use parsers::{parse, parse_and_validate, Parse};
    use path_builder::*;
    use property_bag::PropertyBag;
    use state::{ComputedValues, SpecifiedValue, State};
    use std::cell::Cell;
    use std::f64::consts::*;
    use viewbox::*;
    #[rustc_copy_clone_marker]
    enum MarkerUnits {
        UserSpaceOnUse,
        StrokeWidth,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkerUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&MarkerUnits::UserSpaceOnUse,) => {
                    let mut debug_trait_builder = f.debug_tuple("UserSpaceOnUse");
                    debug_trait_builder.finish()
                }
                (&MarkerUnits::StrokeWidth,) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeWidth");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for MarkerUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkerUnits {
        #[inline]
        fn clone(&self) -> MarkerUnits {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MarkerUnits {
        #[inline]
        fn eq(&self, other: &MarkerUnits) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for MarkerUnits {
        fn default() -> MarkerUnits {
            MarkerUnits::StrokeWidth
        }
    }
    impl Parse for MarkerUnits {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<MarkerUnits, AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "userSpaceOnUse" => Ok(MarkerUnits::UserSpaceOnUse),
                    "strokeWidth" => Ok(MarkerUnits::StrokeWidth),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(Token::Ident(CowRcStr::from(
                            cow.as_ref().to_string(),
                        ))),
                    ),
                })
                .map_err(|_| {
                    AttributeError::Parse(ParseError::new(
                        "expected \"userSpaceOnUse\" or \"strokeWidth\"",
                    ))
                })
        }
    }
    #[rustc_copy_clone_marker]
    enum MarkerOrient {
        Auto,
        Degrees(f64),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkerOrient {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&MarkerOrient::Auto,) => {
                    let mut debug_trait_builder = f.debug_tuple("Auto");
                    debug_trait_builder.finish()
                }
                (&MarkerOrient::Degrees(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Degrees");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for MarkerOrient {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkerOrient {
        #[inline]
        fn clone(&self) -> MarkerOrient {
            {
                let _: ::std::clone::AssertParamIsClone<f64>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MarkerOrient {
        #[inline]
        fn eq(&self, other: &MarkerOrient) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MarkerOrient::Degrees(ref __self_0),
                            &MarkerOrient::Degrees(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &MarkerOrient) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &MarkerOrient::Degrees(ref __self_0),
                            &MarkerOrient::Degrees(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    impl Default for MarkerOrient {
        fn default() -> MarkerOrient {
            MarkerOrient::Degrees(0.0)
        }
    }
    impl Parse for MarkerOrient {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<MarkerOrient, AttributeError> {
            if parser.try(|p| p.expect_ident_matching("auto")).is_ok() {
                Ok(MarkerOrient::Auto)
            } else {
                parsers::angle_degrees(parser)
                    .map(MarkerOrient::Degrees)
                    .map_err(AttributeError::Parse)
            }
        }
    }
    pub struct NodeMarker {
        units: Cell<MarkerUnits>,
        ref_x: Cell<RsvgLength>,
        ref_y: Cell<RsvgLength>,
        width: Cell<RsvgLength>,
        height: Cell<RsvgLength>,
        orient: Cell<MarkerOrient>,
        aspect: Cell<AspectRatio>,
        vbox: Cell<Option<ViewBox>>,
    }
    impl NodeMarker {
        pub fn new() -> NodeMarker {
            NodeMarker {
                units: Cell::new(MarkerUnits::default()),
                ref_x: Cell::new(RsvgLength::default()),
                ref_y: Cell::new(RsvgLength::default()),
                width: Cell::new(NodeMarker::get_default_size(LengthDir::Horizontal)),
                height: Cell::new(NodeMarker::get_default_size(LengthDir::Vertical)),
                orient: Cell::new(MarkerOrient::default()),
                aspect: Cell::new(AspectRatio::default()),
                vbox: Cell::new(None),
            }
        }
        fn get_default_size(dir: LengthDir) -> RsvgLength {
            RsvgLength::parse_str("3", dir).unwrap()
        }
        fn render(
            &self,
            node: &RsvgNode,
            draw_ctx: &mut DrawingCtx,
            xpos: f64,
            ypos: f64,
            computed_angle: f64,
            line_width: f64,
            clipping: bool,
        ) {
            let cascaded = node.get_cascaded_values();
            let values = cascaded.get();
            let marker_width = self.width.get().normalize(&values, draw_ctx);
            let marker_height = self.height.get().normalize(&values, draw_ctx);
            if marker_width.approx_eq_cairo(&0.0) || marker_height.approx_eq_cairo(&0.0) {
                return;
            }
            let cr = draw_ctx.get_cairo_context();
            cr.save();
            let mut affine = cr.get_matrix();
            affine.translate(xpos, ypos);
            let rotation = match self.orient.get() {
                MarkerOrient::Auto => computed_angle,
                MarkerOrient::Degrees(d) => d * PI / 180.0,
            };
            affine.rotate(rotation);
            if self.units.get() == MarkerUnits::StrokeWidth {
                affine.scale(line_width, line_width);
            }
            if let Some(vbox) = self.vbox.get() {
                let (_, _, w, h) = self.aspect.get().compute(
                    vbox.0.width,
                    vbox.0.height,
                    0.0,
                    0.0,
                    marker_width,
                    marker_height,
                );
                affine.scale(w / vbox.0.width, h / vbox.0.height);
                draw_ctx.push_view_box(vbox.0.width, vbox.0.height);
            } else {
                draw_ctx.push_view_box(marker_width, marker_height);
            }
            affine.translate(
                -self.ref_x.get().normalize(&values, draw_ctx),
                -self.ref_y.get().normalize(&values, draw_ctx),
            );
            cr.set_matrix(affine);
            if !values.is_overflow() {
                if let Some(vbox) = self.vbox.get() {
                    draw_ctx.clip(vbox.0.x, vbox.0.y, vbox.0.width, vbox.0.height);
                } else {
                    draw_ctx.clip(0.0, 0.0, marker_width, marker_height);
                }
            }
            draw_ctx.with_discrete_layer(
                node,
                values,
                clipping,
                &mut (|dc| {
                    node.draw_children(&cascaded, dc, clipping);
                }),
            );
            draw_ctx.pop_view_box();
            cr.restore();
        }
    }
    impl NodeTrait for NodeMarker {
        fn set_atts(
            &self,
            node: &RsvgNode,
            _: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            node.set_overflow_hidden();
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::MarkerUnits => self.units.set(parse("markerUnits", value, ())?),
                    Attribute::RefX => self.ref_x.set(parse("refX", value, LengthDir::Horizontal)?),
                    Attribute::RefY => self.ref_y.set(parse("refY", value, LengthDir::Vertical)?),
                    Attribute::MarkerWidth => self.width.set(parse_and_validate(
                        "markerWidth",
                        value,
                        LengthDir::Horizontal,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::MarkerHeight => self.height.set(parse_and_validate(
                        "markerHeight",
                        value,
                        LengthDir::Vertical,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::Orient => self.orient.set(parse("orient", value, ())?),
                    Attribute::PreserveAspectRatio => {
                        self.aspect.set(parse("preserveAspectRatio", value, ())?)
                    }
                    Attribute::ViewBox => self.vbox.set(Some(parse("viewBox", value, ())?)),
                    _ => (),
                }
            }
            Ok(())
        }
        fn set_overridden_properties(&self, state: &mut State) {
            state.values.display = SpecifiedValue::Specified(Default::default());
        }
    }
    pub enum Segment {
        Degenerate {
            x: f64,
            y: f64,
        },
        LineOrCurve {
            x1: f64,
            y1: f64,
            x2: f64,
            y2: f64,
            x3: f64,
            y3: f64,
            x4: f64,
            y4: f64,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Segment {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Segment::Degenerate {
                    x: ref __self_0,
                    y: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("Degenerate");
                    let _ = debug_trait_builder.field("x", &&(*__self_0));
                    let _ = debug_trait_builder.field("y", &&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&Segment::LineOrCurve {
                    x1: ref __self_0,
                    y1: ref __self_1,
                    x2: ref __self_2,
                    y2: ref __self_3,
                    x3: ref __self_4,
                    y3: ref __self_5,
                    x4: ref __self_6,
                    y4: ref __self_7,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("LineOrCurve");
                    let _ = debug_trait_builder.field("x1", &&(*__self_0));
                    let _ = debug_trait_builder.field("y1", &&(*__self_1));
                    let _ = debug_trait_builder.field("x2", &&(*__self_2));
                    let _ = debug_trait_builder.field("y2", &&(*__self_3));
                    let _ = debug_trait_builder.field("x3", &&(*__self_4));
                    let _ = debug_trait_builder.field("y3", &&(*__self_5));
                    let _ = debug_trait_builder.field("x4", &&(*__self_6));
                    let _ = debug_trait_builder.field("y4", &&(*__self_7));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Segment {
        #[inline]
        fn eq(&self, other: &Segment) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Segment::Degenerate {
                                x: ref __self_0,
                                y: ref __self_1,
                            },
                            &Segment::Degenerate {
                                x: ref __arg_1_0,
                                y: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &Segment::LineOrCurve {
                                x1: ref __self_0,
                                y1: ref __self_1,
                                x2: ref __self_2,
                                y2: ref __self_3,
                                x3: ref __self_4,
                                y3: ref __self_5,
                                x4: ref __self_6,
                                y4: ref __self_7,
                            },
                            &Segment::LineOrCurve {
                                x1: ref __arg_1_0,
                                y1: ref __arg_1_1,
                                x2: ref __arg_1_2,
                                y2: ref __arg_1_3,
                                x3: ref __arg_1_4,
                                y3: ref __arg_1_5,
                                x4: ref __arg_1_6,
                                y4: ref __arg_1_7,
                            },
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                                && (*__self_3) == (*__arg_1_3)
                                && (*__self_4) == (*__arg_1_4)
                                && (*__self_5) == (*__arg_1_5)
                                && (*__self_6) == (*__arg_1_6)
                                && (*__self_7) == (*__arg_1_7)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Segment) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &Segment::Degenerate {
                                x: ref __self_0,
                                y: ref __self_1,
                            },
                            &Segment::Degenerate {
                                x: ref __arg_1_0,
                                y: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &Segment::LineOrCurve {
                                x1: ref __self_0,
                                y1: ref __self_1,
                                x2: ref __self_2,
                                y2: ref __self_3,
                                x3: ref __self_4,
                                y3: ref __self_5,
                                x4: ref __self_6,
                                y4: ref __self_7,
                            },
                            &Segment::LineOrCurve {
                                x1: ref __arg_1_0,
                                y1: ref __arg_1_1,
                                x2: ref __arg_1_2,
                                y2: ref __arg_1_3,
                                x3: ref __arg_1_4,
                                y3: ref __arg_1_5,
                                x4: ref __arg_1_6,
                                y4: ref __arg_1_7,
                            },
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                                || (*__self_3) != (*__arg_1_3)
                                || (*__self_4) != (*__arg_1_4)
                                || (*__self_5) != (*__arg_1_5)
                                || (*__self_6) != (*__arg_1_6)
                                || (*__self_7) != (*__arg_1_7)
                        }
                        _ => unsafe { ::std::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    enum SegmentState {
        Initial,
        NewSubpath,
        InSubpath,
        ClosedSubpath,
    }
    fn make_degenerate(x: f64, y: f64) -> Segment {
        Segment::Degenerate { x, y }
    }
    fn make_curve(
        x1: f64,
        y1: f64,
        x2: f64,
        y2: f64,
        x3: f64,
        y3: f64,
        x4: f64,
        y4: f64,
    ) -> Segment {
        Segment::LineOrCurve {
            x1,
            y1,
            x2,
            y2,
            x3,
            y3,
            x4,
            y4,
        }
    }
    fn make_line(x1: f64, y1: f64, x2: f64, y2: f64) -> Segment {
        make_curve(x1, y1, x2, y2, x1, y1, x2, y2)
    }
    pub fn path_builder_to_segments(builder: &PathBuilder) -> Vec<Segment> {
        let mut last_x: f64;
        let mut last_y: f64;
        let mut cur_x: f64;
        let mut cur_y: f64;
        let mut subpath_start_x: f64;
        let mut subpath_start_y: f64;
        let mut segments: Vec<Segment>;
        let mut state: SegmentState;
        cur_x = 0.0;
        cur_y = 0.0;
        subpath_start_x = 0.0;
        subpath_start_y = 0.0;
        segments = Vec::new();
        state = SegmentState::Initial;
        for path_command in builder.get_path_commands() {
            last_x = cur_x;
            last_y = cur_y;
            match *path_command {
                PathCommand::MoveTo(x, y) => {
                    cur_x = x;
                    cur_y = y;
                    subpath_start_x = cur_x;
                    subpath_start_y = cur_y;
                    match state {
                        SegmentState::Initial | SegmentState::InSubpath => {
                            state = SegmentState::NewSubpath;
                        }
                        SegmentState::NewSubpath => {
                            segments.push(make_degenerate(last_x, last_y));
                            state = SegmentState::NewSubpath;
                        }
                        SegmentState::ClosedSubpath => {
                            state = SegmentState::Initial;
                        }
                    }
                }
                PathCommand::LineTo(x, y) => {
                    cur_x = x;
                    cur_y = y;
                    segments.push(make_line(last_x, last_y, cur_x, cur_y));
                    state = SegmentState::InSubpath;
                }
                PathCommand::CurveTo((x2, y2), (x3, y3), (x4, y4)) => {
                    cur_x = x4;
                    cur_y = y4;
                    segments.push(make_curve(last_x, last_y, x2, y2, x3, y3, cur_x, cur_y));
                    state = SegmentState::InSubpath;
                }
                PathCommand::ClosePath => {
                    cur_x = subpath_start_x;
                    cur_y = subpath_start_y;
                    segments.push(make_line(last_x, last_y, cur_x, cur_y));
                    state = SegmentState::ClosedSubpath;
                }
            }
        }
        if let SegmentState::NewSubpath = state {
            segments.push(make_degenerate(cur_x, cur_y));
        };
        segments
    }
    fn points_equal(x1: f64, y1: f64, x2: f64, y2: f64) -> bool {
        x1.approx_eq_cairo(&x2) && y1.approx_eq_cairo(&y2)
    }
    fn get_segment_directionalities(segment: &Segment) -> Option<(f64, f64, f64, f64)> {
        match *segment {
            Segment::Degenerate { .. } => None,
            Segment::LineOrCurve {
                x1,
                y1,
                x2,
                y2,
                x3,
                y3,
                x4,
                y4,
            } => {
                let coincide_1_and_2 = points_equal(x1, y1, x2, y2);
                let coincide_1_and_3 = points_equal(x1, y1, x3, y3);
                let coincide_1_and_4 = points_equal(x1, y1, x4, y4);
                let coincide_2_and_3 = points_equal(x2, y2, x3, y3);
                let coincide_2_and_4 = points_equal(x2, y2, x4, y4);
                let coincide_3_and_4 = points_equal(x3, y3, x4, y4);
                if coincide_1_and_2 && coincide_1_and_3 && coincide_1_and_4 {
                    None
                } else if coincide_1_and_2 && coincide_1_and_3 {
                    Some((x4 - x1, y4 - y1, x4 - x3, y4 - y3))
                } else if coincide_1_and_2 && coincide_3_and_4 {
                    Some((x4 - x1, y4 - y1, x4 - x1, y4 - y1))
                } else if coincide_2_and_3 && coincide_2_and_4 {
                    Some((x2 - x1, y2 - y1, x4 - x1, y4 - y1))
                } else if coincide_1_and_2 {
                    Some((x3 - x1, y3 - y1, x4 - x3, y4 - y3))
                } else if coincide_3_and_4 {
                    Some((x2 - x1, y2 - y1, x4 - x2, y4 - y2))
                } else {
                    Some((x2 - x1, y2 - y1, x4 - x3, y4 - y3))
                }
            }
        }
    }
    fn find_incoming_directionality_backwards(
        segments: &[Segment],
        start_index: usize,
    ) -> (bool, f64, f64) {
        for segment in segments[..start_index + 1].iter().rev() {
            match *segment {
                Segment::Degenerate { .. } => {
                    return (false, 0.0, 0.0);
                }
                Segment::LineOrCurve { .. } => match get_segment_directionalities(segment) {
                    Some((_, _, v2x, v2y)) => {
                        return (true, v2x, v2y);
                    }
                    None => {
                        continue;
                    }
                },
            }
        }
        (false, 0.0, 0.0)
    }
    fn find_outgoing_directionality_forwards(
        segments: &[Segment],
        start_index: usize,
    ) -> (bool, f64, f64) {
        for segment in &segments[start_index..] {
            match *segment {
                Segment::Degenerate { .. } => {
                    return (false, 0.0, 0.0);
                }
                Segment::LineOrCurve { .. } => match get_segment_directionalities(segment) {
                    Some((v1x, v1y, _, _)) => {
                        return (true, v1x, v1y);
                    }
                    None => {
                        continue;
                    }
                },
            }
        }
        (false, 0.0, 0.0)
    }
    fn normalize_angle(mut angle: f64) -> f64 {
        if angle < 0.0 {
            while angle < 0.0 {
                angle += PI * 2.0;
            }
        } else {
            while angle > PI * 2.0 {
                angle -= PI * 2.0;
            }
        }
        angle
    }
    fn angle_from_vector(vx: f64, vy: f64) -> f64 {
        let angle = vy.atan2(vx);
        if angle.is_nan() {
            0.0
        } else {
            normalize_angle(angle)
        }
    }
    fn bisect_angles(incoming: f64, outgoing: f64) -> f64 {
        let half_delta: f64;
        half_delta = (outgoing - incoming) * 0.5;
        if FRAC_PI_2 < half_delta.abs() {
            normalize_angle(incoming + half_delta - PI)
        } else {
            normalize_angle(incoming + half_delta)
        }
    }
    #[rustc_copy_clone_marker]
    enum MarkerType {
        Start,
        Middle,
        End,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkerType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&MarkerType::Start,) => {
                    let mut debug_trait_builder = f.debug_tuple("Start");
                    debug_trait_builder.finish()
                }
                (&MarkerType::Middle,) => {
                    let mut debug_trait_builder = f.debug_tuple("Middle");
                    debug_trait_builder.finish()
                }
                (&MarkerType::End,) => {
                    let mut debug_trait_builder = f.debug_tuple("End");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for MarkerType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkerType {
        #[inline]
        fn clone(&self) -> MarkerType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MarkerType {
        #[inline]
        fn eq(&self, other: &MarkerType) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    fn emit_marker_by_name(
        draw_ctx: &mut DrawingCtx,
        name: &str,
        xpos: f64,
        ypos: f64,
        computed_angle: f64,
        line_width: f64,
        clipping: bool,
    ) {
        if let Some(acquired) = draw_ctx.get_acquired_node_of_type(Some(name), NodeType::Marker) {
            let node = acquired.get();
            node.with_impl(|marker: &NodeMarker| {
                marker.render(
                    &node,
                    draw_ctx,
                    xpos,
                    ypos,
                    computed_angle,
                    line_width,
                    clipping,
                )
            });
        }
    }
    #[rustc_copy_clone_marker]
    enum MarkerEndpoint {
        Start,
        End,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkerEndpoint {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&MarkerEndpoint::Start,) => {
                    let mut debug_trait_builder = f.debug_tuple("Start");
                    debug_trait_builder.finish()
                }
                (&MarkerEndpoint::End,) => {
                    let mut debug_trait_builder = f.debug_tuple("End");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for MarkerEndpoint {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkerEndpoint {
        #[inline]
        fn clone(&self) -> MarkerEndpoint {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MarkerEndpoint {
        #[inline]
        fn eq(&self, other: &MarkerEndpoint) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    fn emit_marker<E>(
        segment: &Segment,
        endpoint: MarkerEndpoint,
        marker_type: MarkerType,
        orient: f64,
        emit_fn: &mut E,
    ) where
        E: FnMut(MarkerType, f64, f64, f64),
    {
        let (x, y) = match *segment {
            Segment::Degenerate { x, y } => (x, y),
            Segment::LineOrCurve { x1, y1, x4, y4, .. } => match endpoint {
                MarkerEndpoint::Start => (x1, y1),
                MarkerEndpoint::End => (x4, y4),
            },
        };
        emit_fn(marker_type, x, y, orient);
    }
    pub fn render_markers_for_path_builder(
        builder: &PathBuilder,
        draw_ctx: &mut DrawingCtx,
        values: &ComputedValues,
        clipping: bool,
    ) {
        let line_width = values.stroke_width.0.normalize(values, draw_ctx);
        if line_width.approx_eq_cairo(&0.0) {
            return;
        }
        let marker_start = &values.marker_start.0;
        let marker_mid = &values.marker_mid.0;
        let marker_end = &values.marker_end.0;
        match (marker_start, marker_mid, marker_end) {
            (&IRI::None, &IRI::None, &IRI::None) => return,
            _ => (),
        }
        emit_markers_for_path_builder(
            builder,
            &mut (|marker_type: MarkerType, x: f64, y: f64, computed_angle: f64| {
                if let &IRI::Resource(ref marker) = match marker_type {
                    MarkerType::Start => &values.marker_start.0,
                    MarkerType::Middle => &values.marker_mid.0,
                    MarkerType::End => &values.marker_end.0,
                } {
                    emit_marker_by_name(
                        draw_ctx,
                        &marker,
                        x,
                        y,
                        computed_angle,
                        line_width,
                        clipping,
                    );
                }
            }),
        );
    }
    fn emit_markers_for_path_builder<E>(builder: &PathBuilder, emit_fn: &mut E)
    where
        E: FnMut(MarkerType, f64, f64, f64),
    {
        enum SubpathState {
            NoSubpath,
            InSubpath,
        }
        let segments = path_builder_to_segments(builder);
        let mut subpath_state = SubpathState::NoSubpath;
        for (i, segment) in segments.iter().enumerate() {
            match *segment {
                Segment::Degenerate { .. } => {
                    if let SubpathState::InSubpath = subpath_state {
                        if !(i > 0) {
                            {
                                ::rt::begin_panic(
                                    "assertion failed: i > 0",
                                    &("rsvg_internals/src/marker.rs", 698u32, 21u32),
                                )
                            }
                        };
                        let (_, incoming_vx, incoming_vy) =
                            find_incoming_directionality_backwards(&segments, i - 1);
                        emit_marker(
                            &segments[i - 1],
                            MarkerEndpoint::End,
                            MarkerType::End,
                            angle_from_vector(incoming_vx, incoming_vy),
                            emit_fn,
                        );
                    }
                    emit_marker(
                        segment,
                        MarkerEndpoint::Start,
                        MarkerType::Middle,
                        0.0,
                        emit_fn,
                    );
                    subpath_state = SubpathState::NoSubpath;
                }
                Segment::LineOrCurve { .. } => match subpath_state {
                    SubpathState::NoSubpath => {
                        let (_, outgoing_vx, outgoing_vy) =
                            find_outgoing_directionality_forwards(&segments, i);
                        emit_marker(
                            segment,
                            MarkerEndpoint::Start,
                            MarkerType::Start,
                            angle_from_vector(outgoing_vx, outgoing_vy),
                            emit_fn,
                        );
                        subpath_state = SubpathState::InSubpath;
                    }
                    SubpathState::InSubpath => {
                        if !(i > 0) {
                            {
                                ::rt::begin_panic(
                                    "assertion failed: i > 0",
                                    &("rsvg_internals/src/marker.rs", 742u32, 25u32),
                                )
                            }
                        };
                        let (has_incoming, incoming_vx, incoming_vy) =
                            find_incoming_directionality_backwards(&segments, i - 1);
                        let (has_outgoing, outgoing_vx, outgoing_vy) =
                            find_outgoing_directionality_forwards(&segments, i);
                        let incoming: f64;
                        let outgoing: f64;
                        incoming = angle_from_vector(incoming_vx, incoming_vy);
                        outgoing = angle_from_vector(outgoing_vx, outgoing_vy);
                        let angle: f64;
                        if has_incoming && has_outgoing {
                            angle = bisect_angles(incoming, outgoing);
                        } else if has_incoming {
                            angle = incoming;
                        } else if has_outgoing {
                            angle = outgoing;
                        } else {
                            angle = 0.0;
                        }
                        emit_marker(
                            segment,
                            MarkerEndpoint::Start,
                            MarkerType::Middle,
                            angle,
                            emit_fn,
                        );
                    }
                },
            }
        }
        if !segments.is_empty() {
            let segment = &segments[segments.len() - 1];
            if let Segment::LineOrCurve { .. } = *segment {
                let (_, incoming_vx, incoming_vy) =
                    find_incoming_directionality_backwards(&segments, segments.len() - 1);
                let angle = {
                    if let PathCommand::ClosePath = builder.get_path_commands()[segments.len()] {
                        let (_, outgoing_vx, outgoing_vy) =
                            find_outgoing_directionality_forwards(&segments, 0);
                        bisect_angles(
                            angle_from_vector(incoming_vx, incoming_vy),
                            angle_from_vector(outgoing_vx, outgoing_vy),
                        )
                    } else {
                        angle_from_vector(incoming_vx, incoming_vy)
                    }
                };
                emit_marker(
                    segment,
                    MarkerEndpoint::End,
                    MarkerType::End,
                    angle,
                    emit_fn,
                );
            }
        }
    }
}
mod mask {
    use attributes::Attribute;
    use cairo::{self, MatrixTrait};
    use cairo_sys;
    use coord_units::CoordUnits;
    use drawing_ctx::DrawingCtx;
    use glib::translate::*;
    use handle::RsvgHandle;
    use length::{LengthDir, RsvgLength};
    use node::{NodeResult, NodeTrait, RsvgNode};
    use parsers::{parse, parse_and_validate, Parse};
    use property_bag::PropertyBag;
    use state::Opacity;
    use std::cell::Cell;
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct MaskUnits(pub CoordUnits);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MaskUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                MaskUnits(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("MaskUnits");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for MaskUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MaskUnits {
        #[inline]
        fn clone(&self) -> MaskUnits {
            {
                let _: ::std::clone::AssertParamIsClone<CoordUnits>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MaskUnits {
        #[inline]
        fn eq(&self, other: &MaskUnits) -> bool {
            match *other {
                MaskUnits(ref __self_1_0) => match *self {
                    MaskUnits(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MaskUnits) -> bool {
            match *other {
                MaskUnits(ref __self_1_0) => match *self {
                    MaskUnits(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for MaskUnits {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<CoordUnits>;
            }
        }
    }
    impl Default for MaskUnits {
        fn default() -> Self {
            MaskUnits(CoordUnits::ObjectBoundingBox)
        }
    }
    impl From<MaskUnits> for CoordUnits {
        fn from(u: MaskUnits) -> Self {
            u.0
        }
    }
    impl ::parsers::Parse for MaskUnits {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(parser: &mut ::cssparser::Parser, _: ()) -> Result<Self, ::error::AttributeError> {
            Ok(MaskUnits(::coord_units::CoordUnits::parse(parser, ())?))
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct MaskContentUnits(pub CoordUnits);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MaskContentUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                MaskContentUnits(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("MaskContentUnits");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for MaskContentUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MaskContentUnits {
        #[inline]
        fn clone(&self) -> MaskContentUnits {
            {
                let _: ::std::clone::AssertParamIsClone<CoordUnits>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MaskContentUnits {
        #[inline]
        fn eq(&self, other: &MaskContentUnits) -> bool {
            match *other {
                MaskContentUnits(ref __self_1_0) => match *self {
                    MaskContentUnits(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MaskContentUnits) -> bool {
            match *other {
                MaskContentUnits(ref __self_1_0) => match *self {
                    MaskContentUnits(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for MaskContentUnits {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<CoordUnits>;
            }
        }
    }
    impl Default for MaskContentUnits {
        fn default() -> Self {
            MaskContentUnits(CoordUnits::UserSpaceOnUse)
        }
    }
    impl From<MaskContentUnits> for CoordUnits {
        fn from(u: MaskContentUnits) -> Self {
            u.0
        }
    }
    impl ::parsers::Parse for MaskContentUnits {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(parser: &mut ::cssparser::Parser, _: ()) -> Result<Self, ::error::AttributeError> {
            Ok(MaskContentUnits(::coord_units::CoordUnits::parse(
                parser,
                (),
            )?))
        }
    }
    fn cairo_mask_surface(cr: &cairo::Context, surface: &cairo::Surface, x: f64, y: f64) {
        unsafe {
            let raw_cr = cr.to_glib_none().0;
            cairo_sys::cairo_mask_surface(raw_cr, surface.to_raw_none(), x, y);
        }
    }
    pub struct NodeMask {
        x: Cell<RsvgLength>,
        y: Cell<RsvgLength>,
        width: Cell<RsvgLength>,
        height: Cell<RsvgLength>,
        units: Cell<MaskUnits>,
        content_units: Cell<MaskContentUnits>,
    }
    impl NodeMask {
        pub fn new() -> NodeMask {
            NodeMask {
                x: Cell::new(NodeMask::get_default_pos(LengthDir::Horizontal)),
                y: Cell::new(NodeMask::get_default_pos(LengthDir::Vertical)),
                width: Cell::new(NodeMask::get_default_size(LengthDir::Horizontal)),
                height: Cell::new(NodeMask::get_default_size(LengthDir::Vertical)),
                units: Cell::new(MaskUnits::default()),
                content_units: Cell::new(MaskContentUnits::default()),
            }
        }
        fn get_default_pos(dir: LengthDir) -> RsvgLength {
            RsvgLength::parse_str("-10%", dir).unwrap()
        }
        fn get_default_size(dir: LengthDir) -> RsvgLength {
            RsvgLength::parse_str("120%", dir).unwrap()
        }
        pub fn generate_cairo_mask(
            &self,
            node: &RsvgNode,
            affine_before_mask: &cairo::Matrix,
            draw_ctx: &mut DrawingCtx,
        ) {
            let cascaded = node.get_cascaded_values();
            let values = cascaded.get();
            let width = draw_ctx.get_width() as i32;
            let height = draw_ctx.get_height() as i32;
            let mut surface =
                match cairo::ImageSurface::create(cairo::Format::ARgb32, width, height) {
                    Ok(surface) => surface,
                    Err(_) => return,
                };
            let mask_units = CoordUnits::from(self.units.get());
            let content_units = CoordUnits::from(self.content_units.get());
            if mask_units == CoordUnits::ObjectBoundingBox {
                draw_ctx.push_view_box(1.0, 1.0);
            }
            let x = self.x.get().normalize(&values, draw_ctx);
            let y = self.y.get().normalize(&values, draw_ctx);
            let w = self.width.get().normalize(&values, draw_ctx);
            let h = self.height.get().normalize(&values, draw_ctx);
            if mask_units == CoordUnits::ObjectBoundingBox {
                draw_ctx.pop_view_box();
            }
            {
                let save_cr = draw_ctx.get_cairo_context();
                let mask_cr = cairo::Context::new(&surface);
                mask_cr.set_matrix(*affine_before_mask);
                mask_cr.transform(node.get_transform());
                draw_ctx.set_cairo_context(&mask_cr);
                if mask_units == CoordUnits::ObjectBoundingBox {
                    let rect = {
                        let bbox = draw_ctx.get_bbox();
                        bbox.rect.unwrap()
                    };
                    draw_ctx.clip(
                        x * rect.width + rect.x,
                        y * rect.height + rect.y,
                        w * rect.width,
                        h * rect.height,
                    );
                } else {
                    draw_ctx.clip(x, y, w, h);
                }
                if content_units == CoordUnits::ObjectBoundingBox {
                    let rect = {
                        let bbox = draw_ctx.get_bbox();
                        bbox.rect.unwrap()
                    };
                    let bbtransform =
                        cairo::Matrix::new(rect.width, 0.0, 0.0, rect.height, rect.x, rect.y);
                    mask_cr.transform(bbtransform);
                    draw_ctx.push_view_box(1.0, 1.0);
                }
                draw_ctx.with_discrete_layer(
                    node,
                    values,
                    false,
                    &mut (|dc| {
                        node.draw_children(&cascaded, dc, false);
                    }),
                );
                if content_units == CoordUnits::ObjectBoundingBox {
                    draw_ctx.pop_view_box();
                }
                draw_ctx.set_cairo_context(&save_cr);
            }
            {
                let rowstride = surface.get_stride() as usize;
                let mut pixels = surface.get_data().unwrap();
                let opacity = {
                    let Opacity(o) = values.opacity;
                    u8::from(o)
                };
                for row in pixels.chunks_mut(rowstride) {
                    for p in row[..4 * width as usize].chunks_mut(4) {
                        let (r, g, b, o) = (p[2] as u32, p[1] as u32, p[0] as u32, opacity as u32);
                        p[3] = (((r * 14042 + g * 47240 + b * 4769) * o) >> 24) as u8;
                    }
                }
            }
            let cr = draw_ctx.get_cairo_context();
            cr.identity_matrix();
            let (xofs, yofs) = draw_ctx.get_offset();
            cairo_mask_surface(&cr, &surface, xofs, yofs);
        }
    }
    impl NodeTrait for NodeMask {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::X => self.x.set(parse("x", value, LengthDir::Horizontal)?),
                    Attribute::Y => self.y.set(parse("y", value, LengthDir::Vertical)?),
                    Attribute::Width => self.width.set(parse_and_validate(
                        "width",
                        value,
                        LengthDir::Horizontal,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::Height => self.height.set(parse_and_validate(
                        "height",
                        value,
                        LengthDir::Vertical,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::MaskUnits => self.units.set(parse("maskUnits", value, ())?),
                    Attribute::MaskContentUnits => {
                        self.content_units
                            .set(parse("maskContentUnits", value, ())?)
                    }
                    _ => (),
                }
            }
            Ok(())
        }
    }
}
mod node {
    use attributes::Attribute;
    use cairo::{Matrix, MatrixTrait};
    use cond::{RequiredExtensions, RequiredFeatures, SystemLanguage};
    use defs::{self, RsvgDefs};
    use downcast_rs::*;
    use drawing_ctx::DrawingCtx;
    use error::*;
    use glib;
    use glib::translate::*;
    use glib_sys;
    use handle::RsvgHandle;
    use libc;
    use parsers::{Parse, ParseError};
    use property_bag::PropertyBag;
    use state::{
        self, rsvg_state_new, ComputedValues, Overflow, RsvgState, SpecifiedValue, SpecifiedValues,
        State,
    };
    use std::cell::{Cell, Ref, RefCell};
    use std::ptr;
    use std::rc::{Rc, Weak};
    use std::str::FromStr;
    use util::utf8_cstr;
    pub type RsvgNode = Rc<Node>;
    pub enum RsvgCNodeImpl {}
    /// Can obtain computed values from a node
    ///
    /// In our tree of SVG elements (Node in our parlance), each node stores a `ComputedValues` that
    /// gets computed during the initial CSS cascade.  However, sometimes nodes need to be rendered
    /// outside the normal hierarchy.  For example, the `<use>` element can "instance" a subtree from
    /// elsewhere in the SVG; it causes the instanced subtree to re-cascade from the computed values for
    /// the `<use>` element.
    ///
    /// This structure gets created by `Node.get_cascaded_values()`.  You can then call the `get()`
    /// method on the resulting `CascadedValues` to get a `&ComputedValues` whose fields you can access.
    pub struct CascadedValues<'a> {
        inner: CascadedInner<'a>,
    }
    enum CascadedInner<'a> {
        FromNode(Ref<'a, ComputedValues>),
        FromValues(ComputedValues),
    }
    impl<'a> CascadedValues<'a> {
        /// Creates a `CascadedValues` that has the same cascading mode as &self
        ///
        /// This is what nodes should normally use to draw their children from their `draw()` method.
        /// Nodes that need to override the cascade for their children can use `new_from_values()`
        /// instead.
        pub fn new(&self, node: &'a Node) -> CascadedValues<'a> {
            match self.inner {
                CascadedInner::FromNode(_) => CascadedValues {
                    inner: CascadedInner::FromNode(node.values.borrow()),
                },
                CascadedInner::FromValues(ref v) => CascadedValues::new_from_values(node, v),
            }
        }
        /// Creates a `CascadedValues` that will hold the `node`'s computed values
        ///
        /// This is to be used only in the toplevel drawing function, or in elements like `<marker>`
        /// that don't propagate their parent's cascade to their children.  All others should use
        /// `new()` to derive the cascade from an existing one.
        fn new_from_node(node: &Node) -> CascadedValues {
            CascadedValues {
                inner: CascadedInner::FromNode(node.values.borrow()),
            }
        }
        /// Creates a `CascadedValues` that will override the `node`'s cascade with the specified
        /// `values`
        ///
        /// This is for the `<use>` element, which draws the element which it references with the
        /// `<use>`'s own cascade, not wih the element's original cascade.
        pub fn new_from_values(node: &'a Node, values: &ComputedValues) -> CascadedValues<'a> {
            let mut v = values.clone();
            node.get_specified_values().to_computed_values(&mut v);
            CascadedValues {
                inner: CascadedInner::FromValues(v),
            }
        }
        /// Returns the cascaded `ComputedValues`.
        ///
        /// Nodes should use this from their `NodeTrait::draw()` implementation to get the
        /// `ComputedValues` from the `CascadedValues` that got passed to `draw()`.
        pub fn get(&'a self) -> &'a ComputedValues {
            match self.inner {
                CascadedInner::FromNode(ref r) => &*r,
                CascadedInner::FromValues(ref v) => v,
            }
        }
    }
    /// The basic trait that all nodes must implement
    pub trait NodeTrait: Downcast {
        /// Sets per-node attributes from the `pbag`
        ///
        /// Each node is supposed to iterate the `pbag`, and parse any attributes it needs.
        fn set_atts(
            &self,
            node: &RsvgNode,
            handle: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult;
        /// Sets any special-cased properties that the node may have, that are different
        /// from defaults in the node's `State`.
        fn set_overridden_properties(&self, _state: &mut State) {}
        fn draw(
            &self,
            _node: &RsvgNode,
            _cascaded: &CascadedValues,
            _draw_ctx: &mut DrawingCtx,
            _clipping: bool,
        ) {
        }
        fn get_c_impl(&self) -> *const RsvgCNodeImpl {
            {
                {
                    ::rt::begin_panic(
                        "internal error: entered unreachable code",
                        &("rsvg_internals/src/node.rs", 141u32, 9u32),
                    )
                }
            };
        }
    }
    impl NodeTrait {
        /// Returns true if the trait object wraps an object of type `__T`.
        #[inline]
        pub fn is<__T: NodeTrait>(&self) -> bool {
            ::Downcast::as_any(self).is::<__T>()
        }
        /// Returns a boxed object from a boxed trait object if the underlying object is of type
        /// `__T`. Returns the original boxed trait if it isn't.
        #[inline]
        pub fn downcast<__T: NodeTrait>(
            self: ::std::boxed::Box<Self>,
        ) -> ::std::result::Result<::std::boxed::Box<__T>, ::std::boxed::Box<Self>> {
            if self.is::<__T>() {
                Ok(::Downcast::into_any(self).downcast::<__T>().unwrap())
            } else {
                Err(self)
            }
        }
        /// Returns a reference to the object within the trait object if it is of type `__T`, or
        /// `None` if it isn't.
        #[inline]
        pub fn downcast_ref<__T: NodeTrait>(&self) -> ::std::option::Option<&__T> {
            ::Downcast::as_any(self).downcast_ref::<__T>()
        }
        /// Returns a mutable reference to the object within the trait object if it is of type
        /// `__T`, or `None` if it isn't.
        #[inline]
        pub fn downcast_mut<__T: NodeTrait>(&mut self) -> ::std::option::Option<&mut __T> {
            ::Downcast::as_any_mut(self).downcast_mut::<__T>()
        }
    }
    pub type NodeResult = Result<(), NodeError>;
    pub struct Node {
        node_type: NodeType,
        parent: Option<Weak<Node>>,
        id: Option<String>,
        class: Option<String>,
        first_child: RefCell<Option<Rc<Node>>>,
        last_child: RefCell<Option<Weak<Node>>>,
        next_sib: RefCell<Option<Rc<Node>>>,
        prev_sib: RefCell<Option<Weak<Node>>>,
        state: *mut RsvgState,
        result: RefCell<NodeResult>,
        transform: Cell<Matrix>,
        values: RefCell<ComputedValues>,
        cond: Cell<bool>,
        node_impl: Box<NodeTrait>,
    }
    pub struct Children {
        next: Option<Rc<Node>>,
        next_back: Option<Rc<Node>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Children {
        #[inline]
        fn clone(&self) -> Children {
            match *self {
                Children {
                    next: ref __self_0_0,
                    next_back: ref __self_0_1,
                } => Children {
                    next: ::std::clone::Clone::clone(&(*__self_0_0)),
                    next_back: ::std::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[repr(C)]
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub enum NodeType {
        Invalid = 0,
        Chars,
        Circle,
        ClipPath,
        ComponentTransferFunction,
        Defs,
        Ellipse,
        Filter,
        Group,
        Image,
        LightSource,
        Line,
        LinearGradient,
        Link,
        Marker,
        Mask,
        Path,
        Pattern,
        Polygon,
        Polyline,
        RadialGradient,
        Rect,
        Stop,
        Svg,
        Switch,
        Symbol,
        Text,
        TRef,
        TSpan,
        Use,
        FilterPrimitiveFirst,
        FilterPrimitiveBlend,
        FilterPrimitiveColorMatrix,
        FilterPrimitiveComponentTransfer,
        FilterPrimitiveComposite,
        FilterPrimitiveConvolveMatrix,
        FilterPrimitiveDiffuseLighting,
        FilterPrimitiveDisplacementMap,
        FilterPrimitiveFlood,
        FilterPrimitiveGaussianBlur,
        FilterPrimitiveImage,
        FilterPrimitiveMerge,
        FilterPrimitiveMergeNode,
        FilterPrimitiveMorphology,
        FilterPrimitiveOffset,
        FilterPrimitiveSpecularLighting,
        FilterPrimitiveTile,
        FilterPrimitiveTurbulence,
        FilterPrimitiveLast,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for NodeType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&NodeType::Invalid,) => {
                    let mut debug_trait_builder = f.debug_tuple("Invalid");
                    debug_trait_builder.finish()
                }
                (&NodeType::Chars,) => {
                    let mut debug_trait_builder = f.debug_tuple("Chars");
                    debug_trait_builder.finish()
                }
                (&NodeType::Circle,) => {
                    let mut debug_trait_builder = f.debug_tuple("Circle");
                    debug_trait_builder.finish()
                }
                (&NodeType::ClipPath,) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipPath");
                    debug_trait_builder.finish()
                }
                (&NodeType::ComponentTransferFunction,) => {
                    let mut debug_trait_builder = f.debug_tuple("ComponentTransferFunction");
                    debug_trait_builder.finish()
                }
                (&NodeType::Defs,) => {
                    let mut debug_trait_builder = f.debug_tuple("Defs");
                    debug_trait_builder.finish()
                }
                (&NodeType::Ellipse,) => {
                    let mut debug_trait_builder = f.debug_tuple("Ellipse");
                    debug_trait_builder.finish()
                }
                (&NodeType::Filter,) => {
                    let mut debug_trait_builder = f.debug_tuple("Filter");
                    debug_trait_builder.finish()
                }
                (&NodeType::Group,) => {
                    let mut debug_trait_builder = f.debug_tuple("Group");
                    debug_trait_builder.finish()
                }
                (&NodeType::Image,) => {
                    let mut debug_trait_builder = f.debug_tuple("Image");
                    debug_trait_builder.finish()
                }
                (&NodeType::LightSource,) => {
                    let mut debug_trait_builder = f.debug_tuple("LightSource");
                    debug_trait_builder.finish()
                }
                (&NodeType::Line,) => {
                    let mut debug_trait_builder = f.debug_tuple("Line");
                    debug_trait_builder.finish()
                }
                (&NodeType::LinearGradient,) => {
                    let mut debug_trait_builder = f.debug_tuple("LinearGradient");
                    debug_trait_builder.finish()
                }
                (&NodeType::Link,) => {
                    let mut debug_trait_builder = f.debug_tuple("Link");
                    debug_trait_builder.finish()
                }
                (&NodeType::Marker,) => {
                    let mut debug_trait_builder = f.debug_tuple("Marker");
                    debug_trait_builder.finish()
                }
                (&NodeType::Mask,) => {
                    let mut debug_trait_builder = f.debug_tuple("Mask");
                    debug_trait_builder.finish()
                }
                (&NodeType::Path,) => {
                    let mut debug_trait_builder = f.debug_tuple("Path");
                    debug_trait_builder.finish()
                }
                (&NodeType::Pattern,) => {
                    let mut debug_trait_builder = f.debug_tuple("Pattern");
                    debug_trait_builder.finish()
                }
                (&NodeType::Polygon,) => {
                    let mut debug_trait_builder = f.debug_tuple("Polygon");
                    debug_trait_builder.finish()
                }
                (&NodeType::Polyline,) => {
                    let mut debug_trait_builder = f.debug_tuple("Polyline");
                    debug_trait_builder.finish()
                }
                (&NodeType::RadialGradient,) => {
                    let mut debug_trait_builder = f.debug_tuple("RadialGradient");
                    debug_trait_builder.finish()
                }
                (&NodeType::Rect,) => {
                    let mut debug_trait_builder = f.debug_tuple("Rect");
                    debug_trait_builder.finish()
                }
                (&NodeType::Stop,) => {
                    let mut debug_trait_builder = f.debug_tuple("Stop");
                    debug_trait_builder.finish()
                }
                (&NodeType::Svg,) => {
                    let mut debug_trait_builder = f.debug_tuple("Svg");
                    debug_trait_builder.finish()
                }
                (&NodeType::Switch,) => {
                    let mut debug_trait_builder = f.debug_tuple("Switch");
                    debug_trait_builder.finish()
                }
                (&NodeType::Symbol,) => {
                    let mut debug_trait_builder = f.debug_tuple("Symbol");
                    debug_trait_builder.finish()
                }
                (&NodeType::Text,) => {
                    let mut debug_trait_builder = f.debug_tuple("Text");
                    debug_trait_builder.finish()
                }
                (&NodeType::TRef,) => {
                    let mut debug_trait_builder = f.debug_tuple("TRef");
                    debug_trait_builder.finish()
                }
                (&NodeType::TSpan,) => {
                    let mut debug_trait_builder = f.debug_tuple("TSpan");
                    debug_trait_builder.finish()
                }
                (&NodeType::Use,) => {
                    let mut debug_trait_builder = f.debug_tuple("Use");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveFirst,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveFirst");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveBlend,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveBlend");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveColorMatrix,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveColorMatrix");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveComponentTransfer,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveComponentTransfer");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveComposite,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveComposite");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveConvolveMatrix,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveConvolveMatrix");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveDiffuseLighting,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveDiffuseLighting");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveDisplacementMap,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveDisplacementMap");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveFlood,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveFlood");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveGaussianBlur,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveGaussianBlur");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveImage,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveImage");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveMerge,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveMerge");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveMergeNode,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveMergeNode");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveMorphology,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveMorphology");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveOffset,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveOffset");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveSpecularLighting,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveSpecularLighting");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveTile,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveTile");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveTurbulence,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveTurbulence");
                    debug_trait_builder.finish()
                }
                (&NodeType::FilterPrimitiveLast,) => {
                    let mut debug_trait_builder = f.debug_tuple("FilterPrimitiveLast");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for NodeType {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for NodeType {
        #[inline]
        fn clone(&self) -> NodeType {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for NodeType {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for NodeType {
        #[inline]
        fn eq(&self, other: &NodeType) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Ord for NodeType {
        #[inline]
        fn cmp(&self, other: &NodeType) -> ::std::cmp::Ordering {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::std::cmp::Ordering::Equal,
                    }
                } else {
                    __self_vi.cmp(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialOrd for NodeType {
        #[inline]
        fn partial_cmp(&self, other: &NodeType) -> ::std::option::Option<::std::cmp::Ordering> {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::std::option::Option::Some(::std::cmp::Ordering::Equal),
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
    }
    impl Node {
        pub fn new(
            node_type: NodeType,
            parent: Option<Weak<Node>>,
            id: Option<&str>,
            class: Option<&str>,
            state: *mut RsvgState,
            node_impl: Box<NodeTrait>,
        ) -> Node {
            Node {
                node_type,
                parent,
                id: id.map(str::to_string),
                class: class.map(str::to_string),
                first_child: RefCell::new(None),
                last_child: RefCell::new(None),
                next_sib: RefCell::new(None),
                prev_sib: RefCell::new(None),
                state,
                transform: Cell::new(Matrix::identity()),
                result: RefCell::new(Ok(())),
                values: RefCell::new(ComputedValues::default()),
                cond: Cell::new(true),
                node_impl,
            }
        }
        pub fn get_type(&self) -> NodeType {
            self.node_type
        }
        pub fn get_id(&self) -> Option<&str> {
            self.id.as_ref().map(String::as_str)
        }
        pub fn get_class(&self) -> Option<&str> {
            self.class.as_ref().map(String::as_str)
        }
        pub fn register(&self, node: &RsvgNode, defs: *mut RsvgDefs) {
            if let Some(ref id) = self.id {
                defs::register_node_by_id(defs, id, node);
            }
        }
        pub fn get_transform(&self) -> Matrix {
            self.transform.get()
        }
        pub fn get_state_mut(&self) -> &mut State {
            state::from_c_mut(self.state)
        }
        pub fn get_specified_values(&self) -> &SpecifiedValues {
            state::from_c(self.state).get_specified_values()
        }
        pub fn get_cascaded_values(&self) -> CascadedValues {
            CascadedValues::new_from_node(self)
        }
        pub fn cascade(&self, values: &ComputedValues) {
            let mut values = values.clone();
            self.get_specified_values().to_computed_values(&mut values);
            *self.values.borrow_mut() = values.clone();
            for child in self.children() {
                child.cascade(&values);
            }
        }
        pub fn get_cond(&self) -> bool {
            self.cond.get()
        }
        pub fn get_parent(&self) -> Option<Rc<Node>> {
            match self.parent {
                None => None,
                Some(ref weak_node) => Some(weak_node.upgrade().unwrap()),
            }
        }
        pub fn is_ancestor(ancestor: Rc<Node>, descendant: Rc<Node>) -> bool {
            let mut desc = Some(descendant.clone());
            while let Some(ref d) = desc.clone() {
                if Rc::ptr_eq(&ancestor, d) {
                    return true;
                }
                desc = d.get_parent();
            }
            false
        }
        pub fn add_child(&self, child: &Rc<Node>) {
            if !child.next_sib.borrow().is_none() {
                {
                    ::rt::begin_panic(
                        "assertion failed: child.next_sib.borrow().is_none()",
                        &("rsvg_internals/src/node.rs", 348u32, 9u32),
                    )
                }
            };
            if !child.prev_sib.borrow().is_none() {
                {
                    ::rt::begin_panic(
                        "assertion failed: child.prev_sib.borrow().is_none()",
                        &("rsvg_internals/src/node.rs", 349u32, 9u32),
                    )
                }
            };
            if let Some(last_child_weak) = self.last_child.replace(Some(Rc::downgrade(child))) {
                if let Some(last_child) = last_child_weak.upgrade() {
                    child.prev_sib.replace(Some(last_child_weak));
                    last_child.next_sib.replace(Some(child.clone()));
                    return;
                }
            }
            self.first_child.replace(Some(child.clone()));
        }
        pub fn set_atts(&self, node: &RsvgNode, handle: *const RsvgHandle, pbag: &PropertyBag) {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::Transform => match Matrix::parse_str(value, ()) {
                        Ok(affine) => self.transform.set(affine),
                        Err(e) => {
                            self.set_error(NodeError::attribute_error(Attribute::Transform, e));
                            return;
                        }
                    },
                    _ => (),
                }
            }
            match self.parse_conditional_processing_attributes(pbag) {
                Ok(_) => (),
                Err(e) => {
                    self.set_error(e);
                    return;
                }
            }
            *self.result.borrow_mut() = self.node_impl.set_atts(node, handle, pbag);
        }
        fn parse_conditional_processing_attributes(
            &self,
            pbag: &PropertyBag,
        ) -> Result<(), NodeError> {
            let mut cond = self.cond.get();
            for (_key, attr, value) in pbag.iter() {
                let mut parse = || {
                    match attr {
                        Attribute::RequiredExtensions if cond => {
                            cond = RequiredExtensions::from_attribute(value)
                                .map(|RequiredExtensions(res)| res)?;
                        }
                        Attribute::RequiredFeatures if cond => {
                            cond = RequiredFeatures::from_attribute(value)
                                .map(|RequiredFeatures(res)| res)?;
                        }
                        Attribute::SystemLanguage if cond => {
                            cond =
                                SystemLanguage::from_attribute(value, &glib::get_language_names())
                                    .map(|SystemLanguage(res, _)| res)?;
                        }
                        _ => {}
                    }
                    Ok(cond)
                };
                parse()
                    .map(|c| self.cond.set(c))
                    .map_err(|e| NodeError::attribute_error(attr, e))?;
            }
            Ok(())
        }
        pub fn set_overridden_properties(&self) {
            let mut state = self.get_state_mut();
            self.node_impl.set_overridden_properties(&mut state);
        }
        pub fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            if self.result.borrow().is_ok() {
                let cr = draw_ctx.get_cairo_context();
                let save_affine = cr.get_matrix();
                cr.transform(self.get_transform());
                self.node_impl.draw(node, cascaded, draw_ctx, clipping);
                cr.set_matrix(save_affine);
            }
        }
        pub fn set_error(&self, error: NodeError) {
            *self.result.borrow_mut() = Err(error);
        }
        pub fn is_in_error(&self) -> bool {
            self.result.borrow().is_err()
        }
        pub fn get_result(&self) -> NodeResult {
            self.result.borrow().clone()
        }
        pub fn get_c_impl(&self) -> *const RsvgCNodeImpl {
            self.node_impl.get_c_impl()
        }
        pub fn with_impl<T, F, U>(&self, f: F) -> U
        where
            T: NodeTrait,
            F: FnOnce(&T) -> U,
        {
            if let Some(t) = (&self.node_impl).downcast_ref::<T>() {
                f(t)
            } else {
                {
                    ::rt::begin_panic(
                        "could not downcast",
                        &("rsvg_internals/src/node.rs", 471u32, 13u32),
                    )
                };
            }
        }
        pub fn get_impl<T: NodeTrait>(&self) -> Option<&T> {
            (&self.node_impl).downcast_ref::<T>()
        }
        pub fn draw_children(
            &self,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            for child in self.children() {
                draw_ctx.draw_node_from_stack(
                    &CascadedValues::new(cascaded, &child),
                    &child,
                    clipping,
                );
            }
        }
        pub fn children(&self) -> Children {
            let last_child = self
                .last_child
                .borrow()
                .as_ref()
                .and_then(|child_weak| child_weak.upgrade());
            Children::new(self.first_child.borrow().clone(), last_child)
        }
        pub fn has_children(&self) -> bool {
            self.first_child.borrow().is_some()
        }
        pub fn set_overflow_hidden(&self) {
            let state = self.get_state_mut();
            state.values.overflow = SpecifiedValue::Specified(Overflow::Hidden);
        }
    }
    #[cfg(not(test))]
    impl Drop for Node {
        fn drop(&mut self) {
            extern "C" {
                fn rsvg_state_free(state: *mut RsvgState);
            }
            unsafe {
                rsvg_state_free(self.state);
            }
        }
    }
    pub fn node_ptr_to_weak(raw_parent: *const RsvgNode) -> Option<Weak<Node>> {
        if raw_parent.is_null() {
            None
        } else {
            let p: &RsvgNode = unsafe { &*raw_parent };
            Some(Rc::downgrade(&p.clone()))
        }
    }
    pub fn boxed_node_new(
        node_type: NodeType,
        raw_parent: *const RsvgNode,
        id: Option<&str>,
        class: Option<&str>,
        node_impl: Box<NodeTrait>,
    ) -> *mut RsvgNode {
        box_node(Rc::new(Node::new(
            node_type,
            node_ptr_to_weak(raw_parent),
            id,
            class,
            rsvg_state_new(),
            node_impl,
        )))
    }
    impl Children {
        fn new(next: Option<Rc<Node>>, next_back: Option<Rc<Node>>) -> Self {
            Self { next, next_back }
        }
        fn finished(&self) -> bool {
            match &self.next_back {
                &Some(ref next_back) => {
                    next_back
                        .next_sib
                        .borrow()
                        .clone()
                        .map(|rc| &*rc as *const Node)
                        == self.next.clone().map(|rc| &*rc as *const Node)
                }
                _ => true,
            }
        }
    }
    impl Iterator for Children {
        type Item = Rc<Node>;
        fn next(&mut self) -> Option<Self::Item> {
            if self.finished() {
                return None;
            }
            self.next.take().and_then(|next| {
                self.next = next.next_sib.borrow().clone();
                Some(next)
            })
        }
    }
    impl DoubleEndedIterator for Children {
        fn next_back(&mut self) -> Option<Self::Item> {
            if self.finished() {
                return None;
            }
            self.next_back.take().and_then(|next_back| {
                self.next_back = next_back
                    .prev_sib
                    .borrow()
                    .as_ref()
                    .and_then(|sib_weak| sib_weak.upgrade());
                Some(next_back)
            })
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_get_type(raw_node: *const RsvgNode) -> NodeType {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 604u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        node.get_type()
    }
    pub fn box_node(node: RsvgNode) -> *mut RsvgNode {
        Box::into_raw(Box::new(node))
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_get_parent(raw_node: *const RsvgNode) -> *const RsvgNode {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 616u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        match node.get_parent() {
            None => ptr::null(),
            Some(node) => box_node(node),
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_ref(raw_node: *mut RsvgNode) -> *mut RsvgNode {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 628u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        box_node(node.clone())
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_unref(raw_node: *mut RsvgNode) -> *mut RsvgNode {
        if !raw_node.is_null() {
            let _ = unsafe { Box::from_raw(raw_node) };
        }
        ptr::null_mut()
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_is_same(
        raw_node1: *const RsvgNode,
        raw_node2: *const RsvgNode,
    ) -> glib_sys::gboolean {
        let is_same = if raw_node1.is_null() && raw_node2.is_null() {
            true
        } else if !raw_node1.is_null() && !raw_node2.is_null() {
            let node1: &RsvgNode = unsafe { &*raw_node1 };
            let node2: &RsvgNode = unsafe { &*raw_node2 };
            Rc::ptr_eq(node1, node2)
        } else {
            false
        };
        is_same.to_glib()
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_add_child(raw_node: *mut RsvgNode, raw_child: *const RsvgNode) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 665u32, 5u32),
                )
            }
        };
        if !!raw_child.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_child.is_null()",
                    &("rsvg_internals/src/node.rs", 666u32, 5u32),
                )
            }
        };
        let node: &mut RsvgNode = unsafe { &mut *raw_node };
        let child: &RsvgNode = unsafe { &*raw_child };
        node.add_child(child);
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_register_in_defs(raw_node: *const RsvgNode, defs: *mut RsvgDefs) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 675u32, 5u32),
                )
            }
        };
        if !!defs.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !defs.is_null()",
                    &("rsvg_internals/src/node.rs", 676u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        node.register(node, defs);
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_set_atts(
        raw_node: *mut RsvgNode,
        handle: *const RsvgHandle,
        pbag: *const PropertyBag,
    ) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 689u32, 5u32),
                )
            }
        };
        if !!pbag.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !pbag.is_null()",
                    &("rsvg_internals/src/node.rs", 690u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        let pbag = unsafe { &*pbag };
        node.set_atts(node, handle, pbag);
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_set_overridden_properties(raw_node: *mut RsvgNode) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 700u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        node.set_overridden_properties();
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_set_attribute_parse_error(
        raw_node: *const RsvgNode,
        attr_name: *const libc::c_char,
        description: *const libc::c_char,
    ) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 713u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        if !!attr_name.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !attr_name.is_null()",
                    &("rsvg_internals/src/node.rs", 716u32, 5u32),
                )
            }
        };
        if !!description.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !description.is_null()",
                    &("rsvg_internals/src/node.rs", 717u32, 5u32),
                )
            }
        };
        unsafe {
            let attr_name = utf8_cstr(attr_name);
            let attr = Attribute::from_str(attr_name).unwrap();
            node.set_error(NodeError::parse_error(
                attr,
                ParseError::new(&String::from_glib_none(description)),
            ));
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_children_iter_begin(raw_node: *const RsvgNode) -> *mut Children {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 732u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        Box::into_raw(Box::new(node.children()))
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_children_iter_end(iter: *mut Children) {
        if !!iter.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !iter.is_null()",
                    &("rsvg_internals/src/node.rs", 740u32, 5u32),
                )
            }
        };
        unsafe { Box::from_raw(iter) };
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_children_iter_next(
        iter: *mut Children,
        out_child: *mut *mut RsvgNode,
    ) -> glib_sys::gboolean {
        if !!iter.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !iter.is_null()",
                    &("rsvg_internals/src/node.rs", 750u32, 5u32),
                )
            }
        };
        let iter = unsafe { &mut *iter };
        if let Some(child) = iter.next() {
            unsafe {
                *out_child = box_node(child);
            }
            true.to_glib()
        } else {
            unsafe {
                *out_child = ptr::null_mut();
            }
            false.to_glib()
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_children_iter_next_back(
        iter: *mut Children,
        out_child: *mut *mut RsvgNode,
    ) -> glib_sys::gboolean {
        if !!iter.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !iter.is_null()",
                    &("rsvg_internals/src/node.rs", 771u32, 5u32),
                )
            }
        };
        let iter = unsafe { &mut *iter };
        if let Some(child) = iter.next_back() {
            unsafe {
                *out_child = box_node(child);
            }
            true.to_glib()
        } else {
            unsafe {
                *out_child = ptr::null_mut();
            }
            false.to_glib()
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_root_node_cascade(raw_node: *const RsvgNode) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/node.rs", 789u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        let values = ComputedValues::default();
        node.cascade(&values)
    }
}
mod paint_server {
    use bbox::BoundingBox;
    use cssparser::{self, Parser};
    use drawing_ctx::DrawingCtx;
    use error::*;
    use gradient;
    use node::NodeType;
    use parsers::Parse;
    use pattern;
    use unitinterval::UnitInterval;
    pub enum PaintServer {
        None,
        Iri {
            iri: String,
            alternate: Option<cssparser::Color>,
        },
        SolidColor(cssparser::Color),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PaintServer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&PaintServer::None,) => {
                    let mut debug_trait_builder = f.debug_tuple("None");
                    debug_trait_builder.finish()
                }
                (&PaintServer::Iri {
                    iri: ref __self_0,
                    alternate: ref __self_1,
                },) => {
                    let mut debug_trait_builder = f.debug_struct("Iri");
                    let _ = debug_trait_builder.field("iri", &&(*__self_0));
                    let _ = debug_trait_builder.field("alternate", &&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&PaintServer::SolidColor(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("SolidColor");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for PaintServer {
        #[inline]
        fn clone(&self) -> PaintServer {
            match (&*self,) {
                (&PaintServer::None,) => PaintServer::None,
                (&PaintServer::Iri {
                    iri: ref __self_0,
                    alternate: ref __self_1,
                },) => PaintServer::Iri {
                    iri: ::std::clone::Clone::clone(&(*__self_0)),
                    alternate: ::std::clone::Clone::clone(&(*__self_1)),
                },
                (&PaintServer::SolidColor(ref __self_0),) => {
                    PaintServer::SolidColor(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for PaintServer {
        #[inline]
        fn eq(&self, other: &PaintServer) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &PaintServer::Iri {
                                iri: ref __self_0,
                                alternate: ref __self_1,
                            },
                            &PaintServer::Iri {
                                iri: ref __arg_1_0,
                                alternate: ref __arg_1_1,
                            },
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &PaintServer::SolidColor(ref __self_0),
                            &PaintServer::SolidColor(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &PaintServer) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &PaintServer::Iri {
                                iri: ref __self_0,
                                alternate: ref __self_1,
                            },
                            &PaintServer::Iri {
                                iri: ref __arg_1_0,
                                alternate: ref __arg_1_1,
                            },
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &PaintServer::SolidColor(ref __self_0),
                            &PaintServer::SolidColor(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    impl Parse for PaintServer {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<PaintServer, AttributeError> {
            if parser.try(|i| i.expect_ident_matching("none")).is_ok() {
                Ok(PaintServer::None)
            } else if let Ok(url) = parser.try(|i| i.expect_url()) {
                let alternate = if !parser.is_exhausted() {
                    if parser.try(|i| i.expect_ident_matching("none")).is_ok() {
                        None
                    } else {
                        Some(parser.try(|i| cssparser::Color::parse(i))?)
                    }
                } else {
                    None
                };
                Ok(PaintServer::Iri {
                    iri: String::from(url.as_ref()),
                    alternate,
                })
            } else {
                cssparser::Color::parse(parser)
                    .map(PaintServer::SolidColor)
                    .map_err(AttributeError::from)
            }
        }
    }
    fn set_color(
        draw_ctx: &mut DrawingCtx,
        color: &cssparser::Color,
        opacity: &UnitInterval,
        current_color: &cssparser::RGBA,
    ) {
        let rgba = match *color {
            cssparser::Color::RGBA(ref rgba) => rgba,
            cssparser::Color::CurrentColor => current_color,
        };
        let &UnitInterval(o) = opacity;
        draw_ctx.get_cairo_context().set_source_rgba(
            f64::from(rgba.red_f32()),
            f64::from(rgba.green_f32()),
            f64::from(rgba.blue_f32()),
            f64::from(rgba.alpha_f32()) * o,
        );
    }
    pub fn set_source_paint_server(
        draw_ctx: &mut DrawingCtx,
        ps: &PaintServer,
        opacity: &UnitInterval,
        bbox: &BoundingBox,
        current_color: &cssparser::RGBA,
    ) -> bool {
        let mut had_paint_server;
        match *ps {
            PaintServer::Iri {
                ref iri,
                ref alternate,
            } => {
                had_paint_server = false;
                if let Some(acquired) = draw_ctx.get_acquired_node(iri.as_str()) {
                    let node = acquired.get();
                    if node.get_type() == NodeType::LinearGradient
                        || node.get_type() == NodeType::RadialGradient
                    {
                        had_paint_server = gradient::gradient_resolve_fallbacks_and_set_pattern(
                            &node, draw_ctx, opacity, bbox,
                        );
                    } else if node.get_type() == NodeType::Pattern {
                        had_paint_server = pattern::pattern_resolve_fallbacks_and_set_pattern(
                            &node, draw_ctx, bbox,
                        );
                    }
                }
                if !had_paint_server && alternate.is_some() {
                    set_color(
                        draw_ctx,
                        alternate.as_ref().unwrap(),
                        opacity,
                        current_color,
                    );
                    had_paint_server = true;
                }
            }
            PaintServer::SolidColor(color) => {
                set_color(draw_ctx, &color, opacity, current_color);
                had_paint_server = true;
            }
            PaintServer::None => {
                had_paint_server = false;
            }
        };
        had_paint_server
    }
}
mod parsers {
    use attributes::Attribute;
    use cssparser::{BasicParseError, Parser, ParserInput, Token};
    use error::{AttributeError, NodeError};
    use glib::translate::*;
    use glib_sys;
    use libc;
    use std::f64::consts::*;
    use std::mem;
    use std::ptr;
    use std::slice;
    use std::str::{self, FromStr};
    use util::utf8_cstr;
    pub struct ParseError {
        pub display: String,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseError {
                    display: ref __self_0_0,
                } => {
                    let mut debug_trait_builder = f.debug_struct("ParseError");
                    let _ = debug_trait_builder.field("display", &&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ParseError {
        #[inline]
        fn clone(&self) -> ParseError {
            match *self {
                ParseError {
                    display: ref __self_0_0,
                } => ParseError {
                    display: ::std::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseError {
        #[inline]
        fn eq(&self, other: &ParseError) -> bool {
            match *other {
                ParseError {
                    display: ref __self_1_0,
                } => match *self {
                    ParseError {
                        display: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ParseError) -> bool {
            match *other {
                ParseError {
                    display: ref __self_1_0,
                } => match *self {
                    ParseError {
                        display: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ParseError {
        pub fn new<T: AsRef<str>>(msg: T) -> ParseError {
            ParseError {
                display: msg.as_ref().to_string(),
            }
        }
    }
    impl<'a> From<BasicParseError<'a>> for ParseError {
        fn from(_: BasicParseError) -> ParseError {
            ParseError::new("parse error")
        }
    }
    pub trait Parse: Sized {
        type Data;
        type Err;
        fn parse(parser: &mut Parser, data: Self::Data) -> Result<Self, Self::Err>;
        fn parse_str(s: &str, data: Self::Data) -> Result<Self, Self::Err> {
            let mut input = ParserInput::new(s);
            let mut parser = Parser::new(&mut input);
            Self::parse(&mut parser, data).and_then(|r| Ok(r))
        }
    }
    impl Parse for f64 {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<f64, AttributeError> {
            Ok(f64::from(parser.expect_number().map_err(|_| {
                AttributeError::Parse(ParseError::new("expected number"))
            })?))
        }
    }
    impl Parse for String {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<String, AttributeError> {
            Ok(String::from(
                parser
                    .expect_string()
                    .map_err(|_| AttributeError::Parse(ParseError::new("expected number")))?
                    .as_ref(),
            ))
        }
    }
    /// Parses a `value` string into a type `T`.
    ///
    /// Some value types need some extra `data` to be parsed.  This
    /// corresponds to the `<T as Parse>::Data` associated type.  For
    /// example, an `RsvgLength` has an associated `type Data =
    /// LengthDir`, so to parse a length value, you could specify
    /// `LengthDir::Horizontal` for `data`, for example.
    pub fn parse<T>(key: &str, value: &str, data: <T as Parse>::Data) -> Result<T, NodeError>
    where
        T: Parse<Err = AttributeError>,
    {
        let mut input = ParserInput::new(value);
        let mut parser = Parser::new(&mut input);
        T::parse(&mut parser, data)
            .map_err(|e| NodeError::attribute_error(Attribute::from_str(key).unwrap(), e))
    }
    /// Parses a `value` string into a type `T` with an optional validation function.
    ///
    /// Some value types need some extra `data` to be parsed.  This
    /// corresponds to the `<T as Parse>::Data` associated type.  For
    /// example, an `RsvgLength` has an associated `type Data =
    /// LengthDir`, so to parse a length value, you could specify
    /// `LengthDir::Horizontal` for `data`, for example.
    pub fn parse_and_validate<T, F>(
        key: &str,
        value: &str,
        data: <T as Parse>::Data,
        validate: F,
    ) -> Result<T, NodeError>
    where
        T: Parse<Err = AttributeError>,
        F: FnOnce(T) -> Result<T, AttributeError>,
    {
        let mut input = ParserInput::new(value);
        let mut parser = Parser::new(&mut input);
        T::parse(&mut parser, data)
            .and_then(validate)
            .map_err(|e| NodeError::attribute_error(Attribute::from_str(key).unwrap(), e))
    }
    pub fn angle_degrees(parser: &mut Parser) -> Result<f64, ParseError> {
        let angle = {
            let token = parser
                .next()
                .map_err(|_| ParseError::new("expected angle"))?;
            match *token {
                Token::Number { value, .. } => f64::from(value),
                Token::Dimension {
                    value, ref unit, ..
                } => {
                    let value = f64::from(value);
                    match unit.as_ref() {
                        "deg" => value,
                        "grad" => value * 360.0 / 400.0,
                        "rad" => value * 180.0 / PI,
                        _ => return Err(ParseError::new("expected \'deg\' | \'grad\' | \'rad\'")),
                    }
                }
                _ => return Err(ParseError::new("expected angle")),
            }
        };
        parser
            .expect_exhausted()
            .map_err(|_| ParseError::new("expected angle"))?;
        Ok(angle)
    }
    pub fn optional_comma(parser: &mut Parser) {
        let _ = parser.try(|p| p.expect_comma());
    }
    pub fn number(s: &str) -> Result<f64, ParseError> {
        let mut input = ParserInput::new(s);
        let mut parser = Parser::new(&mut input);
        Ok(f64::from(parser.expect_number()?))
    }
    pub fn number_optional_number(s: &str) -> Result<(f64, f64), ParseError> {
        let mut input = ParserInput::new(s);
        let mut parser = Parser::new(&mut input);
        let x = f64::from(parser.expect_number()?);
        if !parser.is_exhausted() {
            let state = parser.state();
            match *parser.next()? {
                Token::Comma => {}
                _ => parser.reset(&state),
            };
            let y = f64::from(parser.expect_number()?);
            parser.expect_exhausted()?;
            Ok((x, y))
        } else {
            Ok((x, x))
        }
    }
    pub fn integer(s: &str) -> Result<i32, ParseError> {
        let mut input = ParserInput::new(s);
        let mut parser = Parser::new(&mut input);
        Ok(parser.expect_integer()?)
    }
    pub fn integer_optional_integer(s: &str) -> Result<(i32, i32), ParseError> {
        let mut input = ParserInput::new(s);
        let mut parser = Parser::new(&mut input);
        let x = parser.expect_integer()?;
        if !parser.is_exhausted() {
            let state = parser.state();
            match *parser.next()? {
                Token::Comma => {}
                _ => parser.reset(&state),
            };
            let y = parser.expect_integer()?;
            parser.expect_exhausted()?;
            Ok((x, y))
        } else {
            Ok((x, x))
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_css_parse_number_optional_number(
        s: *const libc::c_char,
        out_x: *mut f64,
        out_y: *mut f64,
    ) -> glib_sys::gboolean {
        if !!s.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !s.is_null()",
                    &("rsvg_internals/src/parsers.rs", 245u32, 5u32),
                )
            }
        };
        if !!out_x.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !out_x.is_null()",
                    &("rsvg_internals/src/parsers.rs", 246u32, 5u32),
                )
            }
        };
        if !!out_y.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !out_y.is_null()",
                    &("rsvg_internals/src/parsers.rs", 247u32, 5u32),
                )
            }
        };
        let string = unsafe { utf8_cstr(s) };
        match number_optional_number(string) {
            Ok((x, y)) => {
                unsafe {
                    *out_x = x;
                    *out_y = y;
                }
                true
            }
            Err(_) => {
                unsafe {
                    *out_x = 0.0;
                    *out_y = 0.0;
                }
                false
            }
        }.to_glib()
    }
    pub fn list_of_points(string: &str) -> Result<Vec<(f64, f64)>, ParseError> {
        let mut input = ParserInput::new(string);
        let mut parser = Parser::new(&mut input);
        let mut v = Vec::new();
        loop {
            let x = f64::from(parser.expect_number()?);
            optional_comma(&mut parser);
            let y = f64::from(parser.expect_number()?);
            v.push((x, y));
            if parser.is_exhausted() {
                break;
            }
            match parser.next_including_whitespace() {
                Ok(&Token::WhiteSpace(_)) => (),
                _ => optional_comma(&mut parser),
            }
        }
        Ok(v)
    }
    #[structural_match]
    pub enum ListLength {
        Exact(usize),
        Maximum(usize),
        Unbounded,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for ListLength {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<usize>;
                let _: ::std::cmp::AssertParamIsEq<usize>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ListLength {
        #[inline]
        fn eq(&self, other: &ListLength) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&ListLength::Exact(ref __self_0), &ListLength::Exact(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &ListLength::Maximum(ref __self_0),
                            &ListLength::Maximum(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &ListLength) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&ListLength::Exact(ref __self_0), &ListLength::Exact(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &ListLength::Maximum(ref __self_0),
                            &ListLength::Maximum(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    pub enum NumberListError {
        IncorrectNumberOfElements,
        Parse(ParseError),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for NumberListError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&NumberListError::IncorrectNumberOfElements,) => {
                    let mut debug_trait_builder = f.debug_tuple("IncorrectNumberOfElements");
                    debug_trait_builder.finish()
                }
                (&NumberListError::Parse(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Parse");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for NumberListError {
        #[inline]
        fn eq(&self, other: &NumberListError) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &NumberListError::Parse(ref __self_0),
                            &NumberListError::Parse(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &NumberListError) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &NumberListError::Parse(ref __self_0),
                            &NumberListError::Parse(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    pub fn number_list(
        parser: &mut Parser,
        length: ListLength,
    ) -> Result<Vec<f64>, NumberListError> {
        let n;
        match length {
            ListLength::Exact(l) => {
                if !(l > 0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: l > 0",
                            &("rsvg_internals/src/parsers.rs", 321u32, 13u32),
                        )
                    }
                };
                n = Some(l);
            }
            ListLength::Maximum(l) => {
                if !(l > 0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: l > 0",
                            &("rsvg_internals/src/parsers.rs", 325u32, 13u32),
                        )
                    }
                };
                n = Some(l);
            }
            ListLength::Unbounded => {
                n = None;
            }
        }
        let mut v = Vec::<f64>::with_capacity(n.unwrap_or(0));
        if parser.is_exhausted() && length == ListLength::Unbounded {
            return Ok(v);
        }
        for i in 0.. {
            if i != 0 {
                optional_comma(parser);
            }
            v.push(f64::from(parser.expect_number().map_err(|_| {
                NumberListError::Parse(ParseError::new("expected number"))
            })?));
            match length {
                ListLength::Exact(l) | ListLength::Maximum(l) => if i + 1 == l {
                    break;
                },
                _ => (),
            }
            if parser.is_exhausted() {
                match length {
                    ListLength::Exact(l) => {
                        if i + 1 == l {
                            break;
                        }
                    }
                    _ => break,
                }
            }
        }
        parser
            .expect_exhausted()
            .map_err(|_| NumberListError::IncorrectNumberOfElements)?;
        Ok(v)
    }
    pub fn number_list_from_str(s: &str, length: ListLength) -> Result<Vec<f64>, NumberListError> {
        let mut input = ParserInput::new(s);
        let mut parser = Parser::new(&mut input);
        number_list(&mut parser, length)
    }
    #[repr(C)]
    #[rustc_copy_clone_marker]
    pub enum NumberListLength {
        Exact,
        Maximum,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for NumberListLength {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&NumberListLength::Exact,) => {
                    let mut debug_trait_builder = f.debug_tuple("Exact");
                    debug_trait_builder.finish()
                }
                (&NumberListLength::Maximum,) => {
                    let mut debug_trait_builder = f.debug_tuple("Maximum");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for NumberListLength {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for NumberListLength {
        #[inline]
        fn clone(&self) -> NumberListLength {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for NumberListLength {
        #[inline]
        fn eq(&self, other: &NumberListLength) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as i32;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as i32;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_css_parse_number_list(
        in_str: *const libc::c_char,
        nlength: NumberListLength,
        size: libc::size_t,
        out_list: *mut *const libc::c_double,
        out_list_length: *mut libc::size_t,
    ) -> glib_sys::gboolean {
        if !!in_str.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !in_str.is_null()",
                    &("rsvg_internals/src/parsers.rs", 396u32, 5u32),
                )
            }
        };
        if !!out_list.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !out_list.is_null()",
                    &("rsvg_internals/src/parsers.rs", 397u32, 5u32),
                )
            }
        };
        if !!out_list_length.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !out_list_length.is_null()",
                    &("rsvg_internals/src/parsers.rs", 398u32, 5u32),
                )
            }
        };
        let length = match nlength {
            NumberListLength::Exact => ListLength::Exact(size),
            NumberListLength::Maximum => ListLength::Maximum(size),
        };
        let s = unsafe { utf8_cstr(in_str) };
        let result = number_list_from_str(s, length);
        match result {
            Ok(number_list) => {
                let num_elems = number_list.len();
                let c_array = unsafe {
                    glib_sys::g_malloc_n(num_elems, mem::size_of::<libc::c_double>())
                        as *mut libc::c_double
                };
                let array = unsafe { slice::from_raw_parts_mut(c_array, num_elems) };
                array.copy_from_slice(&number_list);
                unsafe {
                    *out_list = c_array;
                    *out_list_length = num_elems;
                }
                true
            }
            Err(_) => {
                unsafe {
                    *out_list = ptr::null();
                    *out_list_length = 0;
                }
                false
            }
        }.to_glib()
    }
}
mod path_builder {
    use cairo;
    use float_eq_cairo::ApproxEqCairo;
    use std::f64;
    use std::f64::consts::*;
    use util::clamp;
    #[rustc_copy_clone_marker]
    pub struct LargeArc(pub bool);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for LargeArc {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                LargeArc(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("LargeArc");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for LargeArc {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for LargeArc {
        #[inline]
        fn clone(&self) -> LargeArc {
            {
                let _: ::std::clone::AssertParamIsClone<bool>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for LargeArc {
        #[inline]
        fn eq(&self, other: &LargeArc) -> bool {
            match *other {
                LargeArc(ref __self_1_0) => match *self {
                    LargeArc(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LargeArc) -> bool {
            match *other {
                LargeArc(ref __self_1_0) => match *self {
                    LargeArc(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[rustc_copy_clone_marker]
    pub enum Sweep {
        Negative,
        Positive,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Sweep {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Sweep::Negative,) => {
                    let mut debug_trait_builder = f.debug_tuple("Negative");
                    debug_trait_builder.finish()
                }
                (&Sweep::Positive,) => {
                    let mut debug_trait_builder = f.debug_tuple("Positive");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Sweep {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Sweep {
        #[inline]
        fn clone(&self) -> Sweep {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Sweep {
        #[inline]
        fn eq(&self, other: &Sweep) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    pub enum PathCommand {
        MoveTo(f64, f64),
        LineTo(f64, f64),
        CurveTo((f64, f64), (f64, f64), (f64, f64)),
        ClosePath,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PathCommand {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&PathCommand::MoveTo(ref __self_0, ref __self_1),) => {
                    let mut debug_trait_builder = f.debug_tuple("MoveTo");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    let _ = debug_trait_builder.field(&&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&PathCommand::LineTo(ref __self_0, ref __self_1),) => {
                    let mut debug_trait_builder = f.debug_tuple("LineTo");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    let _ = debug_trait_builder.field(&&(*__self_1));
                    debug_trait_builder.finish()
                }
                (&PathCommand::CurveTo(ref __self_0, ref __self_1, ref __self_2),) => {
                    let mut debug_trait_builder = f.debug_tuple("CurveTo");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    let _ = debug_trait_builder.field(&&(*__self_1));
                    let _ = debug_trait_builder.field(&&(*__self_2));
                    debug_trait_builder.finish()
                }
                (&PathCommand::ClosePath,) => {
                    let mut debug_trait_builder = f.debug_tuple("ClosePath");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for PathCommand {
        #[inline]
        fn eq(&self, other: &PathCommand) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &PathCommand::MoveTo(ref __self_0, ref __self_1),
                            &PathCommand::MoveTo(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &PathCommand::LineTo(ref __self_0, ref __self_1),
                            &PathCommand::LineTo(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) == (*__arg_1_0) && (*__self_1) == (*__arg_1_1),
                        (
                            &PathCommand::CurveTo(ref __self_0, ref __self_1, ref __self_2),
                            &PathCommand::CurveTo(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                        ) => {
                            (*__self_0) == (*__arg_1_0)
                                && (*__self_1) == (*__arg_1_1)
                                && (*__self_2) == (*__arg_1_2)
                        }
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &PathCommand) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (
                            &PathCommand::MoveTo(ref __self_0, ref __self_1),
                            &PathCommand::MoveTo(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &PathCommand::LineTo(ref __self_0, ref __self_1),
                            &PathCommand::LineTo(ref __arg_1_0, ref __arg_1_1),
                        ) => (*__self_0) != (*__arg_1_0) || (*__self_1) != (*__arg_1_1),
                        (
                            &PathCommand::CurveTo(ref __self_0, ref __self_1, ref __self_2),
                            &PathCommand::CurveTo(ref __arg_1_0, ref __arg_1_1, ref __arg_1_2),
                        ) => {
                            (*__self_0) != (*__arg_1_0)
                                || (*__self_1) != (*__arg_1_1)
                                || (*__self_2) != (*__arg_1_2)
                        }
                        _ => false,
                    }
                } else {
                    true
                }
            }
        }
    }
    pub struct PathBuilder {
        path_commands: Vec<PathCommand>,
    }
    impl Default for PathBuilder {
        fn default() -> PathBuilder {
            PathBuilder {
                path_commands: Vec::new(),
            }
        }
    }
    impl PathCommand {
        fn to_cairo(&self, cr: &cairo::Context) {
            match *self {
                PathCommand::MoveTo(x, y) => {
                    cr.move_to(x, y);
                }
                PathCommand::LineTo(x, y) => {
                    cr.line_to(x, y);
                }
                PathCommand::CurveTo((x2, y2), (x3, y3), (x4, y4)) => {
                    cr.curve_to(x2, y2, x3, y3, x4, y4);
                }
                PathCommand::ClosePath => {
                    cr.close_path();
                }
            }
        }
    }
    impl PathBuilder {
        pub fn new() -> PathBuilder {
            PathBuilder::default()
        }
        pub fn move_to(&mut self, x: f64, y: f64) {
            self.path_commands.push(PathCommand::MoveTo(x, y));
        }
        pub fn line_to(&mut self, x: f64, y: f64) {
            self.path_commands.push(PathCommand::LineTo(x, y));
        }
        pub fn curve_to(&mut self, x2: f64, y2: f64, x3: f64, y3: f64, x4: f64, y4: f64) {
            self.path_commands
                .push(PathCommand::CurveTo((x2, y2), (x3, y3), (x4, y4)));
        }
        pub fn close_path(&mut self) {
            self.path_commands.push(PathCommand::ClosePath);
        }
        pub fn get_path_commands(&self) -> &[PathCommand] {
            &self.path_commands
        }
        /// * * * * * * * * * * *
        pub fn arc(
            &mut self,
            x1: f64,
            y1: f64,
            mut rx: f64,
            mut ry: f64,
            x_axis_rotation: f64,
            large_arc: LargeArc,
            sweep: Sweep,
            x2: f64,
            y2: f64,
        ) {
            let f: f64;
            let sinf: f64;
            let cosf: f64;
            let x1_: f64;
            let y1_: f64;
            let cx_: f64;
            let cy_: f64;
            let cx: f64;
            let cy: f64;
            let gamma: f64;
            let mut theta1: f64;
            let mut delta_theta: f64;
            let mut k1: f64;
            let mut k2: f64;
            let k3: f64;
            let k4: f64;
            let mut k5: f64;
            let n_segs: i32;
            if x1.approx_eq_cairo(&x2) && y1.approx_eq_cairo(&y2) {
                return;
            }
            let is_positive_sweep = sweep == Sweep::Positive;
            let is_large_arc = large_arc.0;
            f = x_axis_rotation * PI / 180.0;
            sinf = f.sin();
            cosf = f.cos();
            rx = rx.abs();
            ry = ry.abs();
            if ((rx * rx) < f64::EPSILON) || ((ry * ry) < f64::EPSILON) {
                self.line_to(x2, y2);
                return;
            }
            k1 = (x1 - x2) / 2.0;
            k2 = (y1 - y2) / 2.0;
            x1_ = cosf * k1 + sinf * k2;
            y1_ = -sinf * k1 + cosf * k2;
            gamma = (x1_ * x1_) / (rx * rx) + (y1_ * y1_) / (ry * ry);
            if gamma > 1.0 {
                rx *= gamma.sqrt();
                ry *= gamma.sqrt();
            }
            k1 = rx * rx * y1_ * y1_ + ry * ry * x1_ * x1_;
            if k1.approx_eq_cairo(&0.0) {
                return;
            }
            k1 = ((rx * rx * ry * ry) / k1 - 1.0).abs().sqrt();
            if is_positive_sweep == is_large_arc {
                k1 = -k1;
            }
            cx_ = k1 * rx * y1_ / ry;
            cy_ = -k1 * ry * x1_ / rx;
            cx = cosf * cx_ - sinf * cy_ + (x1 + x2) / 2.0;
            cy = sinf * cx_ + cosf * cy_ + (y1 + y2) / 2.0;
            k1 = (x1_ - cx_) / rx;
            k2 = (y1_ - cy_) / ry;
            k3 = (-x1_ - cx_) / rx;
            k4 = (-y1_ - cy_) / ry;
            k5 = (k1 * k1 + k2 * k2).abs().sqrt();
            if k5.approx_eq_cairo(&0.0) {
                return;
            }
            k5 = k1 / k5;
            k5 = clamp(k5, -1.0, 1.0);
            theta1 = k5.acos();
            if k2 < 0.0 {
                theta1 = -theta1;
            }
            k5 = ((k1 * k1 + k2 * k2) * (k3 * k3 + k4 * k4)).abs().sqrt();
            if k5.approx_eq_cairo(&0.0) {
                return;
            }
            k5 = (k1 * k3 + k2 * k4) / k5;
            k5 = clamp(k5, -1.0, 1.0);
            delta_theta = k5.acos();
            if k1 * k4 - k3 * k2 < 0.0 {
                delta_theta = -delta_theta;
            }
            if is_positive_sweep && delta_theta < 0.0 {
                delta_theta += PI * 2.0;
            } else if !is_positive_sweep && delta_theta > 0.0 {
                delta_theta -= PI * 2.0;
            }
            n_segs = (delta_theta / (PI * 0.5 + 0.001)).abs().ceil() as i32;
            let n_segs_dbl = f64::from(n_segs);
            for i in 0..n_segs {
                self.arc_segment(
                    cx,
                    cy,
                    theta1 + f64::from(i) * delta_theta / n_segs_dbl,
                    theta1 + f64::from(i + 1) * delta_theta / n_segs_dbl,
                    rx,
                    ry,
                    x_axis_rotation,
                );
            }
        }
        fn arc_segment(
            &mut self,
            xc: f64,
            yc: f64,
            th0: f64,
            th1: f64,
            rx: f64,
            ry: f64,
            x_axis_rotation: f64,
        ) {
            let x1: f64;
            let y1: f64;
            let x2: f64;
            let y2: f64;
            let x3: f64;
            let y3: f64;
            let t: f64;
            let th_half: f64;
            let f: f64;
            let sinf: f64;
            let cosf: f64;
            f = x_axis_rotation * PI / 180.0;
            sinf = f.sin();
            cosf = f.cos();
            th_half = 0.5 * (th1 - th0);
            t = (8.0 / 3.0) * (th_half * 0.5).sin() * (th_half * 0.5).sin() / th_half.sin();
            x1 = rx * (th0.cos() - t * th0.sin());
            y1 = ry * (th0.sin() + t * th0.cos());
            x3 = rx * th1.cos();
            y3 = ry * th1.sin();
            x2 = x3 + rx * (t * th1.sin());
            y2 = y3 + ry * (-t * th1.cos());
            self.curve_to(
                xc + cosf * x1 - sinf * y1,
                yc + sinf * x1 + cosf * y1,
                xc + cosf * x2 - sinf * y2,
                yc + sinf * x2 + cosf * y2,
                xc + cosf * x3 - sinf * y3,
                yc + sinf * x3 + cosf * y3,
            );
        }
        pub fn to_cairo(&self, cr: &cairo::Context) {
            for s in &self.path_commands {
                s.to_cairo(cr);
            }
        }
    }
}
mod path_parser {
    use path_builder::*;
    use std::error::Error;
    use std::fmt::{self, Display, Formatter};
    use std::iter::Enumerate;
    use std::str;
    use std::str::Chars;
    struct PathParser<'b> {
        chars_enumerator: Enumerate<Chars<'b>>,
        lookahead: Option<char>,
        current_pos: Option<usize>,
        builder: &'b mut PathBuilder,
        current_x: f64,
        current_y: f64,
        cubic_reflection_x: f64,
        cubic_reflection_y: f64,
        quadratic_reflection_x: f64,
        quadratic_reflection_y: f64,
        subpath_start_x: f64,
        subpath_start_y: f64,
    }
    impl<'b> PathParser<'b> {
        fn new(builder: &'b mut PathBuilder, path_str: &'b str) -> PathParser<'b> {
            PathParser {
                chars_enumerator: path_str.chars().enumerate(),
                lookahead: None,
                current_pos: None,
                builder,
                current_x: 0.0,
                current_y: 0.0,
                cubic_reflection_x: 0.0,
                cubic_reflection_y: 0.0,
                quadratic_reflection_x: 0.0,
                quadratic_reflection_y: 0.0,
                subpath_start_x: 0.0,
                subpath_start_y: 0.0,
            }
        }
        fn parse(&mut self) -> Result<(), ParseError> {
            self.getchar();
            self.optional_whitespace()?;
            self.moveto_drawto_command_groups()
        }
        fn getchar(&mut self) {
            if let Some((pos, c)) = self.chars_enumerator.next() {
                self.lookahead = Some(c);
                self.current_pos = Some(pos);
            } else {
                self.lookahead = None;
                if self.current_pos.is_none() {
                    self.current_pos = Some(0);
                } else {
                    self.current_pos = Some(self.current_pos.unwrap() + 1);
                }
            }
        }
        fn error(&self, kind: ErrorKind) -> ParseError {
            ParseError {
                position: self.current_pos.unwrap(),
                kind,
            }
        }
        fn match_char(&mut self, c: char) -> bool {
            if let Some(x) = self.lookahead {
                if c == x {
                    self.getchar();
                    return true;
                }
            }
            false
        }
        fn whitespace(&mut self) -> Result<(), ParseError> {
            if let Some(c) = self.lookahead {
                if c.is_whitespace() {
                    if !self.match_char(c) {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(c)",
                                &("rsvg_internals/src/path_parser.rs", 125u32, 17u32),
                            )
                        }
                    };
                    while let Some(c) = self.lookahead {
                        if c.is_whitespace() {
                            if !self.match_char(c) {
                                {
                                    ::rt::begin_panic(
                                        "assertion failed: self.match_char(c)",
                                        &("rsvg_internals/src/path_parser.rs", 129u32, 25u32),
                                    )
                                }
                            };
                            continue;
                        } else {
                            break;
                        }
                    }
                }
            }
            Ok(())
        }
        fn optional_whitespace(&mut self) -> Result<(), ParseError> {
            let _ = self.whitespace();
            Ok(())
        }
        fn optional_comma_whitespace(&mut self) -> Result<(), ParseError> {
            self.optional_whitespace()?;
            if self.lookahead_is(',') {
                self.match_char(',');
                self.optional_whitespace()?;
            }
            Ok(())
        }
        fn lookahead_is(&self, c: char) -> bool {
            if let Some(x) = self.lookahead {
                if x == c {
                    return true;
                }
            }
            false
        }
        fn lookahead_is_digit(&self, d: &mut char) -> bool {
            if let Some(c) = self.lookahead {
                if c.is_digit(10) {
                    *d = c;
                    return true;
                }
            }
            false
        }
        fn lookahead_is_start_of_number(&mut self) -> bool {
            let mut c = ' ';
            self.lookahead_is_digit(&mut c)
                || self.lookahead_is('.')
                || self.lookahead_is('+')
                || self.lookahead_is('-')
        }
        fn number(&mut self) -> Result<f64, ParseError> {
            let mut sign: f64;
            sign = 1.0;
            if self.match_char('+') {
                sign = 1.0;
            } else if self.match_char('-') {
                sign = -1.0;
            }
            let mut value: f64;
            let mut exponent_sign: f64;
            let mut exponent: Option<f64>;
            value = 0.0;
            exponent_sign = 1.0;
            exponent = None;
            let mut c: char = ' ';
            if self.lookahead_is_digit(&mut c) || self.lookahead_is('.') {
                while self.lookahead_is_digit(&mut c) {
                    value = value * 10.0 + f64::from(char_to_digit(c));
                    if !self.match_char(c) {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(c)",
                                &("rsvg_internals/src/path_parser.rs", 210u32, 17u32),
                            )
                        }
                    };
                }
                if self.match_char('.') {
                    let mut fraction: f64 = 1.0;
                    let mut c: char = ' ';
                    while self.lookahead_is_digit(&mut c) {
                        fraction /= 10.0;
                        value += fraction * f64::from(char_to_digit(c));
                        if !self.match_char(c) {
                            {
                                ::rt::begin_panic(
                                    "assertion failed: self.match_char(c)",
                                    &("rsvg_internals/src/path_parser.rs", 223u32, 21u32),
                                )
                            }
                        };
                    }
                }
                if self.match_char('E') || self.match_char('e') {
                    if self.match_char('+') {
                        exponent_sign = 1.0;
                    } else if self.match_char('-') {
                        exponent_sign = -1.0;
                    }
                    let mut c: char = ' ';
                    if self.lookahead_is_digit(&mut c) {
                        let mut exp = 0.0;
                        while self.lookahead_is_digit(&mut c) {
                            exp = exp * 10.0 + f64::from(char_to_digit(c));
                            if !self.match_char(c) {
                                {
                                    ::rt::begin_panic(
                                        "assertion failed: self.match_char(c)",
                                        &("rsvg_internals/src/path_parser.rs", 244u32, 25u32),
                                    )
                                }
                            };
                        }
                        exponent = Some(exp);
                    } else if self.lookahead.is_some() {
                        return Err(self.error(ErrorKind::UnexpectedToken));
                    } else {
                        return Err(self.error(ErrorKind::UnexpectedEof));
                    }
                }
                if let Some(exp) = exponent {
                    Ok(sign * value * 10.0f64.powf(exp * exponent_sign))
                } else {
                    Ok(sign * value)
                }
            } else if self.lookahead.is_some() {
                Err(self.error(ErrorKind::UnexpectedToken))
            } else {
                Err(self.error(ErrorKind::UnexpectedEof))
            }
        }
        fn flag(&mut self) -> Result<bool, ParseError> {
            if self.match_char('0') {
                Ok(false)
            } else if self.match_char('1') {
                Ok(true)
            } else if self.lookahead.is_some() {
                Err(self.error(ErrorKind::UnexpectedToken))
            } else {
                Err(self.error(ErrorKind::UnexpectedEof))
            }
        }
        fn coordinate_pair(&mut self) -> Result<(f64, f64), ParseError> {
            let a = self.number()?;
            self.optional_comma_whitespace()?;
            let b = self.number()?;
            Ok((a, b))
        }
        fn set_current_point(&mut self, x: f64, y: f64) {
            self.current_x = x;
            self.current_y = y;
            self.cubic_reflection_x = self.current_x;
            self.cubic_reflection_y = self.current_y;
            self.quadratic_reflection_x = self.current_x;
            self.quadratic_reflection_y = self.current_y;
        }
        fn set_cubic_reflection_and_current_point(&mut self, x3: f64, y3: f64, x4: f64, y4: f64) {
            self.cubic_reflection_x = x3;
            self.cubic_reflection_y = y3;
            self.current_x = x4;
            self.current_y = y4;
            self.quadratic_reflection_x = self.current_x;
            self.quadratic_reflection_y = self.current_y;
        }
        fn set_quadratic_reflection_and_current_point(&mut self, a: f64, b: f64, c: f64, d: f64) {
            self.quadratic_reflection_x = a;
            self.quadratic_reflection_y = b;
            self.current_x = c;
            self.current_y = d;
            self.cubic_reflection_x = self.current_x;
            self.cubic_reflection_y = self.current_y;
        }
        fn emit_move_to(&mut self, x: f64, y: f64) {
            self.set_current_point(x, y);
            self.subpath_start_x = self.current_x;
            self.subpath_start_y = self.current_y;
            self.builder.move_to(self.current_x, self.current_y);
        }
        fn emit_line_to(&mut self, x: f64, y: f64) {
            self.set_current_point(x, y);
            self.builder.line_to(self.current_x, self.current_y);
        }
        fn emit_curve_to(&mut self, x2: f64, y2: f64, x3: f64, y3: f64, x4: f64, y4: f64) {
            self.set_cubic_reflection_and_current_point(x3, y3, x4, y4);
            self.builder.curve_to(x2, y2, x3, y3, x4, y4);
        }
        fn emit_quadratic_curve_to(&mut self, a: f64, b: f64, c: f64, d: f64) {
            let x2 = (self.current_x + 2.0 * a) / 3.0;
            let y2 = (self.current_y + 2.0 * b) / 3.0;
            let x4 = c;
            let y4 = d;
            let x3 = (x4 + 2.0 * a) / 3.0;
            let y3 = (y4 + 2.0 * b) / 3.0;
            self.set_quadratic_reflection_and_current_point(a, b, c, d);
            self.builder.curve_to(x2, y2, x3, y3, x4, y4);
        }
        fn emit_arc(
            &mut self,
            rx: f64,
            ry: f64,
            x_axis_rotation: f64,
            large_arc: LargeArc,
            sweep: Sweep,
            x: f64,
            y: f64,
        ) {
            let (start_x, start_y) = (self.current_x, self.current_y);
            self.set_current_point(x, y);
            self.builder.arc(
                start_x,
                start_y,
                rx,
                ry,
                x_axis_rotation,
                large_arc,
                sweep,
                self.current_x,
                self.current_y,
            );
        }
        fn emit_close_path(&mut self) {
            let (x, y) = (self.subpath_start_x, self.subpath_start_y);
            self.set_current_point(x, y);
            self.builder.close_path();
        }
        fn lineto_argument_sequence(&mut self, absolute: bool) -> Result<(), ParseError> {
            loop {
                let (mut x, mut y) = self.coordinate_pair()?;
                if !absolute {
                    x += self.current_x;
                    y += self.current_y;
                }
                self.emit_line_to(x, y);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 403u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn moveto_argument_sequence(
            &mut self,
            absolute: bool,
            is_initial_moveto: bool,
        ) -> Result<(), ParseError> {
            let (mut x, mut y) = self.coordinate_pair()?;
            if is_initial_moveto {
                self.emit_move_to(x, y);
            } else {
                if !absolute {
                    x += self.current_x;
                    y += self.current_y;
                }
                self.emit_move_to(x, y);
            }
            self.whitespace()?;
            if self.lookahead_is(',') {
                if !self.match_char(',') {
                    {
                        ::rt::begin_panic(
                            "assertion failed: self.match_char(\',\')",
                            &("rsvg_internals/src/path_parser.rs", 434u32, 13u32),
                        )
                    }
                };
                self.optional_whitespace()?;
                self.lineto_argument_sequence(absolute)
            } else if self.lookahead_is_start_of_number() {
                self.lineto_argument_sequence(absolute)
            } else {
                Ok(())
            }
        }
        fn moveto(&mut self, is_initial_moveto: bool) -> Result<(), ParseError> {
            if self.lookahead_is('M') || self.lookahead_is('m') {
                let absolute = if self.match_char('M') {
                    true
                } else {
                    if !self.match_char('m') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'m\')",
                                &("rsvg_internals/src/path_parser.rs", 449u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.moveto_argument_sequence(absolute, is_initial_moveto)
            } else if self.lookahead.is_some() {
                Err(self.error(ErrorKind::UnexpectedToken))
            } else {
                Err(self.error(ErrorKind::UnexpectedEof))
            }
        }
        fn moveto_drawto_command_group(
            &mut self,
            is_initial_moveto: bool,
        ) -> Result<(), ParseError> {
            self.moveto(is_initial_moveto)?;
            self.optional_whitespace()?;
            self.optional_drawto_commands().map(|_| ())
        }
        fn moveto_drawto_command_groups(&mut self) -> Result<(), ParseError> {
            let mut initial = true;
            loop {
                self.moveto_drawto_command_group(initial)?;
                initial = false;
                self.optional_whitespace()?;
                if self.lookahead.is_none() {
                    break;
                }
            }
            Ok(())
        }
        fn optional_drawto_commands(&mut self) -> Result<bool, ParseError> {
            while self.drawto_command()? {
                self.optional_whitespace()?;
            }
            Ok(false)
        }
        fn drawto_command(&mut self) -> Result<bool, ParseError> {
            Ok(self.close_path()?
                || self.line_to()?
                || self.horizontal_line_to()?
                || self.vertical_line_to()?
                || self.curve_to()?
                || self.smooth_curve_to()?
                || self.quadratic_bezier_curve_to()?
                || self.smooth_quadratic_bezier_curve_to()?
                || self.elliptical_arc()?)
        }
        fn close_path(&mut self) -> Result<bool, ParseError> {
            if self.match_char('Z') || self.match_char('z') {
                self.emit_close_path();
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn line_to(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('L') || self.lookahead_is('l') {
                let absolute = if self.match_char('L') {
                    true
                } else {
                    if !self.match_char('l') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'l\')",
                                &("rsvg_internals/src/path_parser.rs", 519u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.lineto_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn horizontal_lineto_argument_sequence(
            &mut self,
            absolute: bool,
        ) -> Result<(), ParseError> {
            loop {
                let mut x = self.number()?;
                if !absolute {
                    x += self.current_x;
                }
                let y = self.current_y;
                self.emit_line_to(x, y);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 547u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn horizontal_line_to(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('H') || self.lookahead_is('h') {
                let absolute = if self.match_char('H') {
                    true
                } else {
                    if !self.match_char('h') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'h\')",
                                &("rsvg_internals/src/path_parser.rs", 562u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.horizontal_lineto_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn vertical_lineto_argument_sequence(&mut self, absolute: bool) -> Result<(), ParseError> {
            loop {
                let mut y = self.number()?;
                if !absolute {
                    y += self.current_y;
                }
                let x = self.current_x;
                self.emit_line_to(x, y);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 590u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn vertical_line_to(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('V') || self.lookahead_is('v') {
                let absolute = if self.match_char('V') {
                    true
                } else {
                    if !self.match_char('v') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'v\')",
                                &("rsvg_internals/src/path_parser.rs", 605u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.vertical_lineto_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn curveto_argument_sequence(&mut self, absolute: bool) -> Result<(), ParseError> {
            loop {
                let (mut x2, mut y2) = self.coordinate_pair()?;
                self.optional_comma_whitespace()?;
                let (mut x3, mut y3) = self.coordinate_pair()?;
                self.optional_comma_whitespace()?;
                let (mut x4, mut y4) = self.coordinate_pair()?;
                if !absolute {
                    x2 += self.current_x;
                    y2 += self.current_y;
                    x3 += self.current_x;
                    y3 += self.current_y;
                    x4 += self.current_x;
                    y4 += self.current_y;
                }
                self.emit_curve_to(x2, y2, x3, y3, x4, y4);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 644u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn smooth_curveto_argument_sequence(&mut self, absolute: bool) -> Result<(), ParseError> {
            loop {
                let (mut x3, mut y3) = self.coordinate_pair()?;
                self.optional_comma_whitespace()?;
                let (mut x4, mut y4) = self.coordinate_pair()?;
                if !absolute {
                    x3 += self.current_x;
                    y3 += self.current_y;
                    x4 += self.current_x;
                    y4 += self.current_y;
                }
                let (x2, y2) = (
                    self.current_x + self.current_x - self.cubic_reflection_x,
                    self.current_y + self.current_y - self.cubic_reflection_y,
                );
                self.emit_curve_to(x2, y2, x3, y3, x4, y4);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 679u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn curve_to(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('C') || self.lookahead_is('c') {
                let absolute = if self.match_char('C') {
                    true
                } else {
                    if !self.match_char('c') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'c\')",
                                &("rsvg_internals/src/path_parser.rs", 694u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.curveto_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn smooth_curve_to(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('S') || self.lookahead_is('s') {
                let absolute = if self.match_char('S') {
                    true
                } else {
                    if !self.match_char('s') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'s\')",
                                &("rsvg_internals/src/path_parser.rs", 712u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.smooth_curveto_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn quadratic_curveto_argument_sequence(
            &mut self,
            absolute: bool,
        ) -> Result<(), ParseError> {
            loop {
                let (mut a, mut b) = self.coordinate_pair()?;
                self.optional_comma_whitespace()?;
                let (mut c, mut d) = self.coordinate_pair()?;
                if !absolute {
                    a += self.current_x;
                    b += self.current_y;
                    c += self.current_x;
                    d += self.current_y;
                }
                self.emit_quadratic_curve_to(a, b, c, d);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 745u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn quadratic_bezier_curve_to(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('Q') || self.lookahead_is('q') {
                let absolute = if self.match_char('Q') {
                    true
                } else {
                    if !self.match_char('q') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'q\')",
                                &("rsvg_internals/src/path_parser.rs", 760u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.quadratic_curveto_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn smooth_quadratic_curveto_argument_sequence(
            &mut self,
            absolute: bool,
        ) -> Result<(), ParseError> {
            loop {
                let (mut c, mut d) = self.coordinate_pair()?;
                if !absolute {
                    c += self.current_x;
                    d += self.current_y;
                }
                let (a, b) = (
                    self.current_x + self.current_x - self.quadratic_reflection_x,
                    self.current_y + self.current_y - self.quadratic_reflection_y,
                );
                self.emit_quadratic_curve_to(a, b, c, d);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 795u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn smooth_quadratic_bezier_curve_to(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('T') || self.lookahead_is('t') {
                let absolute = if self.match_char('T') {
                    true
                } else {
                    if !self.match_char('t') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'t\')",
                                &("rsvg_internals/src/path_parser.rs", 810u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.smooth_quadratic_curveto_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
        fn elliptical_arc_argument_sequence(&mut self, absolute: bool) -> Result<(), ParseError> {
            loop {
                let rx = self.number()?.abs();
                self.optional_comma_whitespace()?;
                let ry = self.number()?.abs();
                self.optional_comma_whitespace()?;
                let x_axis_rotation = self.number()?;
                self.optional_comma_whitespace()?;
                let large_arc = LargeArc(self.flag()?);
                self.optional_comma_whitespace()?;
                let sweep = if self.flag()? {
                    Sweep::Positive
                } else {
                    Sweep::Negative
                };
                self.optional_comma_whitespace()?;
                let (mut x, mut y) = self.coordinate_pair()?;
                if !absolute {
                    x += self.current_x;
                    y += self.current_y;
                }
                self.emit_arc(rx, ry, x_axis_rotation, large_arc, sweep, x, y);
                self.whitespace()?;
                if self.lookahead_is(',') {
                    if !self.match_char(',') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\',\')",
                                &("rsvg_internals/src/path_parser.rs", 861u32, 17u32),
                            )
                        }
                    };
                    self.optional_whitespace()?;
                } else if !self.lookahead_is_start_of_number() {
                    break;
                }
            }
            Ok(())
        }
        fn elliptical_arc(&mut self) -> Result<bool, ParseError> {
            if self.lookahead_is('A') || self.lookahead_is('a') {
                let absolute = if self.match_char('A') {
                    true
                } else {
                    if !self.match_char('a') {
                        {
                            ::rt::begin_panic(
                                "assertion failed: self.match_char(\'a\')",
                                &("rsvg_internals/src/path_parser.rs", 876u32, 17u32),
                            )
                        }
                    };
                    false
                };
                self.optional_whitespace()?;
                self.elliptical_arc_argument_sequence(absolute)?;
                Ok(true)
            } else {
                Ok(false)
            }
        }
    }
    fn char_to_digit(c: char) -> i32 {
        c as i32 - '0' as i32
    }
    pub enum ErrorKind {
        UnexpectedToken,
        UnexpectedEof,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ErrorKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&ErrorKind::UnexpectedToken,) => {
                    let mut debug_trait_builder = f.debug_tuple("UnexpectedToken");
                    debug_trait_builder.finish()
                }
                (&ErrorKind::UnexpectedEof,) => {
                    let mut debug_trait_builder = f.debug_tuple("UnexpectedEof");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ErrorKind {
        #[inline]
        fn eq(&self, other: &ErrorKind) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    pub struct ParseError {
        pub position: usize,
        pub kind: ErrorKind,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ParseError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ParseError {
                    position: ref __self_0_0,
                    kind: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("ParseError");
                    let _ = debug_trait_builder.field("position", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("kind", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ParseError {
        #[inline]
        fn eq(&self, other: &ParseError) -> bool {
            match *other {
                ParseError {
                    position: ref __self_1_0,
                    kind: ref __self_1_1,
                } => match *self {
                    ParseError {
                        position: ref __self_0_0,
                        kind: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ParseError) -> bool {
            match *other {
                ParseError {
                    position: ref __self_1_0,
                    kind: ref __self_1_1,
                } => match *self {
                    ParseError {
                        position: ref __self_0_0,
                        kind: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl Error for ParseError {
        fn description(&self) -> &str {
            match self.kind {
                ErrorKind::UnexpectedToken => "unexpected token",
                ErrorKind::UnexpectedEof => "unexpected end of data",
            }
        }
    }
    impl Display for ParseError {
        fn fmt(&self, f: &mut Formatter) -> fmt::Result {
            f.write_fmt(::std::fmt::Arguments::new_v1_formatted(
                &["error at position ", ": "],
                &match (&self.position, &self.description()) {
                    (arg0, arg1) => [
                        ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                        ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                    ],
                },
                &[
                    ::std::fmt::rt::v1::Argument {
                        position: ::std::fmt::rt::v1::Position::At(0usize),
                        format: ::std::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::std::fmt::rt::v1::Count::Implied,
                            width: ::std::fmt::rt::v1::Count::Implied,
                        },
                    },
                    ::std::fmt::rt::v1::Argument {
                        position: ::std::fmt::rt::v1::Position::At(1usize),
                        format: ::std::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::std::fmt::rt::v1::Count::Implied,
                            width: ::std::fmt::rt::v1::Count::Implied,
                        },
                    },
                ],
            ))
        }
    }
    pub fn parse_path_into_builder(
        path_str: &str,
        builder: &mut PathBuilder,
    ) -> Result<(), ParseError> {
        let mut parser = PathParser::new(builder, path_str);
        parser.parse()
    }
}
mod pattern {
    use aspect_ratio::*;
    use attributes::Attribute;
    use bbox::*;
    use cairo;
    use cairo::MatrixTrait;
    use cairo::Pattern as CairoPattern;
    use coord_units::CoordUnits;
    use drawing_ctx::DrawingCtx;
    use float_eq_cairo::ApproxEqCairo;
    use handle::RsvgHandle;
    use length::*;
    use node::*;
    use parsers::{parse, parse_and_validate};
    use property_bag::PropertyBag;
    use state::ComputedValues;
    use std::cell::RefCell;
    use std::f64;
    use std::rc::*;
    use viewbox::*;
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct PatternUnits(pub CoordUnits);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PatternUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                PatternUnits(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("PatternUnits");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for PatternUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for PatternUnits {
        #[inline]
        fn clone(&self) -> PatternUnits {
            {
                let _: ::std::clone::AssertParamIsClone<CoordUnits>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for PatternUnits {
        #[inline]
        fn eq(&self, other: &PatternUnits) -> bool {
            match *other {
                PatternUnits(ref __self_1_0) => match *self {
                    PatternUnits(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &PatternUnits) -> bool {
            match *other {
                PatternUnits(ref __self_1_0) => match *self {
                    PatternUnits(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for PatternUnits {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<CoordUnits>;
            }
        }
    }
    impl Default for PatternUnits {
        fn default() -> Self {
            PatternUnits(CoordUnits::ObjectBoundingBox)
        }
    }
    impl From<PatternUnits> for CoordUnits {
        fn from(u: PatternUnits) -> Self {
            u.0
        }
    }
    impl ::parsers::Parse for PatternUnits {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(parser: &mut ::cssparser::Parser, _: ()) -> Result<Self, ::error::AttributeError> {
            Ok(PatternUnits(::coord_units::CoordUnits::parse(parser, ())?))
        }
    }
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct PatternContentUnits(pub CoordUnits);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PatternContentUnits {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                PatternContentUnits(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("PatternContentUnits");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for PatternContentUnits {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for PatternContentUnits {
        #[inline]
        fn clone(&self) -> PatternContentUnits {
            {
                let _: ::std::clone::AssertParamIsClone<CoordUnits>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for PatternContentUnits {
        #[inline]
        fn eq(&self, other: &PatternContentUnits) -> bool {
            match *other {
                PatternContentUnits(ref __self_1_0) => match *self {
                    PatternContentUnits(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &PatternContentUnits) -> bool {
            match *other {
                PatternContentUnits(ref __self_1_0) => match *self {
                    PatternContentUnits(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for PatternContentUnits {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<CoordUnits>;
            }
        }
    }
    impl Default for PatternContentUnits {
        fn default() -> Self {
            PatternContentUnits(CoordUnits::UserSpaceOnUse)
        }
    }
    impl From<PatternContentUnits> for CoordUnits {
        fn from(u: PatternContentUnits) -> Self {
            u.0
        }
    }
    impl ::parsers::Parse for PatternContentUnits {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(parser: &mut ::cssparser::Parser, _: ()) -> Result<Self, ::error::AttributeError> {
            Ok(PatternContentUnits(::coord_units::CoordUnits::parse(
                parser,
                (),
            )?))
        }
    }
    struct Pattern {
        pub units: Option<PatternUnits>,
        pub content_units: Option<PatternContentUnits>,
        pub vbox: Option<Option<ViewBox>>,
        pub preserve_aspect_ratio: Option<AspectRatio>,
        pub affine: Option<cairo::Matrix>,
        pub fallback: Option<String>,
        pub x: Option<RsvgLength>,
        pub y: Option<RsvgLength>,
        pub width: Option<RsvgLength>,
        pub height: Option<RsvgLength>,
        pub node: Option<Weak<Node>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Pattern {
        #[inline]
        fn clone(&self) -> Pattern {
            match *self {
                Pattern {
                    units: ref __self_0_0,
                    content_units: ref __self_0_1,
                    vbox: ref __self_0_2,
                    preserve_aspect_ratio: ref __self_0_3,
                    affine: ref __self_0_4,
                    fallback: ref __self_0_5,
                    x: ref __self_0_6,
                    y: ref __self_0_7,
                    width: ref __self_0_8,
                    height: ref __self_0_9,
                    node: ref __self_0_10,
                } => Pattern {
                    units: ::std::clone::Clone::clone(&(*__self_0_0)),
                    content_units: ::std::clone::Clone::clone(&(*__self_0_1)),
                    vbox: ::std::clone::Clone::clone(&(*__self_0_2)),
                    preserve_aspect_ratio: ::std::clone::Clone::clone(&(*__self_0_3)),
                    affine: ::std::clone::Clone::clone(&(*__self_0_4)),
                    fallback: ::std::clone::Clone::clone(&(*__self_0_5)),
                    x: ::std::clone::Clone::clone(&(*__self_0_6)),
                    y: ::std::clone::Clone::clone(&(*__self_0_7)),
                    width: ::std::clone::Clone::clone(&(*__self_0_8)),
                    height: ::std::clone::Clone::clone(&(*__self_0_9)),
                    node: ::std::clone::Clone::clone(&(*__self_0_10)),
                },
            }
        }
    }
    impl Default for Pattern {
        fn default() -> Pattern {
            Pattern {
                units: Some(PatternUnits::default()),
                content_units: Some(PatternContentUnits::default()),
                vbox: Some(None),
                preserve_aspect_ratio: Some(AspectRatio::default()),
                affine: Some(cairo::Matrix::identity()),
                fallback: None,
                x: Some(RsvgLength::default()),
                y: Some(RsvgLength::default()),
                width: Some(RsvgLength::default()),
                height: Some(RsvgLength::default()),
                node: None,
            }
        }
    }
    macro_rules! fallback_to(( $ dest : expr , $ default : expr ) => (
                             $ dest = $ dest . take (  ) . or ( $ default ) )
                             ;);
    impl Pattern {
        fn unresolved() -> Pattern {
            Pattern {
                units: None,
                content_units: None,
                vbox: None,
                preserve_aspect_ratio: None,
                affine: None,
                fallback: None,
                x: None,
                y: None,
                width: None,
                height: None,
                node: None,
            }
        }
        fn is_resolved(&self) -> bool {
            self.units.is_some()
                && self.content_units.is_some()
                && self.vbox.is_some()
                && self.preserve_aspect_ratio.is_some()
                && self.affine.is_some()
                && self.x.is_some()
                && self.y.is_some()
                && self.width.is_some()
                && self.height.is_some()
                && self.children_are_resolved()
        }
        fn children_are_resolved(&self) -> bool {
            if let Some(ref weak) = self.node {
                let strong_node = &weak.clone().upgrade().unwrap();
                strong_node.has_children()
            } else {
                true
            }
        }
        fn resolve_from_defaults(&mut self) {
            self.resolve_from_fallback(&Pattern::default());
        }
        fn resolve_from_fallback(&mut self, fallback: &Pattern) {
            self.units = self.units.take().or(fallback.units);
            self.content_units = self.content_units.take().or(fallback.content_units);
            self.vbox = self.vbox.take().or(fallback.vbox);
            self.preserve_aspect_ratio = self
                .preserve_aspect_ratio
                .take()
                .or(fallback.preserve_aspect_ratio);
            self.affine = self.affine.take().or(fallback.affine);
            self.x = self.x.take().or(fallback.x);
            self.y = self.y.take().or(fallback.y);
            self.width = self.width.take().or(fallback.width);
            self.height = self.height.take().or(fallback.height);
            self.fallback = fallback.fallback.clone();
            if !self.children_are_resolved() {
                if fallback.node.is_some() {
                    self.node = fallback.node.clone();
                } else {
                    self.node = None;
                }
            }
        }
    }
    pub struct NodePattern {
        pattern: RefCell<Pattern>,
    }
    impl NodePattern {
        pub fn new() -> NodePattern {
            NodePattern {
                pattern: RefCell::new(Pattern::unresolved()),
            }
        }
    }
    impl NodeTrait for NodePattern {
        fn set_atts(
            &self,
            node: &RsvgNode,
            _: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            node.set_overflow_hidden();
            let mut p = self.pattern.borrow_mut();
            p.node = Some(Rc::downgrade(node));
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::PatternUnits => p.units = Some(parse("patternUnits", value, ())?),
                    Attribute::PatternContentUnits => {
                        p.content_units = Some(parse("patternContentUnits", value, ())?)
                    }
                    Attribute::ViewBox => p.vbox = Some(Some(parse("viewBox", value, ())?)),
                    Attribute::PreserveAspectRatio => {
                        p.preserve_aspect_ratio = Some(parse("preserveAspectRatio", value, ())?)
                    }
                    Attribute::PatternTransform => {
                        p.affine = Some(parse("patternTransform", value, ())?)
                    }
                    Attribute::XlinkHref => p.fallback = Some(value.to_owned()),
                    Attribute::X => p.x = Some(parse("x", value, LengthDir::Horizontal)?),
                    Attribute::Y => p.y = Some(parse("y", value, LengthDir::Vertical)?),
                    Attribute::Width => {
                        p.width = Some(parse_and_validate(
                            "width",
                            value,
                            LengthDir::Horizontal,
                            RsvgLength::check_nonnegative,
                        )?)
                    }
                    Attribute::Height => {
                        p.height = Some(parse_and_validate(
                            "height",
                            value,
                            LengthDir::Vertical,
                            RsvgLength::check_nonnegative,
                        )?)
                    }
                    _ => (),
                }
            }
            Ok(())
        }
    }
    fn resolve_pattern(pattern: &Pattern, draw_ctx: &mut DrawingCtx) -> Pattern {
        let mut result = pattern.clone();
        while !result.is_resolved() {
            if let Some(acquired) = draw_ctx.get_acquired_node_of_type(
                result.fallback.as_ref().map(String::as_ref),
                NodeType::Pattern,
            ) {
                acquired.get().with_impl(|i: &NodePattern| {
                    result.resolve_from_fallback(&*i.pattern.borrow())
                });
            } else {
                result.resolve_from_defaults();
            }
        }
        result
    }
    fn set_pattern_on_draw_context(
        pattern: &Pattern,
        values: &ComputedValues,
        draw_ctx: &mut DrawingCtx,
        bbox: &BoundingBox,
    ) -> bool {
        if !pattern.is_resolved() {
            {
                ::rt::begin_panic(
                    "assertion failed: pattern.is_resolved()",
                    &("rsvg_internals/src/pattern.rs", 256u32, 5u32),
                )
            }
        };
        if pattern.node.is_none() {
            return false;
        }
        let units = pattern.units.unwrap();
        let content_units = pattern.content_units.unwrap();
        let pattern_affine = pattern.affine.unwrap();
        let vbox = pattern.vbox.unwrap();
        let preserve_aspect_ratio = pattern.preserve_aspect_ratio.unwrap();
        if units == PatternUnits(CoordUnits::ObjectBoundingBox) {
            draw_ctx.push_view_box(1.0, 1.0);
        }
        let pattern_x = pattern.x.unwrap().normalize(values, draw_ctx);
        let pattern_y = pattern.y.unwrap().normalize(values, draw_ctx);
        let pattern_width = pattern.width.unwrap().normalize(values, draw_ctx);
        let pattern_height = pattern.height.unwrap().normalize(values, draw_ctx);
        if units == PatternUnits(CoordUnits::ObjectBoundingBox) {
            draw_ctx.pop_view_box();
        }
        let bbwscale: f64;
        let bbhscale: f64;
        match units {
            PatternUnits(CoordUnits::ObjectBoundingBox) => {
                let bbrect = bbox.rect.unwrap();
                bbwscale = bbrect.width;
                bbhscale = bbrect.height;
            }
            PatternUnits(CoordUnits::UserSpaceOnUse) => {
                bbwscale = 1.0;
                bbhscale = 1.0;
            }
        }
        let cr = draw_ctx.get_cairo_context();
        let affine = cr.get_matrix();
        let taffine = cairo::Matrix::multiply(&pattern_affine, &affine);
        let mut scwscale = (taffine.xx * taffine.xx + taffine.xy * taffine.xy).sqrt();
        let mut schscale = (taffine.yx * taffine.yx + taffine.yy * taffine.yy).sqrt();
        let pw: i32 = (pattern_width * bbwscale * scwscale) as i32;
        let ph: i32 = (pattern_height * bbhscale * schscale) as i32;
        let scaled_width = pattern_width * bbwscale;
        let scaled_height = pattern_height * bbhscale;
        if scaled_width.abs() < f64::EPSILON
            || scaled_height.abs() < f64::EPSILON
            || pw < 1
            || ph < 1
        {
            return false;
        }
        scwscale = f64::from(pw) / scaled_width;
        schscale = f64::from(ph) / scaled_height;
        let mut affine: cairo::Matrix = cairo::Matrix::identity();
        match units {
            PatternUnits(CoordUnits::ObjectBoundingBox) => {
                let bbrect = bbox.rect.unwrap();
                affine.translate(
                    bbrect.x + pattern_x * bbrect.width,
                    bbrect.y + pattern_y * bbrect.height,
                );
            }
            PatternUnits(CoordUnits::UserSpaceOnUse) => {
                affine.translate(pattern_x, pattern_y);
            }
        }
        affine = cairo::Matrix::multiply(&affine, &pattern_affine);
        let mut caffine: cairo::Matrix;
        let pushed_view_box: bool;
        if let Some(vbox) = vbox {
            let (mut x, mut y, w, h) = preserve_aspect_ratio.compute(
                vbox.0.width,
                vbox.0.height,
                0.0,
                0.0,
                pattern_width * bbwscale,
                pattern_height * bbhscale,
            );
            x -= vbox.0.x * w / vbox.0.width;
            y -= vbox.0.y * h / vbox.0.height;
            caffine = cairo::Matrix::new(w / vbox.0.width, 0.0, 0.0, h / vbox.0.height, x, y);
            draw_ctx.push_view_box(vbox.0.width, vbox.0.height);
            pushed_view_box = true;
        } else if content_units == PatternContentUnits(CoordUnits::ObjectBoundingBox) {
            let bbrect = bbox.rect.unwrap();
            caffine = cairo::Matrix::identity();
            caffine.scale(bbrect.width, bbrect.height);
            draw_ctx.push_view_box(1.0, 1.0);
            pushed_view_box = true;
        } else {
            caffine = cairo::Matrix::identity();
            pushed_view_box = false;
        }
        if !scwscale.approx_eq_cairo(&1.0) || !schscale.approx_eq_cairo(&1.0) {
            let mut scalematrix = cairo::Matrix::identity();
            scalematrix.scale(scwscale, schscale);
            caffine = cairo::Matrix::multiply(&caffine, &scalematrix);
            scalematrix = cairo::Matrix::identity();
            scalematrix.scale(1.0 / scwscale, 1.0 / schscale);
            affine = cairo::Matrix::multiply(&scalematrix, &affine);
        }
        let cr_save = draw_ctx.get_cairo_context();
        let surface = cr_save
            .get_target()
            .create_similar(cairo::Content::ColorAlpha, pw, ph);
        let cr_pattern = cairo::Context::new(&surface);
        draw_ctx.set_cairo_context(&cr_pattern);
        let pattern_node = pattern.node.clone().unwrap().upgrade().unwrap();
        let pattern_cascaded = pattern_node.get_cascaded_values();
        let pattern_values = pattern_cascaded.get();
        cr_pattern.set_matrix(caffine);
        draw_ctx.with_discrete_layer(
            &pattern_node,
            pattern_values,
            false,
            &mut (|dc| {
                pattern_node.draw_children(&pattern_cascaded, dc, false);
            }),
        );
        draw_ctx.set_cairo_context(&cr_save);
        if pushed_view_box {
            draw_ctx.pop_view_box();
        }
        let surface_pattern = cairo::SurfacePattern::create(&surface);
        surface_pattern.set_extend(cairo::Extend::Repeat);
        let mut matrix = affine;
        matrix.invert();
        surface_pattern.set_matrix(matrix);
        surface_pattern.set_filter(cairo::Filter::Best);
        cr_save.set_source(&surface_pattern);
        true
    }
    fn resolve_fallbacks_and_set_pattern(
        pattern: &Pattern,
        values: &ComputedValues,
        draw_ctx: &mut DrawingCtx,
        bbox: &BoundingBox,
    ) -> bool {
        let resolved = resolve_pattern(pattern, draw_ctx);
        set_pattern_on_draw_context(&resolved, values, draw_ctx, bbox)
    }
    pub fn pattern_resolve_fallbacks_and_set_pattern(
        node: &RsvgNode,
        draw_ctx: &mut DrawingCtx,
        bbox: &BoundingBox,
    ) -> bool {
        if !(node.get_type() == NodeType::Pattern) {
            {
                ::rt::begin_panic(
                    "assertion failed: node.get_type() == NodeType::Pattern",
                    &("rsvg_internals/src/pattern.rs", 454u32, 5u32),
                )
            }
        };
        let mut did_set_pattern = false;
        node.with_impl(|node_pattern: &NodePattern| {
            let pattern = &*node_pattern.pattern.borrow();
            let cascaded = node.get_cascaded_values();
            let values = cascaded.get();
            did_set_pattern = resolve_fallbacks_and_set_pattern(pattern, values, draw_ctx, bbox);
        });
        did_set_pattern
    }
}
mod property_bag {
    use attributes::Attribute;
    use glib::translate::*;
    use glib_sys;
    use libc;
    use std::ffi::{CStr, CString};
    use std::ops::Deref;
    use std::ptr;
    use std::slice;
    use std::str::{self, FromStr};
    pub struct PropertyBag<'a>(Vec<(&'a CStr, Attribute, &'a CStr)>);
    pub struct OwnedPropertyBag(Vec<(CString, Attribute, CString)>);
    pub struct PropertyBagIter<'a>(PropertyBagCStrIter<'a>);
    pub struct PropertyBagCStrIter<'a>(slice::Iter<'a, (&'a CStr, Attribute, &'a CStr)>);
    trait Utf8CStrToStr {
        fn to_str_utf8(&self) -> &str;
    }
    impl Utf8CStrToStr for CStr {
        fn to_str_utf8(&self) -> &str {
            unsafe { str::from_utf8_unchecked(self.to_bytes()) }
        }
    }
    impl<'a> PropertyBag<'a> {
        /// Creates an iterable `PropertyBag` from a C array of borrowed C strings.
        ///
        /// With libxml2's SAX parser, the caller's callback for "element start"
        /// gets passed a `xmlChar **` of attribute/value pairs.  Even indices
        /// in the array are pointers to attribute names; odd indices are
        /// pointers to attribute values.  The array terminates with a NULL
        /// element in an even index.
        ///
        /// This function is unsafe because the caller must guarantee the following:
        ///
        /// * `pairs` is a valid pointer, or NULL for an empty array
        ///
        /// * `pairs` has key/value pairs and is NULL terminated
        ///
        /// * Both keys and values are valid UTF-8, nul-terminated C strings
        ///
        /// The lifetime of the `PropertyBag` should be considered the same as the lifetime of the
        /// `pairs` array, as the property bag does not copy the strings - it directly stores pointers
        /// into that array's strings.
        pub unsafe fn new_from_key_value_pairs(
            pairs: *const *const libc::c_char,
        ) -> PropertyBag<'a> {
            let mut array = Vec::new();
            if !pairs.is_null() {
                let mut i = 0;
                loop {
                    let key = *pairs.offset(i);
                    if !key.is_null() {
                        let val = *pairs.offset(i + 1);
                        if !!val.is_null() {
                            {
                                ::rt::begin_panic(
                                    "assertion failed: !val.is_null()",
                                    &("rsvg_internals/src/property_bag.rs", 65u32, 21u32),
                                )
                            }
                        };
                        let key_str = CStr::from_ptr(key);
                        let val_str = CStr::from_ptr(val);
                        if let Ok(attr) = Attribute::from_str(key_str.to_str_utf8()) {
                            array.push((key_str, attr, val_str));
                        }
                    } else {
                        break;
                    }
                    i += 2;
                }
            }
            PropertyBag(array)
        }
        pub fn from_owned(owned: &OwnedPropertyBag) -> PropertyBag {
            let mut array = Vec::new();
            for &(ref k, a, ref v) in &owned.0 {
                array.push((k.deref(), a, v.deref()));
            }
            PropertyBag(array)
        }
        pub fn to_owned(&self) -> OwnedPropertyBag {
            let mut array = Vec::<(CString, Attribute, CString)>::new();
            for &(k, a, v) in &self.0 {
                array.push(((*k).to_owned(), a, (*v).to_owned()));
            }
            OwnedPropertyBag(array)
        }
        pub fn ffi(&self) -> *const PropertyBag {
            self as *const PropertyBag
        }
        pub fn len(&self) -> usize {
            self.0.len()
        }
        pub fn iter(&self) -> PropertyBagIter {
            PropertyBagIter(self.cstr_iter())
        }
        pub fn cstr_iter(&self) -> PropertyBagCStrIter {
            PropertyBagCStrIter(self.0.iter())
        }
    }
    impl<'a> Iterator for PropertyBagIter<'a> {
        type Item = (&'a str, Attribute, &'a str);
        fn next(&mut self) -> Option<Self::Item> {
            self.0
                .next()
                .map(|(k, a, v)| (k.to_str_utf8(), a, v.to_str_utf8()))
        }
    }
    impl<'a> Iterator for PropertyBagCStrIter<'a> {
        type Item = (&'a CStr, Attribute, &'a CStr);
        fn next(&mut self) -> Option<Self::Item> {
            self.0.next().map(|&(k, a, v)| (k, a, v))
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_property_bag_new<'a>(
        atts: *const *const libc::c_char,
    ) -> *const PropertyBag<'a> {
        let pbag = unsafe { PropertyBag::new_from_key_value_pairs(atts) };
        Box::into_raw(Box::new(pbag))
    }
    #[no_mangle]
    pub extern "C" fn rsvg_property_bag_free(pbag: *mut PropertyBag) {
        unsafe {
            let _ = Box::from_raw(pbag);
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_property_bag_iter_begin(
        pbag: *const PropertyBag,
    ) -> *mut PropertyBagCStrIter {
        if !!pbag.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !pbag.is_null()",
                    &("rsvg_internals/src/property_bag.rs", 160u32, 5u32),
                )
            }
        };
        let pbag = unsafe { &*pbag };
        Box::into_raw(Box::new(pbag.cstr_iter()))
    }
    #[no_mangle]
    pub extern "C" fn rsvg_property_bag_iter_next(
        iter: *mut PropertyBagCStrIter,
        out_key: *mut *const libc::c_char,
        out_attr: *mut Attribute,
        out_value: *mut *const libc::c_char,
    ) -> glib_sys::gboolean {
        if !!iter.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !iter.is_null()",
                    &("rsvg_internals/src/property_bag.rs", 173u32, 5u32),
                )
            }
        };
        let iter = unsafe { &mut *iter };
        if let Some((key, attr, val)) = iter.next() {
            unsafe {
                *out_key = key.as_ptr();
                *out_attr = attr;
                *out_value = val.as_ptr();
            }
            true.to_glib()
        } else {
            unsafe {
                *out_key = ptr::null();
                *out_value = ptr::null();
            }
            false.to_glib()
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_property_bag_iter_end(iter: *mut PropertyBagCStrIter) {
        if !!iter.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !iter.is_null()",
                    &("rsvg_internals/src/property_bag.rs", 194u32, 5u32),
                )
            }
        };
        unsafe { Box::from_raw(iter) };
    }
}
mod rect {
    use cairo;
    use cairo::MatrixTrait;
    use float_eq_cairo::ApproxEqCairo;
    pub trait RectangleExt {
        fn is_empty(&self) -> bool;
        fn intersect(&self, rect: &cairo::Rectangle) -> cairo::Rectangle;
        fn union(&self, rect: &cairo::Rectangle) -> cairo::Rectangle;
        fn transform(&self, affine: &cairo::Matrix) -> cairo::Rectangle;
        fn outer(&self) -> cairo::Rectangle;
    }
    impl RectangleExt for cairo::Rectangle {
        fn is_empty(&self) -> bool {
            self.width.approx_eq_cairo(&0.0) || self.height.approx_eq_cairo(&0.0)
        }
        fn intersect(&self, rect: &cairo::Rectangle) -> cairo::Rectangle {
            let (x1, y1, x2, y2) = (
                self.x.max(rect.x),
                self.y.max(rect.y),
                (self.x + self.width).min(rect.x + rect.width),
                (self.y + self.height).min(rect.y + rect.height),
            );
            if x2 > x1 && y2 > y1 {
                cairo::Rectangle {
                    x: x1,
                    y: y1,
                    width: x2 - x1,
                    height: y2 - y1,
                }
            } else {
                cairo::Rectangle {
                    x: 0.0,
                    y: 0.0,
                    width: 0.0,
                    height: 0.0,
                }
            }
        }
        fn union(&self, rect: &cairo::Rectangle) -> cairo::Rectangle {
            let (x1, y1, x2, y2) = (
                self.x.min(rect.x),
                self.y.min(rect.y),
                (self.x + self.width).max(rect.x + rect.width),
                (self.y + self.height).max(rect.y + rect.height),
            );
            cairo::Rectangle {
                x: x1,
                y: y1,
                width: x2 - x1,
                height: y2 - y1,
            }
        }
        fn transform(&self, affine: &cairo::Matrix) -> cairo::Rectangle {
            let points = <[_]>::into_vec(box [
                affine.transform_point(self.x, self.y),
                affine.transform_point(self.x + self.width, self.y),
                affine.transform_point(self.x, self.y + self.height),
                affine.transform_point(self.x + self.width, self.y + self.height),
            ]);
            let (mut xmin, mut ymin, mut xmax, mut ymax) = {
                let (x, y) = points[0];
                (x, y, x, y)
            };
            for i in 1..4 {
                let (x, y) = points[i];
                if x < xmin {
                    xmin = x;
                }
                if x > xmax {
                    xmax = x;
                }
                if y < ymin {
                    ymin = y;
                }
                if y > ymax {
                    ymax = y;
                }
            }
            cairo::Rectangle {
                x: xmin,
                y: ymin,
                width: xmax - xmin,
                height: ymax - ymin,
            }
        }
        fn outer(&self) -> cairo::Rectangle {
            let (x, y) = (self.x.floor(), self.y.floor());
            cairo::Rectangle {
                x,
                y,
                width: (self.x + self.width).ceil() - x,
                height: (self.y + self.height).ceil() - y,
            }
        }
    }
}
mod shapes {
    use attributes::Attribute;
    use cairo;
    use drawing_ctx::DrawingCtx;
    use error::*;
    use handle::RsvgHandle;
    use length::*;
    use marker;
    use node::*;
    use parsers::{self, parse, parse_and_validate};
    use path_builder::*;
    use path_parser;
    use property_bag::PropertyBag;
    use state::ComputedValues;
    use std::cell::Cell;
    use std::cell::RefCell;
    fn render_path_builder(
        builder: &PathBuilder,
        draw_ctx: &mut DrawingCtx,
        node: &RsvgNode,
        values: &ComputedValues,
        render_markers: bool,
        clipping: bool,
    ) {
        draw_ctx.with_discrete_layer(
            node,
            values,
            clipping,
            &mut (|dc| {
                let cr = dc.get_cairo_context();
                dc.set_affine_on_cr(&cr);
                builder.to_cairo(&cr);
                if clipping {
                    cr.set_fill_rule(cairo::FillRule::from(values.clip_rule));
                } else {
                    cr.set_fill_rule(cairo::FillRule::from(values.fill_rule));
                    dc.stroke_and_fill(&cr, values);
                }
            }),
        );
        if render_markers {
            marker::render_markers_for_path_builder(builder, draw_ctx, values, clipping);
        }
    }
    fn render_ellipse(
        cx: f64,
        cy: f64,
        rx: f64,
        ry: f64,
        draw_ctx: &mut DrawingCtx,
        node: &RsvgNode,
        values: &ComputedValues,
        clipping: bool,
    ) {
        if rx <= 0.0 || ry <= 0.0 {
            return;
        }
        let arc_magic: f64 = 0.5522847498;
        let mut builder = PathBuilder::new();
        builder.move_to(cx + rx, cy);
        builder.curve_to(
            cx + rx,
            cy + arc_magic * ry,
            cx + arc_magic * rx,
            cy + ry,
            cx,
            cy + ry,
        );
        builder.curve_to(
            cx - arc_magic * rx,
            cy + ry,
            cx - rx,
            cy + arc_magic * ry,
            cx - rx,
            cy,
        );
        builder.curve_to(
            cx - rx,
            cy - arc_magic * ry,
            cx - arc_magic * rx,
            cy - ry,
            cx,
            cy - ry,
        );
        builder.curve_to(
            cx + arc_magic * rx,
            cy - ry,
            cx + rx,
            cy - arc_magic * ry,
            cx + rx,
            cy,
        );
        builder.close_path();
        render_path_builder(&builder, draw_ctx, node, values, false, clipping);
    }
    pub struct NodePath {
        builder: RefCell<Option<PathBuilder>>,
    }
    impl NodePath {
        pub fn new() -> NodePath {
            NodePath {
                builder: RefCell::new(None),
            }
        }
    }
    impl NodeTrait for NodePath {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                if attr == Attribute::D {
                    let mut builder = PathBuilder::new();
                    if path_parser::parse_path_into_builder(value, &mut builder).is_err() {}
                    *self.builder.borrow_mut() = Some(builder);
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            if let Some(ref builder) = *self.builder.borrow() {
                render_path_builder(builder, draw_ctx, node, values, true, clipping);
            }
        }
    }
    enum PolyKind {
        Open,
        Closed,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for PolyKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&PolyKind::Open,) => {
                    let mut debug_trait_builder = f.debug_tuple("Open");
                    debug_trait_builder.finish()
                }
                (&PolyKind::Closed,) => {
                    let mut debug_trait_builder = f.debug_tuple("Closed");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for PolyKind {
        #[inline]
        fn eq(&self, other: &PolyKind) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    pub struct NodePoly {
        points: RefCell<Option<Vec<(f64, f64)>>>,
        kind: PolyKind,
    }
    impl NodePoly {
        pub fn new_open() -> NodePoly {
            NodePoly {
                points: RefCell::new(None),
                kind: PolyKind::Open,
            }
        }
        pub fn new_closed() -> NodePoly {
            NodePoly {
                points: RefCell::new(None),
                kind: PolyKind::Closed,
            }
        }
    }
    impl NodeTrait for NodePoly {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                if attr == Attribute::Points || attr == Attribute::Verts {
                    let result = parsers::list_of_points(value.trim());
                    match result {
                        Ok(v) => {
                            *self.points.borrow_mut() = Some(v);
                            break;
                        }
                        Err(e) => {
                            return Err(NodeError::parse_error(attr, e));
                        }
                    }
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            if let Some(ref points) = *self.points.borrow() {
                let mut builder = PathBuilder::new();
                for (i, &(x, y)) in points.iter().enumerate() {
                    if i == 0 {
                        builder.move_to(x, y);
                    } else {
                        builder.line_to(x, y);
                    }
                }
                if self.kind == PolyKind::Closed {
                    builder.close_path();
                }
                render_path_builder(&builder, draw_ctx, node, values, true, clipping);
            }
        }
    }
    pub struct NodeLine {
        x1: Cell<RsvgLength>,
        y1: Cell<RsvgLength>,
        x2: Cell<RsvgLength>,
        y2: Cell<RsvgLength>,
    }
    impl NodeLine {
        pub fn new() -> NodeLine {
            NodeLine {
                x1: Cell::new(RsvgLength::default()),
                y1: Cell::new(RsvgLength::default()),
                x2: Cell::new(RsvgLength::default()),
                y2: Cell::new(RsvgLength::default()),
            }
        }
    }
    impl NodeTrait for NodeLine {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::X1 => self.x1.set(parse("x1", value, LengthDir::Horizontal)?),
                    Attribute::Y1 => self.y1.set(parse("y1", value, LengthDir::Vertical)?),
                    Attribute::X2 => self.x2.set(parse("x2", value, LengthDir::Horizontal)?),
                    Attribute::Y2 => self.y2.set(parse("y2", value, LengthDir::Vertical)?),
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let mut builder = PathBuilder::new();
            let x1 = self.x1.get().normalize(values, draw_ctx);
            let y1 = self.y1.get().normalize(values, draw_ctx);
            let x2 = self.x2.get().normalize(values, draw_ctx);
            let y2 = self.y2.get().normalize(values, draw_ctx);
            builder.move_to(x1, y1);
            builder.line_to(x2, y2);
            render_path_builder(&builder, draw_ctx, node, values, true, clipping);
        }
    }
    pub struct NodeRect {
        x: Cell<RsvgLength>,
        y: Cell<RsvgLength>,
        w: Cell<RsvgLength>,
        h: Cell<RsvgLength>,
        rx: Cell<Option<RsvgLength>>,
        ry: Cell<Option<RsvgLength>>,
    }
    impl NodeRect {
        pub fn new() -> NodeRect {
            NodeRect {
                x: Cell::new(RsvgLength::default()),
                y: Cell::new(RsvgLength::default()),
                w: Cell::new(RsvgLength::default()),
                h: Cell::new(RsvgLength::default()),
                rx: Cell::new(None),
                ry: Cell::new(None),
            }
        }
    }
    impl NodeTrait for NodeRect {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::X => self.x.set(parse("x", value, LengthDir::Horizontal)?),
                    Attribute::Y => self.y.set(parse("y", value, LengthDir::Vertical)?),
                    Attribute::Width => self.w.set(parse_and_validate(
                        "width",
                        value,
                        LengthDir::Horizontal,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::Height => self.h.set(parse_and_validate(
                        "height",
                        value,
                        LengthDir::Vertical,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::Rx => self.rx.set(
                        parse_and_validate(
                            "rx",
                            value,
                            LengthDir::Horizontal,
                            RsvgLength::check_nonnegative,
                        ).map(Some)?,
                    ),
                    Attribute::Ry => self.ry.set(
                        parse_and_validate(
                            "ry",
                            value,
                            LengthDir::Vertical,
                            RsvgLength::check_nonnegative,
                        ).map(Some)?,
                    ),
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let x = self.x.get().normalize(values, draw_ctx);
            let y = self.y.get().normalize(values, draw_ctx);
            let w = self.w.get().normalize(values, draw_ctx);
            let h = self.h.get().normalize(values, draw_ctx);
            let mut rx;
            let mut ry;
            match (self.rx.get(), self.ry.get()) {
                (None, None) => {
                    rx = 0.0;
                    ry = 0.0;
                }
                (Some(_rx), None) => {
                    rx = _rx.normalize(values, draw_ctx);
                    ry = _rx.normalize(values, draw_ctx);
                }
                (None, Some(_ry)) => {
                    rx = _ry.normalize(values, draw_ctx);
                    ry = _ry.normalize(values, draw_ctx);
                }
                (Some(_rx), Some(_ry)) => {
                    rx = _rx.normalize(values, draw_ctx);
                    ry = _ry.normalize(values, draw_ctx);
                }
            }
            if w <= 0.0 || h <= 0.0 {
                return;
            }
            if rx < 0.0 || ry < 0.0 {
                return;
            }
            let half_w = w / 2.0;
            let half_h = h / 2.0;
            if rx > half_w {
                rx = half_w;
            }
            if ry > half_h {
                ry = half_h;
            }
            if rx == 0.0 {
                ry = 0.0;
            } else if ry == 0.0 {
                rx = 0.0;
            }
            let mut builder = PathBuilder::new();
            if rx == 0.0 {
                builder.move_to(x, y);
                builder.line_to(x + w, y);
                builder.line_to(x + w, y + h);
                builder.line_to(x, y + h);
                builder.line_to(x, y);
                builder.close_path();
            } else {
                let top_x1 = x + rx;
                let top_x2 = x + w - rx;
                let top_y = y;
                let bottom_x1 = top_x1;
                let bottom_x2 = top_x2;
                let bottom_y = y + h;
                let left_x = x;
                let left_y1 = y + ry;
                let left_y2 = y + h - ry;
                let right_x = x + w;
                let right_y1 = left_y1;
                let right_y2 = left_y2;
                builder.move_to(top_x1, top_y);
                builder.line_to(top_x2, top_y);
                builder.arc(
                    top_x2,
                    top_y,
                    rx,
                    ry,
                    0.0,
                    LargeArc(false),
                    Sweep::Positive,
                    right_x,
                    right_y1,
                );
                builder.line_to(right_x, right_y2);
                builder.arc(
                    right_x,
                    right_y2,
                    rx,
                    ry,
                    0.0,
                    LargeArc(false),
                    Sweep::Positive,
                    bottom_x2,
                    bottom_y,
                );
                builder.line_to(bottom_x1, bottom_y);
                builder.arc(
                    bottom_x1,
                    bottom_y,
                    rx,
                    ry,
                    0.0,
                    LargeArc(false),
                    Sweep::Positive,
                    left_x,
                    left_y2,
                );
                builder.line_to(left_x, left_y1);
                builder.arc(
                    left_x,
                    left_y1,
                    rx,
                    ry,
                    0.0,
                    LargeArc(false),
                    Sweep::Positive,
                    top_x1,
                    top_y,
                );
                builder.close_path();
            }
            render_path_builder(&builder, draw_ctx, node, values, false, clipping);
        }
    }
    pub struct NodeCircle {
        cx: Cell<RsvgLength>,
        cy: Cell<RsvgLength>,
        r: Cell<RsvgLength>,
    }
    impl NodeCircle {
        pub fn new() -> NodeCircle {
            NodeCircle {
                cx: Cell::new(RsvgLength::default()),
                cy: Cell::new(RsvgLength::default()),
                r: Cell::new(RsvgLength::default()),
            }
        }
    }
    impl NodeTrait for NodeCircle {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::Cx => self.cx.set(parse("cx", value, LengthDir::Horizontal)?),
                    Attribute::Cy => self.cy.set(parse("cy", value, LengthDir::Vertical)?),
                    Attribute::R => self.r.set(parse_and_validate(
                        "r",
                        value,
                        LengthDir::Both,
                        RsvgLength::check_nonnegative,
                    )?),
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let cx = self.cx.get().normalize(values, draw_ctx);
            let cy = self.cy.get().normalize(values, draw_ctx);
            let r = self.r.get().normalize(values, draw_ctx);
            render_ellipse(cx, cy, r, r, draw_ctx, node, values, clipping);
        }
    }
    pub struct NodeEllipse {
        cx: Cell<RsvgLength>,
        cy: Cell<RsvgLength>,
        rx: Cell<RsvgLength>,
        ry: Cell<RsvgLength>,
    }
    impl NodeEllipse {
        pub fn new() -> NodeEllipse {
            NodeEllipse {
                cx: Cell::new(RsvgLength::default()),
                cy: Cell::new(RsvgLength::default()),
                rx: Cell::new(RsvgLength::default()),
                ry: Cell::new(RsvgLength::default()),
            }
        }
    }
    impl NodeTrait for NodeEllipse {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::Cx => self.cx.set(parse("cx", value, LengthDir::Horizontal)?),
                    Attribute::Cy => self.cy.set(parse("cy", value, LengthDir::Vertical)?),
                    Attribute::Rx => self.rx.set(parse_and_validate(
                        "rx",
                        value,
                        LengthDir::Horizontal,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::Ry => self.ry.set(parse_and_validate(
                        "ry",
                        value,
                        LengthDir::Vertical,
                        RsvgLength::check_nonnegative,
                    )?),
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let cx = self.cx.get().normalize(values, draw_ctx);
            let cy = self.cy.get().normalize(values, draw_ctx);
            let rx = self.rx.get().normalize(values, draw_ctx);
            let ry = self.ry.get().normalize(values, draw_ctx);
            render_ellipse(cx, cy, rx, ry, draw_ctx, node, values, clipping);
        }
    }
}
mod space {
    use itertools::Itertools;
    use state::XmlSpace;
    /// Implements `xml:space` handling per the SVG spec
    ///
    /// Normalizes a string as it comes out of the XML parser's handler
    /// for character data according to the SVG rules in
    /// <https://www.w3.org/TR/SVG/text.html#WhiteSpace>
    pub fn xml_space_normalize(mode: XmlSpace, s: &str) -> String {
        match mode {
            XmlSpace::Default => normalize_default(s),
            XmlSpace::Preserve => normalize_preserve(s),
        }
    }
    fn normalize_default(s: &str) -> String {
        s.trim()
            .chars()
            .filter(|ch| *ch != '\n')
            .map(|ch| match ch {
                '\t' => ' ',
                c => c,
            })
            .coalesce(|current, next| match (current, next) {
                (' ', ' ') => Ok(' '),
                (_, _) => Err((current, next)),
            })
            .collect::<String>()
    }
    fn normalize_preserve(s: &str) -> String {
        s.chars()
            .map(|ch| match ch {
                '\n' | '\t' => ' ',
                c => c,
            })
            .collect()
    }
}
mod srgb {
    //! Utility functions for dealing with sRGB colors.
    //!
    //! The constant values in this module are taken from http://www.color.org/chardata/rgb/srgb.xalter
    use cairo;
    use filters::context::IRect;
    use surface_utils::{
        iterators::Pixels, shared_surface::SharedImageSurface, ImageSurfaceDataExt, Pixel,
    };
    /// Converts an sRGB color value to a linear sRGB color value (undoes the gamma correction).
    ///
    /// The input and the output are supposed to be in the [0, 1] range.
    #[inline]
    pub fn linearize(c: f64) -> f64 {
        if c <= (12.92 * 0.0031308) {
            c / 12.92
        } else {
            ((c + 0.055) / 1.055).powf(2.4)
        }
    }
    /// Converts a linear sRGB color value to a normal sRGB color value (applies the gamma correction).
    ///
    /// The input and the output are supposed to be in the [0, 1] range.
    #[inline]
    pub fn unlinearize(c: f64) -> f64 {
        if c <= 0.0031308 {
            12.92 * c
        } else {
            1.055 * c.powf(1f64 / 2.4) - 0.055
        }
    }
    /// Applies the function to each pixel component after unpremultiplying.
    ///
    /// The returned surface is transparent everywhere except the rectangle defined by `bounds`.
    fn map_unpremultiplied_components<F>(
        surface: &SharedImageSurface,
        bounds: IRect,
        f: F,
    ) -> Result<cairo::ImageSurface, cairo::Status>
    where
        F: Fn(f64) -> f64,
    {
        let width = surface.width();
        let height = surface.height();
        let mut output_surface = cairo::ImageSurface::create(cairo::Format::ARgb32, width, height)?;
        let output_stride = output_surface.get_stride() as usize;
        {
            let mut output_data = output_surface.get_data().unwrap();
            for (x, y, pixel) in Pixels::new(surface, bounds) {
                if pixel.a > 0 {
                    let alpha = f64::from(pixel.a) / 255f64;
                    let compute = |x| {
                        let x = f64::from(x) / 255f64;
                        let x = x / alpha;
                        let x = f(x);
                        let x = x * alpha;
                        (x * 255f64).round() as u8
                    };
                    let output_pixel = Pixel {
                        r: compute(pixel.r),
                        g: compute(pixel.g),
                        b: compute(pixel.b),
                        a: pixel.a,
                    };
                    output_data.set_pixel(output_stride, output_pixel, x, y);
                }
            }
        }
        Ok(output_surface)
    }
    /// Converts an sRGB surface to a linear sRGB surface (undoes the gamma correction).
    ///
    /// The returned surface is transparent everywhere except the rectangle defined by `bounds`.
    #[inline]
    pub fn linearize_surface(
        surface: &SharedImageSurface,
        bounds: IRect,
    ) -> Result<cairo::ImageSurface, cairo::Status> {
        map_unpremultiplied_components(surface, bounds, linearize)
    }
    /// Converts a linear sRGB surface to a normal sRGB surface (applies the gamma correction).
    ///
    /// The returned surface is transparent everywhere except the rectangle defined by `bounds`.
    #[inline]
    pub fn unlinearize_surface(
        surface: &SharedImageSurface,
        bounds: IRect,
    ) -> Result<cairo::ImageSurface, cairo::Status> {
        map_unpremultiplied_components(surface, bounds, unlinearize)
    }
}
mod state {
    use attributes::Attribute;
    use color::rgba_to_argb;
    use cssparser::{self, Parser, Token};
    use error::*;
    use glib::translate::*;
    use glib_sys;
    use handle::RsvgHandle;
    use iri::IRI;
    use length::{Dasharray, FontSizeSpec, LengthDir, LengthUnit, RsvgLength};
    use libc;
    use node::RsvgNode;
    use paint_server::PaintServer;
    use parsers::{Parse, ParseError};
    use property_bag::PropertyBag;
    use property_macros::Property;
    use std::cell::RefCell;
    use std::collections::HashSet;
    use std::str::FromStr;
    use unitinterval::UnitInterval;
    use util::utf8_cstr;
    /// Representation of a single CSS property value.
    ///
    /// `Unspecified` is the `Default`; it means that the corresponding property is not present.
    ///
    /// `Inherit` means that the property is explicitly set to inherit
    /// from the parent element.  This is useful for properties which the
    /// SVG or CSS specs mandate that should not be inherited by default.
    ///
    /// `Specified` is a value given by the SVG or CSS stylesheet.  This will later be
    /// resolved into part of a `ComputedValues` struct.
    pub enum SpecifiedValue<T>
    where
        T: Property<ComputedValues> + Clone + Default,
    {
        Unspecified,
        Inherit,
        Specified(T),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::std::clone::Clone> ::std::clone::Clone for SpecifiedValue<T>
    where
        T: Property<ComputedValues> + Clone + Default,
    {
        #[inline]
        fn clone(&self) -> SpecifiedValue<T> {
            match (&*self,) {
                (&SpecifiedValue::Unspecified,) => SpecifiedValue::Unspecified,
                (&SpecifiedValue::Inherit,) => SpecifiedValue::Inherit,
                (&SpecifiedValue::Specified(ref __self_0),) => {
                    SpecifiedValue::Specified(::std::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl<T> SpecifiedValue<T>
    where
        T: Property<ComputedValues> + Clone + Default,
    {
        pub fn compute(&self, src: &T, src_values: &ComputedValues) -> T {
            match *self {
                SpecifiedValue::Unspecified => {
                    if <T as Property<ComputedValues>>::inherits_automatically() {
                        src.clone()
                    } else {
                        Default::default()
                    }
                }
                SpecifiedValue::Inherit => src.clone(),
                SpecifiedValue::Specified(ref v) => v.compute(src_values),
            }
        }
    }
    impl<T> Default for SpecifiedValue<T>
    where
        T: Property<ComputedValues> + Clone + Default,
    {
        fn default() -> SpecifiedValue<T> {
            SpecifiedValue::Unspecified
        }
    }
    pub enum RsvgState {}
    /// Holds the state of CSS properties
    ///
    /// This is used for various purposes:
    ///
    /// * Immutably, to store the attributes of element nodes after parsing.
    /// * Mutably, during cascading/rendering.
    ///
    /// Each property should have its own data type, and implement
    /// `Default` and `parsers::Parse`.
    ///
    /// If a property is `None`, is means it was not specified and must be
    /// inherited from the parent state, or in the end the caller can
    /// `.unwrap_or_default()` to get the default value for the property.
    pub struct State {
        pub values: SpecifiedValues,
        important_styles: RefCell<HashSet<Attribute>>,
    }
    pub struct SpecifiedValues {
        pub baseline_shift: SpecifiedValue<BaselineShift>,
        pub clip_path: SpecifiedValue<ClipPath>,
        pub clip_rule: SpecifiedValue<ClipRule>,
        pub comp_op: SpecifiedValue<CompOp>,
        pub color: SpecifiedValue<Color>,
        pub color_interpolation_filters: SpecifiedValue<ColorInterpolationFilters>,
        pub direction: SpecifiedValue<Direction>,
        pub display: SpecifiedValue<Display>,
        pub enable_background: SpecifiedValue<EnableBackground>,
        pub fill: SpecifiedValue<Fill>,
        pub fill_opacity: SpecifiedValue<FillOpacity>,
        pub fill_rule: SpecifiedValue<FillRule>,
        pub filter: SpecifiedValue<Filter>,
        pub flood_color: SpecifiedValue<FloodColor>,
        pub flood_opacity: SpecifiedValue<FloodOpacity>,
        pub font_family: SpecifiedValue<FontFamily>,
        pub font_size: SpecifiedValue<FontSize>,
        pub font_stretch: SpecifiedValue<FontStretch>,
        pub font_style: SpecifiedValue<FontStyle>,
        pub font_variant: SpecifiedValue<FontVariant>,
        pub font_weight: SpecifiedValue<FontWeight>,
        pub letter_spacing: SpecifiedValue<LetterSpacing>,
        pub lighting_color: SpecifiedValue<LightingColor>,
        pub marker_end: SpecifiedValue<MarkerEnd>,
        pub marker_mid: SpecifiedValue<MarkerMid>,
        pub marker_start: SpecifiedValue<MarkerStart>,
        pub mask: SpecifiedValue<Mask>,
        pub opacity: SpecifiedValue<Opacity>,
        pub overflow: SpecifiedValue<Overflow>,
        pub shape_rendering: SpecifiedValue<ShapeRendering>,
        pub stop_color: SpecifiedValue<StopColor>,
        pub stop_opacity: SpecifiedValue<StopOpacity>,
        pub stroke: SpecifiedValue<Stroke>,
        pub stroke_dasharray: SpecifiedValue<StrokeDasharray>,
        pub stroke_dashoffset: SpecifiedValue<StrokeDashoffset>,
        pub stroke_line_cap: SpecifiedValue<StrokeLinecap>,
        pub stroke_line_join: SpecifiedValue<StrokeLinejoin>,
        pub stroke_opacity: SpecifiedValue<StrokeOpacity>,
        pub stroke_miterlimit: SpecifiedValue<StrokeMiterlimit>,
        pub stroke_width: SpecifiedValue<StrokeWidth>,
        pub text_anchor: SpecifiedValue<TextAnchor>,
        pub text_decoration: SpecifiedValue<TextDecoration>,
        pub text_rendering: SpecifiedValue<TextRendering>,
        pub unicode_bidi: SpecifiedValue<UnicodeBidi>,
        pub visibility: SpecifiedValue<Visibility>,
        pub writing_mode: SpecifiedValue<WritingMode>,
        pub xml_lang: SpecifiedValue<XmlLang>,
        pub xml_space: SpecifiedValue<XmlSpace>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::default::Default for SpecifiedValues {
        #[inline]
        fn default() -> SpecifiedValues {
            SpecifiedValues {
                baseline_shift: ::std::default::Default::default(),
                clip_path: ::std::default::Default::default(),
                clip_rule: ::std::default::Default::default(),
                comp_op: ::std::default::Default::default(),
                color: ::std::default::Default::default(),
                color_interpolation_filters: ::std::default::Default::default(),
                direction: ::std::default::Default::default(),
                display: ::std::default::Default::default(),
                enable_background: ::std::default::Default::default(),
                fill: ::std::default::Default::default(),
                fill_opacity: ::std::default::Default::default(),
                fill_rule: ::std::default::Default::default(),
                filter: ::std::default::Default::default(),
                flood_color: ::std::default::Default::default(),
                flood_opacity: ::std::default::Default::default(),
                font_family: ::std::default::Default::default(),
                font_size: ::std::default::Default::default(),
                font_stretch: ::std::default::Default::default(),
                font_style: ::std::default::Default::default(),
                font_variant: ::std::default::Default::default(),
                font_weight: ::std::default::Default::default(),
                letter_spacing: ::std::default::Default::default(),
                lighting_color: ::std::default::Default::default(),
                marker_end: ::std::default::Default::default(),
                marker_mid: ::std::default::Default::default(),
                marker_start: ::std::default::Default::default(),
                mask: ::std::default::Default::default(),
                opacity: ::std::default::Default::default(),
                overflow: ::std::default::Default::default(),
                shape_rendering: ::std::default::Default::default(),
                stop_color: ::std::default::Default::default(),
                stop_opacity: ::std::default::Default::default(),
                stroke: ::std::default::Default::default(),
                stroke_dasharray: ::std::default::Default::default(),
                stroke_dashoffset: ::std::default::Default::default(),
                stroke_line_cap: ::std::default::Default::default(),
                stroke_line_join: ::std::default::Default::default(),
                stroke_opacity: ::std::default::Default::default(),
                stroke_miterlimit: ::std::default::Default::default(),
                stroke_width: ::std::default::Default::default(),
                text_anchor: ::std::default::Default::default(),
                text_decoration: ::std::default::Default::default(),
                text_rendering: ::std::default::Default::default(),
                unicode_bidi: ::std::default::Default::default(),
                visibility: ::std::default::Default::default(),
                writing_mode: ::std::default::Default::default(),
                xml_lang: ::std::default::Default::default(),
                xml_space: ::std::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for SpecifiedValues {
        #[inline]
        fn clone(&self) -> SpecifiedValues {
            match *self {
                SpecifiedValues {
                    baseline_shift: ref __self_0_0,
                    clip_path: ref __self_0_1,
                    clip_rule: ref __self_0_2,
                    comp_op: ref __self_0_3,
                    color: ref __self_0_4,
                    color_interpolation_filters: ref __self_0_5,
                    direction: ref __self_0_6,
                    display: ref __self_0_7,
                    enable_background: ref __self_0_8,
                    fill: ref __self_0_9,
                    fill_opacity: ref __self_0_10,
                    fill_rule: ref __self_0_11,
                    filter: ref __self_0_12,
                    flood_color: ref __self_0_13,
                    flood_opacity: ref __self_0_14,
                    font_family: ref __self_0_15,
                    font_size: ref __self_0_16,
                    font_stretch: ref __self_0_17,
                    font_style: ref __self_0_18,
                    font_variant: ref __self_0_19,
                    font_weight: ref __self_0_20,
                    letter_spacing: ref __self_0_21,
                    lighting_color: ref __self_0_22,
                    marker_end: ref __self_0_23,
                    marker_mid: ref __self_0_24,
                    marker_start: ref __self_0_25,
                    mask: ref __self_0_26,
                    opacity: ref __self_0_27,
                    overflow: ref __self_0_28,
                    shape_rendering: ref __self_0_29,
                    stop_color: ref __self_0_30,
                    stop_opacity: ref __self_0_31,
                    stroke: ref __self_0_32,
                    stroke_dasharray: ref __self_0_33,
                    stroke_dashoffset: ref __self_0_34,
                    stroke_line_cap: ref __self_0_35,
                    stroke_line_join: ref __self_0_36,
                    stroke_opacity: ref __self_0_37,
                    stroke_miterlimit: ref __self_0_38,
                    stroke_width: ref __self_0_39,
                    text_anchor: ref __self_0_40,
                    text_decoration: ref __self_0_41,
                    text_rendering: ref __self_0_42,
                    unicode_bidi: ref __self_0_43,
                    visibility: ref __self_0_44,
                    writing_mode: ref __self_0_45,
                    xml_lang: ref __self_0_46,
                    xml_space: ref __self_0_47,
                } => SpecifiedValues {
                    baseline_shift: ::std::clone::Clone::clone(&(*__self_0_0)),
                    clip_path: ::std::clone::Clone::clone(&(*__self_0_1)),
                    clip_rule: ::std::clone::Clone::clone(&(*__self_0_2)),
                    comp_op: ::std::clone::Clone::clone(&(*__self_0_3)),
                    color: ::std::clone::Clone::clone(&(*__self_0_4)),
                    color_interpolation_filters: ::std::clone::Clone::clone(&(*__self_0_5)),
                    direction: ::std::clone::Clone::clone(&(*__self_0_6)),
                    display: ::std::clone::Clone::clone(&(*__self_0_7)),
                    enable_background: ::std::clone::Clone::clone(&(*__self_0_8)),
                    fill: ::std::clone::Clone::clone(&(*__self_0_9)),
                    fill_opacity: ::std::clone::Clone::clone(&(*__self_0_10)),
                    fill_rule: ::std::clone::Clone::clone(&(*__self_0_11)),
                    filter: ::std::clone::Clone::clone(&(*__self_0_12)),
                    flood_color: ::std::clone::Clone::clone(&(*__self_0_13)),
                    flood_opacity: ::std::clone::Clone::clone(&(*__self_0_14)),
                    font_family: ::std::clone::Clone::clone(&(*__self_0_15)),
                    font_size: ::std::clone::Clone::clone(&(*__self_0_16)),
                    font_stretch: ::std::clone::Clone::clone(&(*__self_0_17)),
                    font_style: ::std::clone::Clone::clone(&(*__self_0_18)),
                    font_variant: ::std::clone::Clone::clone(&(*__self_0_19)),
                    font_weight: ::std::clone::Clone::clone(&(*__self_0_20)),
                    letter_spacing: ::std::clone::Clone::clone(&(*__self_0_21)),
                    lighting_color: ::std::clone::Clone::clone(&(*__self_0_22)),
                    marker_end: ::std::clone::Clone::clone(&(*__self_0_23)),
                    marker_mid: ::std::clone::Clone::clone(&(*__self_0_24)),
                    marker_start: ::std::clone::Clone::clone(&(*__self_0_25)),
                    mask: ::std::clone::Clone::clone(&(*__self_0_26)),
                    opacity: ::std::clone::Clone::clone(&(*__self_0_27)),
                    overflow: ::std::clone::Clone::clone(&(*__self_0_28)),
                    shape_rendering: ::std::clone::Clone::clone(&(*__self_0_29)),
                    stop_color: ::std::clone::Clone::clone(&(*__self_0_30)),
                    stop_opacity: ::std::clone::Clone::clone(&(*__self_0_31)),
                    stroke: ::std::clone::Clone::clone(&(*__self_0_32)),
                    stroke_dasharray: ::std::clone::Clone::clone(&(*__self_0_33)),
                    stroke_dashoffset: ::std::clone::Clone::clone(&(*__self_0_34)),
                    stroke_line_cap: ::std::clone::Clone::clone(&(*__self_0_35)),
                    stroke_line_join: ::std::clone::Clone::clone(&(*__self_0_36)),
                    stroke_opacity: ::std::clone::Clone::clone(&(*__self_0_37)),
                    stroke_miterlimit: ::std::clone::Clone::clone(&(*__self_0_38)),
                    stroke_width: ::std::clone::Clone::clone(&(*__self_0_39)),
                    text_anchor: ::std::clone::Clone::clone(&(*__self_0_40)),
                    text_decoration: ::std::clone::Clone::clone(&(*__self_0_41)),
                    text_rendering: ::std::clone::Clone::clone(&(*__self_0_42)),
                    unicode_bidi: ::std::clone::Clone::clone(&(*__self_0_43)),
                    visibility: ::std::clone::Clone::clone(&(*__self_0_44)),
                    writing_mode: ::std::clone::Clone::clone(&(*__self_0_45)),
                    xml_lang: ::std::clone::Clone::clone(&(*__self_0_46)),
                    xml_space: ::std::clone::Clone::clone(&(*__self_0_47)),
                },
            }
        }
    }
    pub type RsvgComputedValues = *const ComputedValues;
    pub struct ComputedValues {
        pub baseline_shift: BaselineShift,
        pub clip_path: ClipPath,
        pub clip_rule: ClipRule,
        pub comp_op: CompOp,
        pub color: Color,
        pub color_interpolation_filters: ColorInterpolationFilters,
        pub direction: Direction,
        pub display: Display,
        pub enable_background: EnableBackground,
        pub fill: Fill,
        pub fill_opacity: FillOpacity,
        pub fill_rule: FillRule,
        pub filter: Filter,
        pub flood_color: FloodColor,
        pub flood_opacity: FloodOpacity,
        pub font_family: FontFamily,
        pub font_size: FontSize,
        pub font_stretch: FontStretch,
        pub font_style: FontStyle,
        pub font_variant: FontVariant,
        pub font_weight: FontWeight,
        pub letter_spacing: LetterSpacing,
        pub lighting_color: LightingColor,
        pub marker_end: MarkerEnd,
        pub marker_mid: MarkerMid,
        pub marker_start: MarkerStart,
        pub mask: Mask,
        pub opacity: Opacity,
        pub overflow: Overflow,
        pub shape_rendering: ShapeRendering,
        pub stop_color: StopColor,
        pub stop_opacity: StopOpacity,
        pub stroke: Stroke,
        pub stroke_dasharray: StrokeDasharray,
        pub stroke_dashoffset: StrokeDashoffset,
        pub stroke_line_cap: StrokeLinecap,
        pub stroke_line_join: StrokeLinejoin,
        pub stroke_opacity: StrokeOpacity,
        pub stroke_miterlimit: StrokeMiterlimit,
        pub stroke_width: StrokeWidth,
        pub text_anchor: TextAnchor,
        pub text_decoration: TextDecoration,
        pub text_rendering: TextRendering,
        pub unicode_bidi: UnicodeBidi,
        pub visibility: Visibility,
        pub writing_mode: WritingMode,
        pub xml_lang: XmlLang,
        pub xml_space: XmlSpace,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ComputedValues {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ComputedValues {
                    baseline_shift: ref __self_0_0,
                    clip_path: ref __self_0_1,
                    clip_rule: ref __self_0_2,
                    comp_op: ref __self_0_3,
                    color: ref __self_0_4,
                    color_interpolation_filters: ref __self_0_5,
                    direction: ref __self_0_6,
                    display: ref __self_0_7,
                    enable_background: ref __self_0_8,
                    fill: ref __self_0_9,
                    fill_opacity: ref __self_0_10,
                    fill_rule: ref __self_0_11,
                    filter: ref __self_0_12,
                    flood_color: ref __self_0_13,
                    flood_opacity: ref __self_0_14,
                    font_family: ref __self_0_15,
                    font_size: ref __self_0_16,
                    font_stretch: ref __self_0_17,
                    font_style: ref __self_0_18,
                    font_variant: ref __self_0_19,
                    font_weight: ref __self_0_20,
                    letter_spacing: ref __self_0_21,
                    lighting_color: ref __self_0_22,
                    marker_end: ref __self_0_23,
                    marker_mid: ref __self_0_24,
                    marker_start: ref __self_0_25,
                    mask: ref __self_0_26,
                    opacity: ref __self_0_27,
                    overflow: ref __self_0_28,
                    shape_rendering: ref __self_0_29,
                    stop_color: ref __self_0_30,
                    stop_opacity: ref __self_0_31,
                    stroke: ref __self_0_32,
                    stroke_dasharray: ref __self_0_33,
                    stroke_dashoffset: ref __self_0_34,
                    stroke_line_cap: ref __self_0_35,
                    stroke_line_join: ref __self_0_36,
                    stroke_opacity: ref __self_0_37,
                    stroke_miterlimit: ref __self_0_38,
                    stroke_width: ref __self_0_39,
                    text_anchor: ref __self_0_40,
                    text_decoration: ref __self_0_41,
                    text_rendering: ref __self_0_42,
                    unicode_bidi: ref __self_0_43,
                    visibility: ref __self_0_44,
                    writing_mode: ref __self_0_45,
                    xml_lang: ref __self_0_46,
                    xml_space: ref __self_0_47,
                } => {
                    let mut debug_trait_builder = f.debug_struct("ComputedValues");
                    let _ = debug_trait_builder.field("baseline_shift", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("clip_path", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("clip_rule", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("comp_op", &&(*__self_0_3));
                    let _ = debug_trait_builder.field("color", &&(*__self_0_4));
                    let _ =
                        debug_trait_builder.field("color_interpolation_filters", &&(*__self_0_5));
                    let _ = debug_trait_builder.field("direction", &&(*__self_0_6));
                    let _ = debug_trait_builder.field("display", &&(*__self_0_7));
                    let _ = debug_trait_builder.field("enable_background", &&(*__self_0_8));
                    let _ = debug_trait_builder.field("fill", &&(*__self_0_9));
                    let _ = debug_trait_builder.field("fill_opacity", &&(*__self_0_10));
                    let _ = debug_trait_builder.field("fill_rule", &&(*__self_0_11));
                    let _ = debug_trait_builder.field("filter", &&(*__self_0_12));
                    let _ = debug_trait_builder.field("flood_color", &&(*__self_0_13));
                    let _ = debug_trait_builder.field("flood_opacity", &&(*__self_0_14));
                    let _ = debug_trait_builder.field("font_family", &&(*__self_0_15));
                    let _ = debug_trait_builder.field("font_size", &&(*__self_0_16));
                    let _ = debug_trait_builder.field("font_stretch", &&(*__self_0_17));
                    let _ = debug_trait_builder.field("font_style", &&(*__self_0_18));
                    let _ = debug_trait_builder.field("font_variant", &&(*__self_0_19));
                    let _ = debug_trait_builder.field("font_weight", &&(*__self_0_20));
                    let _ = debug_trait_builder.field("letter_spacing", &&(*__self_0_21));
                    let _ = debug_trait_builder.field("lighting_color", &&(*__self_0_22));
                    let _ = debug_trait_builder.field("marker_end", &&(*__self_0_23));
                    let _ = debug_trait_builder.field("marker_mid", &&(*__self_0_24));
                    let _ = debug_trait_builder.field("marker_start", &&(*__self_0_25));
                    let _ = debug_trait_builder.field("mask", &&(*__self_0_26));
                    let _ = debug_trait_builder.field("opacity", &&(*__self_0_27));
                    let _ = debug_trait_builder.field("overflow", &&(*__self_0_28));
                    let _ = debug_trait_builder.field("shape_rendering", &&(*__self_0_29));
                    let _ = debug_trait_builder.field("stop_color", &&(*__self_0_30));
                    let _ = debug_trait_builder.field("stop_opacity", &&(*__self_0_31));
                    let _ = debug_trait_builder.field("stroke", &&(*__self_0_32));
                    let _ = debug_trait_builder.field("stroke_dasharray", &&(*__self_0_33));
                    let _ = debug_trait_builder.field("stroke_dashoffset", &&(*__self_0_34));
                    let _ = debug_trait_builder.field("stroke_line_cap", &&(*__self_0_35));
                    let _ = debug_trait_builder.field("stroke_line_join", &&(*__self_0_36));
                    let _ = debug_trait_builder.field("stroke_opacity", &&(*__self_0_37));
                    let _ = debug_trait_builder.field("stroke_miterlimit", &&(*__self_0_38));
                    let _ = debug_trait_builder.field("stroke_width", &&(*__self_0_39));
                    let _ = debug_trait_builder.field("text_anchor", &&(*__self_0_40));
                    let _ = debug_trait_builder.field("text_decoration", &&(*__self_0_41));
                    let _ = debug_trait_builder.field("text_rendering", &&(*__self_0_42));
                    let _ = debug_trait_builder.field("unicode_bidi", &&(*__self_0_43));
                    let _ = debug_trait_builder.field("visibility", &&(*__self_0_44));
                    let _ = debug_trait_builder.field("writing_mode", &&(*__self_0_45));
                    let _ = debug_trait_builder.field("xml_lang", &&(*__self_0_46));
                    let _ = debug_trait_builder.field("xml_space", &&(*__self_0_47));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ComputedValues {
        #[inline]
        fn clone(&self) -> ComputedValues {
            match *self {
                ComputedValues {
                    baseline_shift: ref __self_0_0,
                    clip_path: ref __self_0_1,
                    clip_rule: ref __self_0_2,
                    comp_op: ref __self_0_3,
                    color: ref __self_0_4,
                    color_interpolation_filters: ref __self_0_5,
                    direction: ref __self_0_6,
                    display: ref __self_0_7,
                    enable_background: ref __self_0_8,
                    fill: ref __self_0_9,
                    fill_opacity: ref __self_0_10,
                    fill_rule: ref __self_0_11,
                    filter: ref __self_0_12,
                    flood_color: ref __self_0_13,
                    flood_opacity: ref __self_0_14,
                    font_family: ref __self_0_15,
                    font_size: ref __self_0_16,
                    font_stretch: ref __self_0_17,
                    font_style: ref __self_0_18,
                    font_variant: ref __self_0_19,
                    font_weight: ref __self_0_20,
                    letter_spacing: ref __self_0_21,
                    lighting_color: ref __self_0_22,
                    marker_end: ref __self_0_23,
                    marker_mid: ref __self_0_24,
                    marker_start: ref __self_0_25,
                    mask: ref __self_0_26,
                    opacity: ref __self_0_27,
                    overflow: ref __self_0_28,
                    shape_rendering: ref __self_0_29,
                    stop_color: ref __self_0_30,
                    stop_opacity: ref __self_0_31,
                    stroke: ref __self_0_32,
                    stroke_dasharray: ref __self_0_33,
                    stroke_dashoffset: ref __self_0_34,
                    stroke_line_cap: ref __self_0_35,
                    stroke_line_join: ref __self_0_36,
                    stroke_opacity: ref __self_0_37,
                    stroke_miterlimit: ref __self_0_38,
                    stroke_width: ref __self_0_39,
                    text_anchor: ref __self_0_40,
                    text_decoration: ref __self_0_41,
                    text_rendering: ref __self_0_42,
                    unicode_bidi: ref __self_0_43,
                    visibility: ref __self_0_44,
                    writing_mode: ref __self_0_45,
                    xml_lang: ref __self_0_46,
                    xml_space: ref __self_0_47,
                } => ComputedValues {
                    baseline_shift: ::std::clone::Clone::clone(&(*__self_0_0)),
                    clip_path: ::std::clone::Clone::clone(&(*__self_0_1)),
                    clip_rule: ::std::clone::Clone::clone(&(*__self_0_2)),
                    comp_op: ::std::clone::Clone::clone(&(*__self_0_3)),
                    color: ::std::clone::Clone::clone(&(*__self_0_4)),
                    color_interpolation_filters: ::std::clone::Clone::clone(&(*__self_0_5)),
                    direction: ::std::clone::Clone::clone(&(*__self_0_6)),
                    display: ::std::clone::Clone::clone(&(*__self_0_7)),
                    enable_background: ::std::clone::Clone::clone(&(*__self_0_8)),
                    fill: ::std::clone::Clone::clone(&(*__self_0_9)),
                    fill_opacity: ::std::clone::Clone::clone(&(*__self_0_10)),
                    fill_rule: ::std::clone::Clone::clone(&(*__self_0_11)),
                    filter: ::std::clone::Clone::clone(&(*__self_0_12)),
                    flood_color: ::std::clone::Clone::clone(&(*__self_0_13)),
                    flood_opacity: ::std::clone::Clone::clone(&(*__self_0_14)),
                    font_family: ::std::clone::Clone::clone(&(*__self_0_15)),
                    font_size: ::std::clone::Clone::clone(&(*__self_0_16)),
                    font_stretch: ::std::clone::Clone::clone(&(*__self_0_17)),
                    font_style: ::std::clone::Clone::clone(&(*__self_0_18)),
                    font_variant: ::std::clone::Clone::clone(&(*__self_0_19)),
                    font_weight: ::std::clone::Clone::clone(&(*__self_0_20)),
                    letter_spacing: ::std::clone::Clone::clone(&(*__self_0_21)),
                    lighting_color: ::std::clone::Clone::clone(&(*__self_0_22)),
                    marker_end: ::std::clone::Clone::clone(&(*__self_0_23)),
                    marker_mid: ::std::clone::Clone::clone(&(*__self_0_24)),
                    marker_start: ::std::clone::Clone::clone(&(*__self_0_25)),
                    mask: ::std::clone::Clone::clone(&(*__self_0_26)),
                    opacity: ::std::clone::Clone::clone(&(*__self_0_27)),
                    overflow: ::std::clone::Clone::clone(&(*__self_0_28)),
                    shape_rendering: ::std::clone::Clone::clone(&(*__self_0_29)),
                    stop_color: ::std::clone::Clone::clone(&(*__self_0_30)),
                    stop_opacity: ::std::clone::Clone::clone(&(*__self_0_31)),
                    stroke: ::std::clone::Clone::clone(&(*__self_0_32)),
                    stroke_dasharray: ::std::clone::Clone::clone(&(*__self_0_33)),
                    stroke_dashoffset: ::std::clone::Clone::clone(&(*__self_0_34)),
                    stroke_line_cap: ::std::clone::Clone::clone(&(*__self_0_35)),
                    stroke_line_join: ::std::clone::Clone::clone(&(*__self_0_36)),
                    stroke_opacity: ::std::clone::Clone::clone(&(*__self_0_37)),
                    stroke_miterlimit: ::std::clone::Clone::clone(&(*__self_0_38)),
                    stroke_width: ::std::clone::Clone::clone(&(*__self_0_39)),
                    text_anchor: ::std::clone::Clone::clone(&(*__self_0_40)),
                    text_decoration: ::std::clone::Clone::clone(&(*__self_0_41)),
                    text_rendering: ::std::clone::Clone::clone(&(*__self_0_42)),
                    unicode_bidi: ::std::clone::Clone::clone(&(*__self_0_43)),
                    visibility: ::std::clone::Clone::clone(&(*__self_0_44)),
                    writing_mode: ::std::clone::Clone::clone(&(*__self_0_45)),
                    xml_lang: ::std::clone::Clone::clone(&(*__self_0_46)),
                    xml_space: ::std::clone::Clone::clone(&(*__self_0_47)),
                },
            }
        }
    }
    impl ComputedValues {
        pub fn is_overflow(&self) -> bool {
            match self.overflow {
                Overflow::Auto | Overflow::Visible => true,
                _ => false,
            }
        }
        pub fn is_visible(&self) -> bool {
            match (self.display, self.visibility) {
                (Display::None, _) => false,
                (_, Visibility::Visible) => true,
                _ => false,
            }
        }
        pub fn text_gravity_is_vertical(&self) -> bool {
            match self.writing_mode {
                WritingMode::Tb | WritingMode::TbRl => true,
                _ => false,
            }
        }
    }
    impl Default for ComputedValues {
        fn default() -> ComputedValues {
            ComputedValues {
                baseline_shift: Default::default(),
                clip_path: Default::default(),
                clip_rule: Default::default(),
                color: Default::default(),
                color_interpolation_filters: Default::default(),
                comp_op: Default::default(),
                direction: Default::default(),
                display: Default::default(),
                enable_background: Default::default(),
                fill: Default::default(),
                fill_opacity: Default::default(),
                fill_rule: Default::default(),
                filter: Default::default(),
                flood_color: Default::default(),
                flood_opacity: Default::default(),
                font_family: Default::default(),
                font_size: Default::default(),
                font_stretch: Default::default(),
                font_style: Default::default(),
                font_variant: Default::default(),
                font_weight: Default::default(),
                letter_spacing: Default::default(),
                lighting_color: Default::default(),
                marker_end: Default::default(),
                marker_mid: Default::default(),
                marker_start: Default::default(),
                mask: Default::default(),
                opacity: Default::default(),
                overflow: Default::default(),
                shape_rendering: Default::default(),
                stop_color: Default::default(),
                stop_opacity: Default::default(),
                stroke: Default::default(),
                stroke_dasharray: Default::default(),
                stroke_dashoffset: Default::default(),
                stroke_line_cap: Default::default(),
                stroke_line_join: Default::default(),
                stroke_opacity: Default::default(),
                stroke_miterlimit: Default::default(),
                stroke_width: Default::default(),
                text_anchor: Default::default(),
                text_decoration: Default::default(),
                text_rendering: Default::default(),
                unicode_bidi: Default::default(),
                visibility: Default::default(),
                writing_mode: Default::default(),
                xml_lang: Default::default(),
                xml_space: Default::default(),
            }
        }
    }
    macro_rules! compute_value((
                               $ self : ident , $ computed : ident , $ name :
                               ident ) => {
                               $ computed . $ name = $ self . $ name . compute
                               ( & $ computed . $ name , & $ computed ) } ;);
    impl SpecifiedValues {
        pub fn to_computed_values(&self, computed: &mut ComputedValues) {
            computed.baseline_shift = self
                .baseline_shift
                .compute(&computed.baseline_shift, &computed);
            computed.clip_path = self.clip_path.compute(&computed.clip_path, &computed);
            computed.clip_rule = self.clip_rule.compute(&computed.clip_rule, &computed);
            computed.comp_op = self.comp_op.compute(&computed.comp_op, &computed);
            computed.color = self.color.compute(&computed.color, &computed);
            computed.color_interpolation_filters = self
                .color_interpolation_filters
                .compute(&computed.color_interpolation_filters, &computed);
            computed.direction = self.direction.compute(&computed.direction, &computed);
            computed.display = self.display.compute(&computed.display, &computed);
            computed.enable_background = self
                .enable_background
                .compute(&computed.enable_background, &computed);
            computed.fill = self.fill.compute(&computed.fill, &computed);
            computed.fill_opacity = self.fill_opacity.compute(&computed.fill_opacity, &computed);
            computed.fill_rule = self.fill_rule.compute(&computed.fill_rule, &computed);
            computed.filter = self.filter.compute(&computed.filter, &computed);
            computed.flood_color = self.flood_color.compute(&computed.flood_color, &computed);
            computed.flood_opacity = self
                .flood_opacity
                .compute(&computed.flood_opacity, &computed);
            computed.font_family = self.font_family.compute(&computed.font_family, &computed);
            computed.font_size = self.font_size.compute(&computed.font_size, &computed);
            computed.font_stretch = self.font_stretch.compute(&computed.font_stretch, &computed);
            computed.font_style = self.font_style.compute(&computed.font_style, &computed);
            computed.font_variant = self.font_variant.compute(&computed.font_variant, &computed);
            computed.font_weight = self.font_weight.compute(&computed.font_weight, &computed);
            computed.letter_spacing = self
                .letter_spacing
                .compute(&computed.letter_spacing, &computed);
            computed.lighting_color = self
                .lighting_color
                .compute(&computed.lighting_color, &computed);
            computed.marker_end = self.marker_end.compute(&computed.marker_end, &computed);
            computed.marker_mid = self.marker_mid.compute(&computed.marker_mid, &computed);
            computed.marker_start = self.marker_start.compute(&computed.marker_start, &computed);
            computed.mask = self.mask.compute(&computed.mask, &computed);
            computed.opacity = self.opacity.compute(&computed.opacity, &computed);
            computed.overflow = self.overflow.compute(&computed.overflow, &computed);
            computed.shape_rendering = self
                .shape_rendering
                .compute(&computed.shape_rendering, &computed);
            computed.stop_color = self.stop_color.compute(&computed.stop_color, &computed);
            computed.stop_opacity = self.stop_opacity.compute(&computed.stop_opacity, &computed);
            computed.stroke = self.stroke.compute(&computed.stroke, &computed);
            computed.stroke_dasharray = self
                .stroke_dasharray
                .compute(&computed.stroke_dasharray, &computed);
            computed.stroke_dashoffset = self
                .stroke_dashoffset
                .compute(&computed.stroke_dashoffset, &computed);
            computed.stroke_line_cap = self
                .stroke_line_cap
                .compute(&computed.stroke_line_cap, &computed);
            computed.stroke_line_join = self
                .stroke_line_join
                .compute(&computed.stroke_line_join, &computed);
            computed.stroke_opacity = self
                .stroke_opacity
                .compute(&computed.stroke_opacity, &computed);
            computed.stroke_miterlimit = self
                .stroke_miterlimit
                .compute(&computed.stroke_miterlimit, &computed);
            computed.stroke_width = self.stroke_width.compute(&computed.stroke_width, &computed);
            computed.text_anchor = self.text_anchor.compute(&computed.text_anchor, &computed);
            computed.text_decoration = self
                .text_decoration
                .compute(&computed.text_decoration, &computed);
            computed.text_rendering = self
                .text_rendering
                .compute(&computed.text_rendering, &computed);
            computed.unicode_bidi = self.unicode_bidi.compute(&computed.unicode_bidi, &computed);
            computed.visibility = self.visibility.compute(&computed.visibility, &computed);
            computed.writing_mode = self.writing_mode.compute(&computed.writing_mode, &computed);
            computed.xml_lang = self.xml_lang.compute(&computed.xml_lang, &computed);
            computed.xml_space = self.xml_space.compute(&computed.xml_space, &computed);
        }
        pub fn is_overflow(&self) -> bool {
            match self.overflow {
                SpecifiedValue::Specified(Overflow::Auto)
                | SpecifiedValue::Specified(Overflow::Visible) => true,
                _ => false,
            }
        }
    }
    impl State {
        fn new() -> State {
            State {
                values: Default::default(),
                important_styles: Default::default(),
            }
        }
        fn parse_style_pair(
            &mut self,
            attr: Attribute,
            value: &str,
            important: bool,
            accept_shorthands: bool,
        ) -> Result<(), NodeError> {
            if !important && self.important_styles.borrow().contains(&attr) {
                return Ok(());
            }
            if important {
                self.important_styles.borrow_mut().insert(attr);
            }
            let mut parse = || -> Result<(), AttributeError> {
                match attr {
                    Attribute::BaselineShift => {
                        self.values.baseline_shift = parse_property(value, ())?;
                    }
                    Attribute::ClipPath => {
                        self.values.clip_path = parse_property(value, ())?;
                    }
                    Attribute::ClipRule => {
                        self.values.clip_rule = parse_property(value, ())?;
                    }
                    Attribute::Color => {
                        self.values.color = parse_property(value, ())?;
                    }
                    Attribute::ColorInterpolationFilters => {
                        self.values.color_interpolation_filters = parse_property(value, ())?;
                    }
                    Attribute::CompOp => {
                        self.values.comp_op = parse_property(value, ())?;
                    }
                    Attribute::Direction => {
                        self.values.direction = parse_property(value, ())?;
                    }
                    Attribute::Display => {
                        self.values.display = parse_property(value, ())?;
                    }
                    Attribute::EnableBackground => {
                        self.values.enable_background = parse_property(value, ())?;
                    }
                    Attribute::Fill => {
                        self.values.fill = parse_property(value, ())?;
                    }
                    Attribute::FillOpacity => {
                        self.values.fill_opacity = parse_property(value, ())?;
                    }
                    Attribute::FillRule => {
                        self.values.fill_rule = parse_property(value, ())?;
                    }
                    Attribute::Filter => {
                        self.values.filter = parse_property(value, ())?;
                    }
                    Attribute::FloodColor => {
                        self.values.flood_color = parse_property(value, ())?;
                    }
                    Attribute::FloodOpacity => {
                        self.values.flood_opacity = parse_property(value, ())?;
                    }
                    Attribute::FontFamily => {
                        self.values.font_family = parse_property(value, ())?;
                    }
                    Attribute::FontSize => {
                        self.values.font_size = parse_property(value, ())?;
                    }
                    Attribute::FontStretch => {
                        self.values.font_stretch = parse_property(value, ())?;
                    }
                    Attribute::FontStyle => {
                        self.values.font_style = parse_property(value, ())?;
                    }
                    Attribute::FontVariant => {
                        self.values.font_variant = parse_property(value, ())?;
                    }
                    Attribute::FontWeight => {
                        self.values.font_weight = parse_property(value, ())?;
                    }
                    Attribute::LetterSpacing => {
                        self.values.letter_spacing = parse_property(value, LengthDir::Horizontal)?;
                    }
                    Attribute::LightingColor => {
                        self.values.lighting_color = parse_property(value, ())?;
                    }
                    Attribute::MarkerEnd => {
                        self.values.marker_end = parse_property(value, ())?;
                    }
                    Attribute::MarkerMid => {
                        self.values.marker_mid = parse_property(value, ())?;
                    }
                    Attribute::MarkerStart => {
                        self.values.marker_start = parse_property(value, ())?;
                    }
                    Attribute::Marker if accept_shorthands => {
                        self.values.marker_end = parse_property(value, ())?;
                        self.values.marker_mid = parse_property(value, ())?;
                        self.values.marker_start = parse_property(value, ())?;
                    }
                    Attribute::Mask => {
                        self.values.mask = parse_property(value, ())?;
                    }
                    Attribute::Opacity => {
                        self.values.opacity = parse_property(value, ())?;
                    }
                    Attribute::Overflow => {
                        self.values.overflow = parse_property(value, ())?;
                    }
                    Attribute::ShapeRendering => {
                        self.values.shape_rendering = parse_property(value, ())?;
                    }
                    Attribute::StopColor => {
                        self.values.stop_color = parse_property(value, ())?;
                    }
                    Attribute::StopOpacity => {
                        self.values.stop_opacity = parse_property(value, ())?;
                    }
                    Attribute::Stroke => {
                        self.values.stroke = parse_property(value, ())?;
                    }
                    Attribute::StrokeDasharray => {
                        self.values.stroke_dasharray = parse_property(value, ())?;
                    }
                    Attribute::StrokeDashoffset => {
                        self.values.stroke_dashoffset = parse_property(value, LengthDir::Both)?;
                    }
                    Attribute::StrokeLinecap => {
                        self.values.stroke_line_cap = parse_property(value, ())?;
                    }
                    Attribute::StrokeLinejoin => {
                        self.values.stroke_line_join = parse_property(value, ())?;
                    }
                    Attribute::StrokeOpacity => {
                        self.values.stroke_opacity = parse_property(value, ())?;
                    }
                    Attribute::StrokeMiterlimit => {
                        self.values.stroke_miterlimit = parse_property(value, ())?;
                    }
                    Attribute::StrokeWidth => {
                        self.values.stroke_width = parse_property(value, LengthDir::Both)?;
                    }
                    Attribute::TextAnchor => {
                        self.values.text_anchor = parse_property(value, ())?;
                    }
                    Attribute::TextDecoration => {
                        self.values.text_decoration = parse_property(value, ())?;
                    }
                    Attribute::TextRendering => {
                        self.values.text_rendering = parse_property(value, ())?;
                    }
                    Attribute::UnicodeBidi => {
                        self.values.unicode_bidi = parse_property(value, ())?;
                    }
                    Attribute::Visibility => {
                        self.values.visibility = parse_property(value, ())?;
                    }
                    Attribute::WritingMode => {
                        self.values.writing_mode = parse_property(value, ())?;
                    }
                    Attribute::XmlLang => {
                        self.values.xml_lang =
                            SpecifiedValue::Specified(XmlLang::parse_str(value, ())?);
                    }
                    Attribute::XmlSpace => {
                        self.values.xml_space =
                            SpecifiedValue::Specified(XmlSpace::parse_str(value, ())?);
                    }
                    _ => {}
                }
                Ok(())
            };
            let _ = parse();
            Ok(())
        }
        fn parse_presentation_attributes(&mut self, pbag: &PropertyBag) -> Result<(), NodeError> {
            for (_key, attr, value) in pbag.iter() {
                self.parse_style_pair(attr, value, false, false)?;
            }
            Ok(())
        }
        fn parse_style_declarations(&mut self, declarations: &str) -> Result<(), NodeError> {
            for decl in declarations.split(';') {
                if let Some(colon_pos) = decl.find(':') {
                    let (prop_name, value) = decl.split_at(colon_pos);
                    let prop_name = prop_name.trim();
                    let value = value[1..].trim();
                    if !prop_name.is_empty() && !value.is_empty() {
                        let value = value.replace('\'', "");
                        let mut important = false;
                        let value = if let Some(bang_pos) = value.find('!') {
                            let (before_bang, bang_and_after) = value.split_at(bang_pos);
                            if bang_and_after[1..].trim() == "important" {
                                important = true;
                            }
                            before_bang.trim()
                        } else {
                            &value
                        };
                        if let Ok(attr) = Attribute::from_str(prop_name) {
                            self.parse_style_pair(attr, value, important, true)?;
                        }
                    }
                }
            }
            Ok(())
        }
        pub fn get_specified_values(&self) -> &SpecifiedValues {
            &self.values
        }
    }
    fn parse_property<T>(
        value: &str,
        data: <T as Parse>::Data,
    ) -> Result<SpecifiedValue<T>, <T as Parse>::Err>
    where
        T: Property<ComputedValues> + Clone + Default + Parse,
    {
        if value.trim() == "inherit" {
            Ok(SpecifiedValue::Inherit)
        } else {
            Parse::parse_str(value, data).map(SpecifiedValue::Specified)
        }
    }
    pub struct BaselineShift(pub RsvgLength);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for BaselineShift {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                BaselineShift(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("BaselineShift");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for BaselineShift {
        #[inline]
        fn clone(&self) -> BaselineShift {
            match *self {
                BaselineShift(ref __self_0_0) => {
                    BaselineShift(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for BaselineShift {
        #[inline]
        fn eq(&self, other: &BaselineShift) -> bool {
            match *other {
                BaselineShift(ref __self_1_0) => match *self {
                    BaselineShift(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &BaselineShift) -> bool {
            match *other {
                BaselineShift(ref __self_1_0) => match *self {
                    BaselineShift(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for BaselineShift {
        fn default() -> BaselineShift {
            BaselineShift(RsvgLength::parse_str("0.0", LengthDir::Both).unwrap())
        }
    }
    impl Property<ComputedValues> for BaselineShift {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, v: &ComputedValues) -> Self {
            let font_size = v.font_size.0.value();
            if self.0.unit != LengthUnit::Percent || v.baseline_shift.0.unit != font_size.unit {
                return BaselineShift(RsvgLength::new(
                    v.baseline_shift.0.length,
                    v.baseline_shift.0.unit,
                    LengthDir::Both,
                ));
            }
            BaselineShift(RsvgLength::new(
                self.0.length * font_size.length + v.baseline_shift.0.length,
                font_size.unit,
                LengthDir::Both,
            ))
        }
    }
    impl Parse for BaselineShift {
        type Data = ();
        type Err = AttributeError;
        fn parse(
            parser: &mut Parser,
            _: Self::Data,
        ) -> Result<BaselineShift, ::error::AttributeError> {
            let parser_state = parser.state();
            {
                let token = parser.next().map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("expected token"))
                })?;
                if let Token::Ident(ref cow) = token {
                    match cow.as_ref() {
                        "baseline" => {
                            return Ok(BaselineShift(RsvgLength::new(
                                0.0,
                                LengthUnit::Percent,
                                LengthDir::Both,
                            )))
                        }
                        "sub" => {
                            return Ok(BaselineShift(RsvgLength::new(
                                -0.2,
                                LengthUnit::Percent,
                                LengthDir::Both,
                            )))
                        }
                        "super" => {
                            return Ok(BaselineShift(RsvgLength::new(
                                0.4,
                                LengthUnit::Percent,
                                LengthDir::Both,
                            )))
                        }
                        _ => (),
                    }
                }
            }
            parser.reset(&parser_state);
            Ok(BaselineShift(RsvgLength::from_cssparser(
                parser,
                LengthDir::Both,
            )?))
        }
    }
    pub struct ClipPath(pub IRI);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ClipPath {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ClipPath(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipPath");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ClipPath {
        #[inline]
        fn clone(&self) -> ClipPath {
            match *self {
                ClipPath(ref __self_0_0) => ClipPath(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ClipPath {
        #[inline]
        fn eq(&self, other: &ClipPath) -> bool {
            match *other {
                ClipPath(ref __self_1_0) => match *self {
                    ClipPath(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ClipPath) -> bool {
            match *other {
                ClipPath(ref __self_1_0) => match *self {
                    ClipPath(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for ClipPath {
        fn default() -> ClipPath {
            ClipPath(IRI::None)
        }
    }
    impl ::property_macros::Property<ComputedValues> for ClipPath {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for ClipPath {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<ClipPath, ::error::AttributeError> {
            Ok(ClipPath(<IRI as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum ClipRule {
        NonZero,
        EvenOdd,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ClipRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&ClipRule::NonZero,) => {
                    let mut debug_trait_builder = f.debug_tuple("NonZero");
                    debug_trait_builder.finish()
                }
                (&ClipRule::EvenOdd,) => {
                    let mut debug_trait_builder = f.debug_tuple("EvenOdd");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ClipRule {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ClipRule {
        #[inline]
        fn clone(&self) -> ClipRule {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ClipRule {
        #[inline]
        fn eq(&self, other: &ClipRule) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for ClipRule {
        fn default() -> ClipRule {
            ClipRule::NonZero
        }
    }
    impl ::property_macros::Property<ComputedValues> for ClipRule {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for ClipRule {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<ClipRule, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "nonzero" => Ok(ClipRule::NonZero),
                    "evenodd" => Ok(ClipRule::EvenOdd),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct Color(pub cssparser::RGBA);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Color {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Color(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Color");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Color {
        #[inline]
        fn clone(&self) -> Color {
            match *self {
                Color(ref __self_0_0) => Color(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Color {
        #[inline]
        fn eq(&self, other: &Color) -> bool {
            match *other {
                Color(ref __self_1_0) => match *self {
                    Color(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Color) -> bool {
            match *other {
                Color(ref __self_1_0) => match *self {
                    Color(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for Color {
        fn default() -> Color {
            Color(cssparser::RGBA::new(0, 0, 0, 255))
        }
    }
    impl ::property_macros::Property<ComputedValues> for Color {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Color {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<Color, ::error::AttributeError> {
            Ok(Color(<cssparser::RGBA as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum ColorInterpolationFilters {
        Auto,
        LinearRgb,
        Srgb,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ColorInterpolationFilters {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&ColorInterpolationFilters::Auto,) => {
                    let mut debug_trait_builder = f.debug_tuple("Auto");
                    debug_trait_builder.finish()
                }
                (&ColorInterpolationFilters::LinearRgb,) => {
                    let mut debug_trait_builder = f.debug_tuple("LinearRgb");
                    debug_trait_builder.finish()
                }
                (&ColorInterpolationFilters::Srgb,) => {
                    let mut debug_trait_builder = f.debug_tuple("Srgb");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ColorInterpolationFilters {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ColorInterpolationFilters {
        #[inline]
        fn clone(&self) -> ColorInterpolationFilters {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ColorInterpolationFilters {
        #[inline]
        fn eq(&self, other: &ColorInterpolationFilters) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for ColorInterpolationFilters {
        fn default() -> ColorInterpolationFilters {
            ColorInterpolationFilters::LinearRgb
        }
    }
    impl ::property_macros::Property<ComputedValues> for ColorInterpolationFilters {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for ColorInterpolationFilters {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<ColorInterpolationFilters, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "auto" => Ok(ColorInterpolationFilters::Auto),
                    "linearRGB" => Ok(ColorInterpolationFilters::LinearRgb),
                    "sRGB" => Ok(ColorInterpolationFilters::Srgb),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum CompOp {
        Clear,
        Src,
        Dst,
        SrcOver,
        DstOver,
        SrcIn,
        DstIn,
        SrcOut,
        DstOut,
        SrcAtop,
        DstAtop,
        Xor,
        Plus,
        Multiply,
        Screen,
        Overlay,
        Darken,
        Lighten,
        ColorDodge,
        ColorBurn,
        HardLight,
        SoftLight,
        Difference,
        Exclusion,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for CompOp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&CompOp::Clear,) => {
                    let mut debug_trait_builder = f.debug_tuple("Clear");
                    debug_trait_builder.finish()
                }
                (&CompOp::Src,) => {
                    let mut debug_trait_builder = f.debug_tuple("Src");
                    debug_trait_builder.finish()
                }
                (&CompOp::Dst,) => {
                    let mut debug_trait_builder = f.debug_tuple("Dst");
                    debug_trait_builder.finish()
                }
                (&CompOp::SrcOver,) => {
                    let mut debug_trait_builder = f.debug_tuple("SrcOver");
                    debug_trait_builder.finish()
                }
                (&CompOp::DstOver,) => {
                    let mut debug_trait_builder = f.debug_tuple("DstOver");
                    debug_trait_builder.finish()
                }
                (&CompOp::SrcIn,) => {
                    let mut debug_trait_builder = f.debug_tuple("SrcIn");
                    debug_trait_builder.finish()
                }
                (&CompOp::DstIn,) => {
                    let mut debug_trait_builder = f.debug_tuple("DstIn");
                    debug_trait_builder.finish()
                }
                (&CompOp::SrcOut,) => {
                    let mut debug_trait_builder = f.debug_tuple("SrcOut");
                    debug_trait_builder.finish()
                }
                (&CompOp::DstOut,) => {
                    let mut debug_trait_builder = f.debug_tuple("DstOut");
                    debug_trait_builder.finish()
                }
                (&CompOp::SrcAtop,) => {
                    let mut debug_trait_builder = f.debug_tuple("SrcAtop");
                    debug_trait_builder.finish()
                }
                (&CompOp::DstAtop,) => {
                    let mut debug_trait_builder = f.debug_tuple("DstAtop");
                    debug_trait_builder.finish()
                }
                (&CompOp::Xor,) => {
                    let mut debug_trait_builder = f.debug_tuple("Xor");
                    debug_trait_builder.finish()
                }
                (&CompOp::Plus,) => {
                    let mut debug_trait_builder = f.debug_tuple("Plus");
                    debug_trait_builder.finish()
                }
                (&CompOp::Multiply,) => {
                    let mut debug_trait_builder = f.debug_tuple("Multiply");
                    debug_trait_builder.finish()
                }
                (&CompOp::Screen,) => {
                    let mut debug_trait_builder = f.debug_tuple("Screen");
                    debug_trait_builder.finish()
                }
                (&CompOp::Overlay,) => {
                    let mut debug_trait_builder = f.debug_tuple("Overlay");
                    debug_trait_builder.finish()
                }
                (&CompOp::Darken,) => {
                    let mut debug_trait_builder = f.debug_tuple("Darken");
                    debug_trait_builder.finish()
                }
                (&CompOp::Lighten,) => {
                    let mut debug_trait_builder = f.debug_tuple("Lighten");
                    debug_trait_builder.finish()
                }
                (&CompOp::ColorDodge,) => {
                    let mut debug_trait_builder = f.debug_tuple("ColorDodge");
                    debug_trait_builder.finish()
                }
                (&CompOp::ColorBurn,) => {
                    let mut debug_trait_builder = f.debug_tuple("ColorBurn");
                    debug_trait_builder.finish()
                }
                (&CompOp::HardLight,) => {
                    let mut debug_trait_builder = f.debug_tuple("HardLight");
                    debug_trait_builder.finish()
                }
                (&CompOp::SoftLight,) => {
                    let mut debug_trait_builder = f.debug_tuple("SoftLight");
                    debug_trait_builder.finish()
                }
                (&CompOp::Difference,) => {
                    let mut debug_trait_builder = f.debug_tuple("Difference");
                    debug_trait_builder.finish()
                }
                (&CompOp::Exclusion,) => {
                    let mut debug_trait_builder = f.debug_tuple("Exclusion");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for CompOp {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for CompOp {
        #[inline]
        fn clone(&self) -> CompOp {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for CompOp {
        #[inline]
        fn eq(&self, other: &CompOp) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for CompOp {
        fn default() -> CompOp {
            CompOp::SrcOver
        }
    }
    impl ::property_macros::Property<ComputedValues> for CompOp {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for CompOp {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<CompOp, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "clear" => Ok(CompOp::Clear),
                    "src" => Ok(CompOp::Src),
                    "dst" => Ok(CompOp::Dst),
                    "src-over" => Ok(CompOp::SrcOver),
                    "dst-over" => Ok(CompOp::DstOver),
                    "src-in" => Ok(CompOp::SrcIn),
                    "dst-in" => Ok(CompOp::DstIn),
                    "src-out" => Ok(CompOp::SrcOut),
                    "dst-out" => Ok(CompOp::DstOut),
                    "src-atop" => Ok(CompOp::SrcAtop),
                    "dst-atop" => Ok(CompOp::DstAtop),
                    "xor" => Ok(CompOp::Xor),
                    "plus" => Ok(CompOp::Plus),
                    "multiply" => Ok(CompOp::Multiply),
                    "screen" => Ok(CompOp::Screen),
                    "overlay" => Ok(CompOp::Overlay),
                    "darken" => Ok(CompOp::Darken),
                    "lighten" => Ok(CompOp::Lighten),
                    "color-dodge" => Ok(CompOp::ColorDodge),
                    "color-burn" => Ok(CompOp::ColorBurn),
                    "hard-light" => Ok(CompOp::HardLight),
                    "soft-light" => Ok(CompOp::SoftLight),
                    "difference" => Ok(CompOp::Difference),
                    "exclusion" => Ok(CompOp::Exclusion),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum Direction {
        Ltr,
        Rtl,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Direction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Direction::Ltr,) => {
                    let mut debug_trait_builder = f.debug_tuple("Ltr");
                    debug_trait_builder.finish()
                }
                (&Direction::Rtl,) => {
                    let mut debug_trait_builder = f.debug_tuple("Rtl");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Direction {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Direction {
        #[inline]
        fn clone(&self) -> Direction {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Direction {
        #[inline]
        fn eq(&self, other: &Direction) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for Direction {
        fn default() -> Direction {
            Direction::Ltr
        }
    }
    impl ::property_macros::Property<ComputedValues> for Direction {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Direction {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<Direction, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "ltr" => Ok(Direction::Ltr),
                    "rtl" => Ok(Direction::Rtl),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum Display {
        Inline,
        Block,
        ListItem,
        RunIn,
        Compact,
        Marker,
        Table,
        InlineTable,
        TableRowGroup,
        TableHeaderGroup,
        TableFooterGroup,
        TableRow,
        TableColumnGroup,
        TableColumn,
        TableCell,
        TableCaption,
        None,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Display {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Display::Inline,) => {
                    let mut debug_trait_builder = f.debug_tuple("Inline");
                    debug_trait_builder.finish()
                }
                (&Display::Block,) => {
                    let mut debug_trait_builder = f.debug_tuple("Block");
                    debug_trait_builder.finish()
                }
                (&Display::ListItem,) => {
                    let mut debug_trait_builder = f.debug_tuple("ListItem");
                    debug_trait_builder.finish()
                }
                (&Display::RunIn,) => {
                    let mut debug_trait_builder = f.debug_tuple("RunIn");
                    debug_trait_builder.finish()
                }
                (&Display::Compact,) => {
                    let mut debug_trait_builder = f.debug_tuple("Compact");
                    debug_trait_builder.finish()
                }
                (&Display::Marker,) => {
                    let mut debug_trait_builder = f.debug_tuple("Marker");
                    debug_trait_builder.finish()
                }
                (&Display::Table,) => {
                    let mut debug_trait_builder = f.debug_tuple("Table");
                    debug_trait_builder.finish()
                }
                (&Display::InlineTable,) => {
                    let mut debug_trait_builder = f.debug_tuple("InlineTable");
                    debug_trait_builder.finish()
                }
                (&Display::TableRowGroup,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableRowGroup");
                    debug_trait_builder.finish()
                }
                (&Display::TableHeaderGroup,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableHeaderGroup");
                    debug_trait_builder.finish()
                }
                (&Display::TableFooterGroup,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableFooterGroup");
                    debug_trait_builder.finish()
                }
                (&Display::TableRow,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableRow");
                    debug_trait_builder.finish()
                }
                (&Display::TableColumnGroup,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableColumnGroup");
                    debug_trait_builder.finish()
                }
                (&Display::TableColumn,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableColumn");
                    debug_trait_builder.finish()
                }
                (&Display::TableCell,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableCell");
                    debug_trait_builder.finish()
                }
                (&Display::TableCaption,) => {
                    let mut debug_trait_builder = f.debug_tuple("TableCaption");
                    debug_trait_builder.finish()
                }
                (&Display::None,) => {
                    let mut debug_trait_builder = f.debug_tuple("None");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Display {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Display {
        #[inline]
        fn clone(&self) -> Display {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Display {
        #[inline]
        fn eq(&self, other: &Display) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for Display {
        fn default() -> Display {
            Display::Inline
        }
    }
    impl ::property_macros::Property<ComputedValues> for Display {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Display {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<Display, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "inline" => Ok(Display::Inline),
                    "block" => Ok(Display::Block),
                    "list-item" => Ok(Display::ListItem),
                    "run-in" => Ok(Display::RunIn),
                    "compact" => Ok(Display::Compact),
                    "marker" => Ok(Display::Marker),
                    "table" => Ok(Display::Table),
                    "inline-table" => Ok(Display::InlineTable),
                    "table-row-group" => Ok(Display::TableRowGroup),
                    "table-header-group" => Ok(Display::TableHeaderGroup),
                    "table-footer-group" => Ok(Display::TableFooterGroup),
                    "table-row" => Ok(Display::TableRow),
                    "table-column-group" => Ok(Display::TableColumnGroup),
                    "table-column" => Ok(Display::TableColumn),
                    "table-cell" => Ok(Display::TableCell),
                    "table-caption" => Ok(Display::TableCaption),
                    "none" => Ok(Display::None),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum EnableBackground {
        Accumulate,
        New,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for EnableBackground {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&EnableBackground::Accumulate,) => {
                    let mut debug_trait_builder = f.debug_tuple("Accumulate");
                    debug_trait_builder.finish()
                }
                (&EnableBackground::New,) => {
                    let mut debug_trait_builder = f.debug_tuple("New");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for EnableBackground {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for EnableBackground {
        #[inline]
        fn clone(&self) -> EnableBackground {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for EnableBackground {
        #[inline]
        fn eq(&self, other: &EnableBackground) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for EnableBackground {
        fn default() -> EnableBackground {
            EnableBackground::Accumulate
        }
    }
    impl ::property_macros::Property<ComputedValues> for EnableBackground {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for EnableBackground {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<EnableBackground, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "accumulate" => Ok(EnableBackground::Accumulate),
                    "new" => Ok(EnableBackground::New),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct Fill(pub PaintServer);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Fill {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Fill(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Fill");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Fill {
        #[inline]
        fn clone(&self) -> Fill {
            match *self {
                Fill(ref __self_0_0) => Fill(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Fill {
        #[inline]
        fn eq(&self, other: &Fill) -> bool {
            match *other {
                Fill(ref __self_1_0) => match *self {
                    Fill(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Fill) -> bool {
            match *other {
                Fill(ref __self_1_0) => match *self {
                    Fill(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for Fill {
        fn default() -> Fill {
            Fill(PaintServer::parse_str("#000", ()).unwrap())
        }
    }
    impl ::property_macros::Property<ComputedValues> for Fill {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Fill {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<Fill, ::error::AttributeError> {
            Ok(Fill(<PaintServer as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct FillOpacity(pub UnitInterval);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FillOpacity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FillOpacity(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("FillOpacity");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FillOpacity {
        #[inline]
        fn clone(&self) -> FillOpacity {
            match *self {
                FillOpacity(ref __self_0_0) => {
                    FillOpacity(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FillOpacity {
        #[inline]
        fn eq(&self, other: &FillOpacity) -> bool {
            match *other {
                FillOpacity(ref __self_1_0) => match *self {
                    FillOpacity(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FillOpacity) -> bool {
            match *other {
                FillOpacity(ref __self_1_0) => match *self {
                    FillOpacity(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for FillOpacity {
        fn default() -> FillOpacity {
            FillOpacity(UnitInterval(1.0))
        }
    }
    impl ::property_macros::Property<ComputedValues> for FillOpacity {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FillOpacity {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<FillOpacity, ::error::AttributeError> {
            Ok(FillOpacity(<UnitInterval as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum FillRule {
        NonZero,
        EvenOdd,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FillRule {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FillRule::NonZero,) => {
                    let mut debug_trait_builder = f.debug_tuple("NonZero");
                    debug_trait_builder.finish()
                }
                (&FillRule::EvenOdd,) => {
                    let mut debug_trait_builder = f.debug_tuple("EvenOdd");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FillRule {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FillRule {
        #[inline]
        fn clone(&self) -> FillRule {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FillRule {
        #[inline]
        fn eq(&self, other: &FillRule) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for FillRule {
        fn default() -> FillRule {
            FillRule::NonZero
        }
    }
    impl ::property_macros::Property<ComputedValues> for FillRule {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FillRule {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<FillRule, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "nonzero" => Ok(FillRule::NonZero),
                    "evenodd" => Ok(FillRule::EvenOdd),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct Filter(pub IRI);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Filter {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Filter(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Filter");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Filter {
        #[inline]
        fn clone(&self) -> Filter {
            match *self {
                Filter(ref __self_0_0) => Filter(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Filter {
        #[inline]
        fn eq(&self, other: &Filter) -> bool {
            match *other {
                Filter(ref __self_1_0) => match *self {
                    Filter(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Filter) -> bool {
            match *other {
                Filter(ref __self_1_0) => match *self {
                    Filter(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for Filter {
        fn default() -> Filter {
            Filter(IRI::None)
        }
    }
    impl ::property_macros::Property<ComputedValues> for Filter {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Filter {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<Filter, ::error::AttributeError> {
            Ok(Filter(<IRI as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct FloodColor(pub cssparser::Color);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FloodColor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FloodColor(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("FloodColor");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FloodColor {
        #[inline]
        fn clone(&self) -> FloodColor {
            match *self {
                FloodColor(ref __self_0_0) => {
                    FloodColor(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FloodColor {
        #[inline]
        fn eq(&self, other: &FloodColor) -> bool {
            match *other {
                FloodColor(ref __self_1_0) => match *self {
                    FloodColor(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FloodColor) -> bool {
            match *other {
                FloodColor(ref __self_1_0) => match *self {
                    FloodColor(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for FloodColor {
        fn default() -> FloodColor {
            FloodColor(cssparser::Color::RGBA(cssparser::RGBA::new(0, 0, 0, 0)))
        }
    }
    impl ::property_macros::Property<ComputedValues> for FloodColor {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FloodColor {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<FloodColor, ::error::AttributeError> {
            Ok(FloodColor(<cssparser::Color as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct FloodOpacity(pub UnitInterval);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FloodOpacity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FloodOpacity(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("FloodOpacity");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FloodOpacity {
        #[inline]
        fn clone(&self) -> FloodOpacity {
            match *self {
                FloodOpacity(ref __self_0_0) => {
                    FloodOpacity(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FloodOpacity {
        #[inline]
        fn eq(&self, other: &FloodOpacity) -> bool {
            match *other {
                FloodOpacity(ref __self_1_0) => match *self {
                    FloodOpacity(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FloodOpacity) -> bool {
            match *other {
                FloodOpacity(ref __self_1_0) => match *self {
                    FloodOpacity(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for FloodOpacity {
        fn default() -> FloodOpacity {
            FloodOpacity(UnitInterval(1.0))
        }
    }
    impl ::property_macros::Property<ComputedValues> for FloodOpacity {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FloodOpacity {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<FloodOpacity, ::error::AttributeError> {
            Ok(FloodOpacity(<UnitInterval as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct FontFamily(pub String);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FontFamily {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FontFamily(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("FontFamily");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FontFamily {
        #[inline]
        fn clone(&self) -> FontFamily {
            match *self {
                FontFamily(ref __self_0_0) => {
                    FontFamily(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FontFamily {
        #[inline]
        fn eq(&self, other: &FontFamily) -> bool {
            match *other {
                FontFamily(ref __self_1_0) => match *self {
                    FontFamily(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FontFamily) -> bool {
            match *other {
                FontFamily(ref __self_1_0) => match *self {
                    FontFamily(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for FontFamily {
        fn default() -> FontFamily {
            FontFamily("Times New Roman".to_string())
        }
    }
    impl ::property_macros::Property<ComputedValues> for FontFamily {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FontFamily {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<FontFamily, ::error::AttributeError> {
            Ok(FontFamily(<String as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct FontSize(pub FontSizeSpec);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FontSize {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                FontSize(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("FontSize");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FontSize {
        #[inline]
        fn clone(&self) -> FontSize {
            match *self {
                FontSize(ref __self_0_0) => FontSize(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FontSize {
        #[inline]
        fn eq(&self, other: &FontSize) -> bool {
            match *other {
                FontSize(ref __self_1_0) => match *self {
                    FontSize(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &FontSize) -> bool {
            match *other {
                FontSize(ref __self_1_0) => match *self {
                    FontSize(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for FontSize {
        fn default() -> FontSize {
            FontSize(FontSizeSpec::Value(
                RsvgLength::parse_str("12.0", LengthDir::Both).unwrap(),
            ))
        }
    }
    impl Property<ComputedValues> for FontSize {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, v: &ComputedValues) -> Self {
            FontSize(self.0.compute(v))
        }
    }
    impl ::parsers::Parse for FontSize {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<FontSize, ::error::AttributeError> {
            Ok(FontSize(<FontSizeSpec as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum FontStretch {
        Normal,
        Wider,
        Narrower,
        UltraCondensed,
        ExtraCondensed,
        Condensed,
        SemiCondensed,
        SemiExpanded,
        Expanded,
        ExtraExpanded,
        UltraExpanded,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FontStretch {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FontStretch::Normal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Normal");
                    debug_trait_builder.finish()
                }
                (&FontStretch::Wider,) => {
                    let mut debug_trait_builder = f.debug_tuple("Wider");
                    debug_trait_builder.finish()
                }
                (&FontStretch::Narrower,) => {
                    let mut debug_trait_builder = f.debug_tuple("Narrower");
                    debug_trait_builder.finish()
                }
                (&FontStretch::UltraCondensed,) => {
                    let mut debug_trait_builder = f.debug_tuple("UltraCondensed");
                    debug_trait_builder.finish()
                }
                (&FontStretch::ExtraCondensed,) => {
                    let mut debug_trait_builder = f.debug_tuple("ExtraCondensed");
                    debug_trait_builder.finish()
                }
                (&FontStretch::Condensed,) => {
                    let mut debug_trait_builder = f.debug_tuple("Condensed");
                    debug_trait_builder.finish()
                }
                (&FontStretch::SemiCondensed,) => {
                    let mut debug_trait_builder = f.debug_tuple("SemiCondensed");
                    debug_trait_builder.finish()
                }
                (&FontStretch::SemiExpanded,) => {
                    let mut debug_trait_builder = f.debug_tuple("SemiExpanded");
                    debug_trait_builder.finish()
                }
                (&FontStretch::Expanded,) => {
                    let mut debug_trait_builder = f.debug_tuple("Expanded");
                    debug_trait_builder.finish()
                }
                (&FontStretch::ExtraExpanded,) => {
                    let mut debug_trait_builder = f.debug_tuple("ExtraExpanded");
                    debug_trait_builder.finish()
                }
                (&FontStretch::UltraExpanded,) => {
                    let mut debug_trait_builder = f.debug_tuple("UltraExpanded");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FontStretch {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FontStretch {
        #[inline]
        fn clone(&self) -> FontStretch {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FontStretch {
        #[inline]
        fn eq(&self, other: &FontStretch) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for FontStretch {
        fn default() -> FontStretch {
            FontStretch::Normal
        }
    }
    impl ::property_macros::Property<ComputedValues> for FontStretch {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FontStretch {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<FontStretch, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "normal" => Ok(FontStretch::Normal),
                    "wider" => Ok(FontStretch::Wider),
                    "narrower" => Ok(FontStretch::Narrower),
                    "ultra-condensed" => Ok(FontStretch::UltraCondensed),
                    "extra-condensed" => Ok(FontStretch::ExtraCondensed),
                    "condensed" => Ok(FontStretch::Condensed),
                    "semi-condensed" => Ok(FontStretch::SemiCondensed),
                    "semi-expanded" => Ok(FontStretch::SemiExpanded),
                    "expanded" => Ok(FontStretch::Expanded),
                    "extra-expanded" => Ok(FontStretch::ExtraExpanded),
                    "ultra-expanded" => Ok(FontStretch::UltraExpanded),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum FontStyle {
        Normal,
        Italic,
        Oblique,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FontStyle {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FontStyle::Normal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Normal");
                    debug_trait_builder.finish()
                }
                (&FontStyle::Italic,) => {
                    let mut debug_trait_builder = f.debug_tuple("Italic");
                    debug_trait_builder.finish()
                }
                (&FontStyle::Oblique,) => {
                    let mut debug_trait_builder = f.debug_tuple("Oblique");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FontStyle {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FontStyle {
        #[inline]
        fn clone(&self) -> FontStyle {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FontStyle {
        #[inline]
        fn eq(&self, other: &FontStyle) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for FontStyle {
        fn default() -> FontStyle {
            FontStyle::Normal
        }
    }
    impl ::property_macros::Property<ComputedValues> for FontStyle {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FontStyle {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<FontStyle, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "normal" => Ok(FontStyle::Normal),
                    "italic" => Ok(FontStyle::Italic),
                    "oblique" => Ok(FontStyle::Oblique),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum FontVariant {
        Normal,
        SmallCaps,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FontVariant {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FontVariant::Normal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Normal");
                    debug_trait_builder.finish()
                }
                (&FontVariant::SmallCaps,) => {
                    let mut debug_trait_builder = f.debug_tuple("SmallCaps");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FontVariant {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FontVariant {
        #[inline]
        fn clone(&self) -> FontVariant {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FontVariant {
        #[inline]
        fn eq(&self, other: &FontVariant) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for FontVariant {
        fn default() -> FontVariant {
            FontVariant::Normal
        }
    }
    impl ::property_macros::Property<ComputedValues> for FontVariant {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FontVariant {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<FontVariant, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "normal" => Ok(FontVariant::Normal),
                    "small-caps" => Ok(FontVariant::SmallCaps),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum FontWeight {
        Normal,
        Bold,
        Bolder,
        Lighter,
        W100,
        W200,
        W300,
        W400,
        W500,
        W600,
        W700,
        W800,
        W900,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for FontWeight {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&FontWeight::Normal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Normal");
                    debug_trait_builder.finish()
                }
                (&FontWeight::Bold,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bold");
                    debug_trait_builder.finish()
                }
                (&FontWeight::Bolder,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bolder");
                    debug_trait_builder.finish()
                }
                (&FontWeight::Lighter,) => {
                    let mut debug_trait_builder = f.debug_tuple("Lighter");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W100,) => {
                    let mut debug_trait_builder = f.debug_tuple("W100");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W200,) => {
                    let mut debug_trait_builder = f.debug_tuple("W200");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W300,) => {
                    let mut debug_trait_builder = f.debug_tuple("W300");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W400,) => {
                    let mut debug_trait_builder = f.debug_tuple("W400");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W500,) => {
                    let mut debug_trait_builder = f.debug_tuple("W500");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W600,) => {
                    let mut debug_trait_builder = f.debug_tuple("W600");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W700,) => {
                    let mut debug_trait_builder = f.debug_tuple("W700");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W800,) => {
                    let mut debug_trait_builder = f.debug_tuple("W800");
                    debug_trait_builder.finish()
                }
                (&FontWeight::W900,) => {
                    let mut debug_trait_builder = f.debug_tuple("W900");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for FontWeight {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for FontWeight {
        #[inline]
        fn clone(&self) -> FontWeight {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for FontWeight {
        #[inline]
        fn eq(&self, other: &FontWeight) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for FontWeight {
        fn default() -> FontWeight {
            FontWeight::Normal
        }
    }
    impl ::property_macros::Property<ComputedValues> for FontWeight {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for FontWeight {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<FontWeight, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "normal" => Ok(FontWeight::Normal),
                    "bold" => Ok(FontWeight::Bold),
                    "bolder" => Ok(FontWeight::Bolder),
                    "lighter" => Ok(FontWeight::Lighter),
                    "100" => Ok(FontWeight::W100),
                    "200" => Ok(FontWeight::W200),
                    "300" => Ok(FontWeight::W300),
                    "400" => Ok(FontWeight::W400),
                    "500" => Ok(FontWeight::W500),
                    "600" => Ok(FontWeight::W600),
                    "700" => Ok(FontWeight::W700),
                    "800" => Ok(FontWeight::W800),
                    "900" => Ok(FontWeight::W900),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct LetterSpacing(pub RsvgLength);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for LetterSpacing {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                LetterSpacing(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("LetterSpacing");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for LetterSpacing {
        #[inline]
        fn clone(&self) -> LetterSpacing {
            match *self {
                LetterSpacing(ref __self_0_0) => {
                    LetterSpacing(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for LetterSpacing {
        #[inline]
        fn eq(&self, other: &LetterSpacing) -> bool {
            match *other {
                LetterSpacing(ref __self_1_0) => match *self {
                    LetterSpacing(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LetterSpacing) -> bool {
            match *other {
                LetterSpacing(ref __self_1_0) => match *self {
                    LetterSpacing(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for LetterSpacing {
        fn default() -> LetterSpacing {
            LetterSpacing(RsvgLength::default())
        }
    }
    impl ::property_macros::Property<ComputedValues> for LetterSpacing {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for LetterSpacing {
        type Data = LengthDir;
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<LetterSpacing, ::error::AttributeError> {
            Ok(LetterSpacing(<RsvgLength as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct LightingColor(pub cssparser::Color);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for LightingColor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                LightingColor(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("LightingColor");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for LightingColor {
        #[inline]
        fn clone(&self) -> LightingColor {
            match *self {
                LightingColor(ref __self_0_0) => {
                    LightingColor(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for LightingColor {
        #[inline]
        fn eq(&self, other: &LightingColor) -> bool {
            match *other {
                LightingColor(ref __self_1_0) => match *self {
                    LightingColor(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &LightingColor) -> bool {
            match *other {
                LightingColor(ref __self_1_0) => match *self {
                    LightingColor(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for LightingColor {
        fn default() -> LightingColor {
            LightingColor(cssparser::Color::RGBA(cssparser::RGBA::new(
                255, 255, 255, 255,
            )))
        }
    }
    impl ::property_macros::Property<ComputedValues> for LightingColor {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for LightingColor {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<LightingColor, ::error::AttributeError> {
            Ok(LightingColor(
                <cssparser::Color as ::parsers::Parse>::parse(parser, d)?,
            ))
        }
    }
    pub struct MarkerEnd(pub IRI);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkerEnd {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                MarkerEnd(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerEnd");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkerEnd {
        #[inline]
        fn clone(&self) -> MarkerEnd {
            match *self {
                MarkerEnd(ref __self_0_0) => MarkerEnd(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MarkerEnd {
        #[inline]
        fn eq(&self, other: &MarkerEnd) -> bool {
            match *other {
                MarkerEnd(ref __self_1_0) => match *self {
                    MarkerEnd(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MarkerEnd) -> bool {
            match *other {
                MarkerEnd(ref __self_1_0) => match *self {
                    MarkerEnd(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for MarkerEnd {
        fn default() -> MarkerEnd {
            MarkerEnd(IRI::None)
        }
    }
    impl ::property_macros::Property<ComputedValues> for MarkerEnd {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for MarkerEnd {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<MarkerEnd, ::error::AttributeError> {
            Ok(MarkerEnd(<IRI as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct MarkerMid(pub IRI);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkerMid {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                MarkerMid(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerMid");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkerMid {
        #[inline]
        fn clone(&self) -> MarkerMid {
            match *self {
                MarkerMid(ref __self_0_0) => MarkerMid(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MarkerMid {
        #[inline]
        fn eq(&self, other: &MarkerMid) -> bool {
            match *other {
                MarkerMid(ref __self_1_0) => match *self {
                    MarkerMid(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MarkerMid) -> bool {
            match *other {
                MarkerMid(ref __self_1_0) => match *self {
                    MarkerMid(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for MarkerMid {
        fn default() -> MarkerMid {
            MarkerMid(IRI::None)
        }
    }
    impl ::property_macros::Property<ComputedValues> for MarkerMid {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for MarkerMid {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<MarkerMid, ::error::AttributeError> {
            Ok(MarkerMid(<IRI as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct MarkerStart(pub IRI);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for MarkerStart {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                MarkerStart(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("MarkerStart");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for MarkerStart {
        #[inline]
        fn clone(&self) -> MarkerStart {
            match *self {
                MarkerStart(ref __self_0_0) => {
                    MarkerStart(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for MarkerStart {
        #[inline]
        fn eq(&self, other: &MarkerStart) -> bool {
            match *other {
                MarkerStart(ref __self_1_0) => match *self {
                    MarkerStart(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &MarkerStart) -> bool {
            match *other {
                MarkerStart(ref __self_1_0) => match *self {
                    MarkerStart(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for MarkerStart {
        fn default() -> MarkerStart {
            MarkerStart(IRI::None)
        }
    }
    impl ::property_macros::Property<ComputedValues> for MarkerStart {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for MarkerStart {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<MarkerStart, ::error::AttributeError> {
            Ok(MarkerStart(<IRI as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct Mask(pub IRI);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Mask {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Mask(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Mask");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Mask {
        #[inline]
        fn clone(&self) -> Mask {
            match *self {
                Mask(ref __self_0_0) => Mask(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Mask {
        #[inline]
        fn eq(&self, other: &Mask) -> bool {
            match *other {
                Mask(ref __self_1_0) => match *self {
                    Mask(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Mask) -> bool {
            match *other {
                Mask(ref __self_1_0) => match *self {
                    Mask(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for Mask {
        fn default() -> Mask {
            Mask(IRI::None)
        }
    }
    impl ::property_macros::Property<ComputedValues> for Mask {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Mask {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<Mask, ::error::AttributeError> {
            Ok(Mask(<IRI as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct Opacity(pub UnitInterval);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Opacity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Opacity(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Opacity");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Opacity {
        #[inline]
        fn clone(&self) -> Opacity {
            match *self {
                Opacity(ref __self_0_0) => Opacity(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Opacity {
        #[inline]
        fn eq(&self, other: &Opacity) -> bool {
            match *other {
                Opacity(ref __self_1_0) => match *self {
                    Opacity(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Opacity) -> bool {
            match *other {
                Opacity(ref __self_1_0) => match *self {
                    Opacity(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for Opacity {
        fn default() -> Opacity {
            Opacity(UnitInterval(1.0))
        }
    }
    impl ::property_macros::Property<ComputedValues> for Opacity {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Opacity {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<Opacity, ::error::AttributeError> {
            Ok(Opacity(<UnitInterval as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum Overflow {
        Visible,
        Hidden,
        Scroll,
        Auto,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Overflow {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Overflow::Visible,) => {
                    let mut debug_trait_builder = f.debug_tuple("Visible");
                    debug_trait_builder.finish()
                }
                (&Overflow::Hidden,) => {
                    let mut debug_trait_builder = f.debug_tuple("Hidden");
                    debug_trait_builder.finish()
                }
                (&Overflow::Scroll,) => {
                    let mut debug_trait_builder = f.debug_tuple("Scroll");
                    debug_trait_builder.finish()
                }
                (&Overflow::Auto,) => {
                    let mut debug_trait_builder = f.debug_tuple("Auto");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Overflow {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Overflow {
        #[inline]
        fn clone(&self) -> Overflow {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Overflow {
        #[inline]
        fn eq(&self, other: &Overflow) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for Overflow {
        fn default() -> Overflow {
            Overflow::Visible
        }
    }
    impl ::property_macros::Property<ComputedValues> for Overflow {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Overflow {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<Overflow, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "visible" => Ok(Overflow::Visible),
                    "hidden" => Ok(Overflow::Hidden),
                    "scroll" => Ok(Overflow::Scroll),
                    "auto" => Ok(Overflow::Auto),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum ShapeRendering {
        Auto,
        OptimizeSpeed,
        GeometricPrecision,
        CrispEdges,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ShapeRendering {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&ShapeRendering::Auto,) => {
                    let mut debug_trait_builder = f.debug_tuple("Auto");
                    debug_trait_builder.finish()
                }
                (&ShapeRendering::OptimizeSpeed,) => {
                    let mut debug_trait_builder = f.debug_tuple("OptimizeSpeed");
                    debug_trait_builder.finish()
                }
                (&ShapeRendering::GeometricPrecision,) => {
                    let mut debug_trait_builder = f.debug_tuple("GeometricPrecision");
                    debug_trait_builder.finish()
                }
                (&ShapeRendering::CrispEdges,) => {
                    let mut debug_trait_builder = f.debug_tuple("CrispEdges");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ShapeRendering {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ShapeRendering {
        #[inline]
        fn clone(&self) -> ShapeRendering {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ShapeRendering {
        #[inline]
        fn eq(&self, other: &ShapeRendering) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for ShapeRendering {
        fn default() -> ShapeRendering {
            ShapeRendering::Auto
        }
    }
    impl ::property_macros::Property<ComputedValues> for ShapeRendering {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for ShapeRendering {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<ShapeRendering, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "auto" => Ok(ShapeRendering::Auto),
                    "optimizeSpeed" => Ok(ShapeRendering::OptimizeSpeed),
                    "geometricPrecision" => Ok(ShapeRendering::GeometricPrecision),
                    "crispEdges" => Ok(ShapeRendering::CrispEdges),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct StopColor(pub cssparser::Color);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StopColor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                StopColor(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("StopColor");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StopColor {
        #[inline]
        fn clone(&self) -> StopColor {
            match *self {
                StopColor(ref __self_0_0) => StopColor(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StopColor {
        #[inline]
        fn eq(&self, other: &StopColor) -> bool {
            match *other {
                StopColor(ref __self_1_0) => match *self {
                    StopColor(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StopColor) -> bool {
            match *other {
                StopColor(ref __self_1_0) => match *self {
                    StopColor(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for StopColor {
        fn default() -> StopColor {
            StopColor(cssparser::Color::RGBA(cssparser::RGBA::new(0, 0, 0, 255)))
        }
    }
    impl ::property_macros::Property<ComputedValues> for StopColor {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StopColor {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<StopColor, ::error::AttributeError> {
            Ok(StopColor(<cssparser::Color as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct StopOpacity(pub UnitInterval);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StopOpacity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                StopOpacity(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("StopOpacity");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StopOpacity {
        #[inline]
        fn clone(&self) -> StopOpacity {
            match *self {
                StopOpacity(ref __self_0_0) => {
                    StopOpacity(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StopOpacity {
        #[inline]
        fn eq(&self, other: &StopOpacity) -> bool {
            match *other {
                StopOpacity(ref __self_1_0) => match *self {
                    StopOpacity(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StopOpacity) -> bool {
            match *other {
                StopOpacity(ref __self_1_0) => match *self {
                    StopOpacity(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for StopOpacity {
        fn default() -> StopOpacity {
            StopOpacity(UnitInterval(1.0))
        }
    }
    impl ::property_macros::Property<ComputedValues> for StopOpacity {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StopOpacity {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<StopOpacity, ::error::AttributeError> {
            Ok(StopOpacity(<UnitInterval as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct Stroke(pub PaintServer);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Stroke {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Stroke(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("Stroke");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Stroke {
        #[inline]
        fn clone(&self) -> Stroke {
            match *self {
                Stroke(ref __self_0_0) => Stroke(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Stroke {
        #[inline]
        fn eq(&self, other: &Stroke) -> bool {
            match *other {
                Stroke(ref __self_1_0) => match *self {
                    Stroke(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Stroke) -> bool {
            match *other {
                Stroke(ref __self_1_0) => match *self {
                    Stroke(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for Stroke {
        fn default() -> Stroke {
            Stroke(PaintServer::None)
        }
    }
    impl ::property_macros::Property<ComputedValues> for Stroke {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Stroke {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<Stroke, ::error::AttributeError> {
            Ok(Stroke(<PaintServer as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    pub struct StrokeDasharray(pub Dasharray);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StrokeDasharray {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                StrokeDasharray(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeDasharray");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StrokeDasharray {
        #[inline]
        fn clone(&self) -> StrokeDasharray {
            match *self {
                StrokeDasharray(ref __self_0_0) => {
                    StrokeDasharray(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StrokeDasharray {
        #[inline]
        fn eq(&self, other: &StrokeDasharray) -> bool {
            match *other {
                StrokeDasharray(ref __self_1_0) => match *self {
                    StrokeDasharray(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StrokeDasharray) -> bool {
            match *other {
                StrokeDasharray(ref __self_1_0) => match *self {
                    StrokeDasharray(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for StrokeDasharray {
        fn default() -> StrokeDasharray {
            StrokeDasharray(Dasharray::default())
        }
    }
    impl ::property_macros::Property<ComputedValues> for StrokeDasharray {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StrokeDasharray {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<StrokeDasharray, ::error::AttributeError> {
            Ok(StrokeDasharray(<Dasharray as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct StrokeDashoffset(pub RsvgLength);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StrokeDashoffset {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                StrokeDashoffset(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeDashoffset");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StrokeDashoffset {
        #[inline]
        fn clone(&self) -> StrokeDashoffset {
            match *self {
                StrokeDashoffset(ref __self_0_0) => {
                    StrokeDashoffset(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StrokeDashoffset {
        #[inline]
        fn eq(&self, other: &StrokeDashoffset) -> bool {
            match *other {
                StrokeDashoffset(ref __self_1_0) => match *self {
                    StrokeDashoffset(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StrokeDashoffset) -> bool {
            match *other {
                StrokeDashoffset(ref __self_1_0) => match *self {
                    StrokeDashoffset(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for StrokeDashoffset {
        fn default() -> StrokeDashoffset {
            StrokeDashoffset(RsvgLength::default())
        }
    }
    impl ::property_macros::Property<ComputedValues> for StrokeDashoffset {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StrokeDashoffset {
        type Data = LengthDir;
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<StrokeDashoffset, ::error::AttributeError> {
            Ok(StrokeDashoffset(<RsvgLength as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum StrokeLinecap {
        Butt,
        Round,
        Square,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StrokeLinecap {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&StrokeLinecap::Butt,) => {
                    let mut debug_trait_builder = f.debug_tuple("Butt");
                    debug_trait_builder.finish()
                }
                (&StrokeLinecap::Round,) => {
                    let mut debug_trait_builder = f.debug_tuple("Round");
                    debug_trait_builder.finish()
                }
                (&StrokeLinecap::Square,) => {
                    let mut debug_trait_builder = f.debug_tuple("Square");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for StrokeLinecap {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StrokeLinecap {
        #[inline]
        fn clone(&self) -> StrokeLinecap {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StrokeLinecap {
        #[inline]
        fn eq(&self, other: &StrokeLinecap) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for StrokeLinecap {
        fn default() -> StrokeLinecap {
            StrokeLinecap::Butt
        }
    }
    impl ::property_macros::Property<ComputedValues> for StrokeLinecap {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StrokeLinecap {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<StrokeLinecap, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "butt" => Ok(StrokeLinecap::Butt),
                    "round" => Ok(StrokeLinecap::Round),
                    "square" => Ok(StrokeLinecap::Square),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum StrokeLinejoin {
        Miter,
        Round,
        Bevel,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StrokeLinejoin {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&StrokeLinejoin::Miter,) => {
                    let mut debug_trait_builder = f.debug_tuple("Miter");
                    debug_trait_builder.finish()
                }
                (&StrokeLinejoin::Round,) => {
                    let mut debug_trait_builder = f.debug_tuple("Round");
                    debug_trait_builder.finish()
                }
                (&StrokeLinejoin::Bevel,) => {
                    let mut debug_trait_builder = f.debug_tuple("Bevel");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for StrokeLinejoin {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StrokeLinejoin {
        #[inline]
        fn clone(&self) -> StrokeLinejoin {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StrokeLinejoin {
        #[inline]
        fn eq(&self, other: &StrokeLinejoin) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for StrokeLinejoin {
        fn default() -> StrokeLinejoin {
            StrokeLinejoin::Miter
        }
    }
    impl ::property_macros::Property<ComputedValues> for StrokeLinejoin {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StrokeLinejoin {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<StrokeLinejoin, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "miter" => Ok(StrokeLinejoin::Miter),
                    "round" => Ok(StrokeLinejoin::Round),
                    "bevel" => Ok(StrokeLinejoin::Bevel),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct StrokeMiterlimit(pub f64);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StrokeMiterlimit {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                StrokeMiterlimit(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeMiterlimit");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StrokeMiterlimit {
        #[inline]
        fn clone(&self) -> StrokeMiterlimit {
            match *self {
                StrokeMiterlimit(ref __self_0_0) => {
                    StrokeMiterlimit(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StrokeMiterlimit {
        #[inline]
        fn eq(&self, other: &StrokeMiterlimit) -> bool {
            match *other {
                StrokeMiterlimit(ref __self_1_0) => match *self {
                    StrokeMiterlimit(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StrokeMiterlimit) -> bool {
            match *other {
                StrokeMiterlimit(ref __self_1_0) => match *self {
                    StrokeMiterlimit(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for StrokeMiterlimit {
        fn default() -> StrokeMiterlimit {
            StrokeMiterlimit(4f64)
        }
    }
    impl ::property_macros::Property<ComputedValues> for StrokeMiterlimit {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StrokeMiterlimit {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<StrokeMiterlimit, ::error::AttributeError> {
            Ok(StrokeMiterlimit(<f64 as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct StrokeOpacity(pub UnitInterval);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StrokeOpacity {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                StrokeOpacity(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeOpacity");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StrokeOpacity {
        #[inline]
        fn clone(&self) -> StrokeOpacity {
            match *self {
                StrokeOpacity(ref __self_0_0) => {
                    StrokeOpacity(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StrokeOpacity {
        #[inline]
        fn eq(&self, other: &StrokeOpacity) -> bool {
            match *other {
                StrokeOpacity(ref __self_1_0) => match *self {
                    StrokeOpacity(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StrokeOpacity) -> bool {
            match *other {
                StrokeOpacity(ref __self_1_0) => match *self {
                    StrokeOpacity(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for StrokeOpacity {
        fn default() -> StrokeOpacity {
            StrokeOpacity(UnitInterval(1.0))
        }
    }
    impl ::property_macros::Property<ComputedValues> for StrokeOpacity {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StrokeOpacity {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<StrokeOpacity, ::error::AttributeError> {
            Ok(StrokeOpacity(<UnitInterval as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    pub struct StrokeWidth(pub RsvgLength);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for StrokeWidth {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                StrokeWidth(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("StrokeWidth");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for StrokeWidth {
        #[inline]
        fn clone(&self) -> StrokeWidth {
            match *self {
                StrokeWidth(ref __self_0_0) => {
                    StrokeWidth(::std::clone::Clone::clone(&(*__self_0_0)))
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for StrokeWidth {
        #[inline]
        fn eq(&self, other: &StrokeWidth) -> bool {
            match *other {
                StrokeWidth(ref __self_1_0) => match *self {
                    StrokeWidth(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &StrokeWidth) -> bool {
            match *other {
                StrokeWidth(ref __self_1_0) => match *self {
                    StrokeWidth(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for StrokeWidth {
        fn default() -> StrokeWidth {
            StrokeWidth(RsvgLength::parse_str("1.0", LengthDir::Both).unwrap())
        }
    }
    impl ::property_macros::Property<ComputedValues> for StrokeWidth {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for StrokeWidth {
        type Data = LengthDir;
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<StrokeWidth, ::error::AttributeError> {
            Ok(StrokeWidth(<RsvgLength as ::parsers::Parse>::parse(
                parser, d,
            )?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum TextAnchor {
        Start,
        Middle,
        End,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TextAnchor {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&TextAnchor::Start,) => {
                    let mut debug_trait_builder = f.debug_tuple("Start");
                    debug_trait_builder.finish()
                }
                (&TextAnchor::Middle,) => {
                    let mut debug_trait_builder = f.debug_tuple("Middle");
                    debug_trait_builder.finish()
                }
                (&TextAnchor::End,) => {
                    let mut debug_trait_builder = f.debug_tuple("End");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for TextAnchor {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for TextAnchor {
        #[inline]
        fn clone(&self) -> TextAnchor {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for TextAnchor {
        #[inline]
        fn eq(&self, other: &TextAnchor) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for TextAnchor {
        fn default() -> TextAnchor {
            TextAnchor::Start
        }
    }
    impl ::property_macros::Property<ComputedValues> for TextAnchor {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for TextAnchor {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<TextAnchor, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "start" => Ok(TextAnchor::Start),
                    "middle" => Ok(TextAnchor::Middle),
                    "end" => Ok(TextAnchor::End),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct TextDecoration {
        pub overline: bool,
        pub underline: bool,
        pub strike: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TextDecoration {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                TextDecoration {
                    overline: ref __self_0_0,
                    underline: ref __self_0_1,
                    strike: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("TextDecoration");
                    let _ = debug_trait_builder.field("overline", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("underline", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("strike", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for TextDecoration {
        #[inline]
        fn clone(&self) -> TextDecoration {
            match *self {
                TextDecoration {
                    overline: ref __self_0_0,
                    underline: ref __self_0_1,
                    strike: ref __self_0_2,
                } => TextDecoration {
                    overline: ::std::clone::Clone::clone(&(*__self_0_0)),
                    underline: ::std::clone::Clone::clone(&(*__self_0_1)),
                    strike: ::std::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for TextDecoration {
        #[inline]
        fn eq(&self, other: &TextDecoration) -> bool {
            match *other {
                TextDecoration {
                    overline: ref __self_1_0,
                    underline: ref __self_1_1,
                    strike: ref __self_1_2,
                } => match *self {
                    TextDecoration {
                        overline: ref __self_0_0,
                        underline: ref __self_0_1,
                        strike: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &TextDecoration) -> bool {
            match *other {
                TextDecoration {
                    overline: ref __self_1_0,
                    underline: ref __self_1_1,
                    strike: ref __self_1_2,
                } => match *self {
                    TextDecoration {
                        overline: ref __self_0_0,
                        underline: ref __self_0_1,
                        strike: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl Default for TextDecoration {
        fn default() -> TextDecoration {
            TextDecoration {
                overline: false,
                underline: false,
                strike: false,
            }
        }
    }
    impl ::property_macros::Property<ComputedValues> for TextDecoration {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl Parse for TextDecoration {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: Self::Data) -> Result<TextDecoration, AttributeError> {
            let mut overline = false;
            let mut underline = false;
            let mut strike = false;
            if parser.try(|p| p.expect_ident_matching("none")).is_ok() {
                return Ok(TextDecoration::default());
            }
            while !parser.is_exhausted() {
                let cow = parser.expect_ident().map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new(
                        "expected identifier",
                    ))
                })?;
                match cow.as_ref() {
                    "overline" => overline = true,
                    "underline" => underline = true,
                    "line-through" => strike = true,
                    _ => return Err(AttributeError::Parse(ParseError::new("invalid syntax"))),
                }
            }
            Ok(TextDecoration {
                overline,
                underline,
                strike,
            })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum TextRendering {
        Auto,
        OptimizeSpeed,
        OptimizeLegibility,
        GeometricPrecision,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for TextRendering {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&TextRendering::Auto,) => {
                    let mut debug_trait_builder = f.debug_tuple("Auto");
                    debug_trait_builder.finish()
                }
                (&TextRendering::OptimizeSpeed,) => {
                    let mut debug_trait_builder = f.debug_tuple("OptimizeSpeed");
                    debug_trait_builder.finish()
                }
                (&TextRendering::OptimizeLegibility,) => {
                    let mut debug_trait_builder = f.debug_tuple("OptimizeLegibility");
                    debug_trait_builder.finish()
                }
                (&TextRendering::GeometricPrecision,) => {
                    let mut debug_trait_builder = f.debug_tuple("GeometricPrecision");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for TextRendering {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for TextRendering {
        #[inline]
        fn clone(&self) -> TextRendering {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for TextRendering {
        #[inline]
        fn eq(&self, other: &TextRendering) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for TextRendering {
        fn default() -> TextRendering {
            TextRendering::Auto
        }
    }
    impl ::property_macros::Property<ComputedValues> for TextRendering {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for TextRendering {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<TextRendering, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "auto" => Ok(TextRendering::Auto),
                    "optimizeSpeed" => Ok(TextRendering::OptimizeSpeed),
                    "optimizeLegibility" => Ok(TextRendering::OptimizeLegibility),
                    "geometricPrecision" => Ok(TextRendering::GeometricPrecision),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum UnicodeBidi {
        Normal,
        Embed,
        Override,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for UnicodeBidi {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&UnicodeBidi::Normal,) => {
                    let mut debug_trait_builder = f.debug_tuple("Normal");
                    debug_trait_builder.finish()
                }
                (&UnicodeBidi::Embed,) => {
                    let mut debug_trait_builder = f.debug_tuple("Embed");
                    debug_trait_builder.finish()
                }
                (&UnicodeBidi::Override,) => {
                    let mut debug_trait_builder = f.debug_tuple("Override");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for UnicodeBidi {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for UnicodeBidi {
        #[inline]
        fn clone(&self) -> UnicodeBidi {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for UnicodeBidi {
        #[inline]
        fn eq(&self, other: &UnicodeBidi) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for UnicodeBidi {
        fn default() -> UnicodeBidi {
            UnicodeBidi::Normal
        }
    }
    impl ::property_macros::Property<ComputedValues> for UnicodeBidi {
        fn inherits_automatically() -> bool {
            false
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for UnicodeBidi {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<UnicodeBidi, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "normal" => Ok(UnicodeBidi::Normal),
                    "embed" => Ok(UnicodeBidi::Embed),
                    "bidi-override" => Ok(UnicodeBidi::Override),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum Visibility {
        Visible,
        Hidden,
        Collapse,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Visibility {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&Visibility::Visible,) => {
                    let mut debug_trait_builder = f.debug_tuple("Visible");
                    debug_trait_builder.finish()
                }
                (&Visibility::Hidden,) => {
                    let mut debug_trait_builder = f.debug_tuple("Hidden");
                    debug_trait_builder.finish()
                }
                (&Visibility::Collapse,) => {
                    let mut debug_trait_builder = f.debug_tuple("Collapse");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Visibility {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Visibility {
        #[inline]
        fn clone(&self) -> Visibility {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Visibility {
        #[inline]
        fn eq(&self, other: &Visibility) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for Visibility {
        fn default() -> Visibility {
            Visibility::Visible
        }
    }
    impl ::property_macros::Property<ComputedValues> for Visibility {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for Visibility {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<Visibility, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "visible" => Ok(Visibility::Visible),
                    "hidden" => Ok(Visibility::Hidden),
                    "collapse" => Ok(Visibility::Collapse),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    #[rustc_copy_clone_marker]
    pub enum WritingMode {
        Lr,
        LrTb,
        Rl,
        RlTb,
        Tb,
        TbRl,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for WritingMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&WritingMode::Lr,) => {
                    let mut debug_trait_builder = f.debug_tuple("Lr");
                    debug_trait_builder.finish()
                }
                (&WritingMode::LrTb,) => {
                    let mut debug_trait_builder = f.debug_tuple("LrTb");
                    debug_trait_builder.finish()
                }
                (&WritingMode::Rl,) => {
                    let mut debug_trait_builder = f.debug_tuple("Rl");
                    debug_trait_builder.finish()
                }
                (&WritingMode::RlTb,) => {
                    let mut debug_trait_builder = f.debug_tuple("RlTb");
                    debug_trait_builder.finish()
                }
                (&WritingMode::Tb,) => {
                    let mut debug_trait_builder = f.debug_tuple("Tb");
                    debug_trait_builder.finish()
                }
                (&WritingMode::TbRl,) => {
                    let mut debug_trait_builder = f.debug_tuple("TbRl");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for WritingMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for WritingMode {
        #[inline]
        fn clone(&self) -> WritingMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for WritingMode {
        #[inline]
        fn eq(&self, other: &WritingMode) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for WritingMode {
        fn default() -> WritingMode {
            WritingMode::LrTb
        }
    }
    impl ::property_macros::Property<ComputedValues> for WritingMode {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for WritingMode {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<WritingMode, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "lr" => Ok(WritingMode::Lr),
                    "lr-tb" => Ok(WritingMode::LrTb),
                    "rl" => Ok(WritingMode::Rl),
                    "rl-tb" => Ok(WritingMode::RlTb),
                    "tb" => Ok(WritingMode::Tb),
                    "tb-rl" => Ok(WritingMode::TbRl),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub struct XmlLang(pub String);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for XmlLang {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                XmlLang(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("XmlLang");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for XmlLang {
        #[inline]
        fn clone(&self) -> XmlLang {
            match *self {
                XmlLang(ref __self_0_0) => XmlLang(::std::clone::Clone::clone(&(*__self_0_0))),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for XmlLang {
        #[inline]
        fn eq(&self, other: &XmlLang) -> bool {
            match *other {
                XmlLang(ref __self_1_0) => match *self {
                    XmlLang(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &XmlLang) -> bool {
            match *other {
                XmlLang(ref __self_1_0) => match *self {
                    XmlLang(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for XmlLang {
        fn default() -> XmlLang {
            XmlLang("".to_string())
        }
    }
    impl ::property_macros::Property<ComputedValues> for XmlLang {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for XmlLang {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            d: Self::Data,
        ) -> Result<XmlLang, ::error::AttributeError> {
            Ok(XmlLang(<String as ::parsers::Parse>::parse(parser, d)?))
        }
    }
    #[rustc_copy_clone_marker]
    pub enum XmlSpace {
        Default,
        Preserve,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for XmlSpace {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&XmlSpace::Default,) => {
                    let mut debug_trait_builder = f.debug_tuple("Default");
                    debug_trait_builder.finish()
                }
                (&XmlSpace::Preserve,) => {
                    let mut debug_trait_builder = f.debug_tuple("Preserve");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for XmlSpace {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for XmlSpace {
        #[inline]
        fn clone(&self) -> XmlSpace {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for XmlSpace {
        #[inline]
        fn eq(&self, other: &XmlSpace) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl Default for XmlSpace {
        fn default() -> XmlSpace {
            XmlSpace::Default
        }
    }
    impl ::property_macros::Property<ComputedValues> for XmlSpace {
        fn inherits_automatically() -> bool {
            true
        }
        fn compute(&self, _v: &ComputedValues) -> Self {
            self.clone()
        }
    }
    impl ::parsers::Parse for XmlSpace {
        type Data = ();
        type Err = ::error::AttributeError;
        fn parse(
            parser: &mut ::cssparser::Parser,
            _: Self::Data,
        ) -> Result<XmlSpace, ::error::AttributeError> {
            let loc = parser.current_source_location();
            parser
                .expect_ident()
                .and_then(|cow| match cow.as_ref() {
                    "default" => Ok(XmlSpace::Default),
                    "preserve" => Ok(XmlSpace::Preserve),
                    _ => Err(
                        loc.new_basic_unexpected_token_error(::cssparser::Token::Ident(
                            ::cssparser::CowRcStr::from(cow.as_ref().to_string()),
                        )),
                    ),
                })
                .map_err(|_| {
                    ::error::AttributeError::Parse(::parsers::ParseError::new("unexpected value"))
                })
        }
    }
    pub fn from_c<'a>(state: *const RsvgState) -> &'a State {
        if !!state.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !state.is_null()",
                    &("rsvg_internals/src/state.rs", 1438u32, 5u32),
                )
            }
        };
        unsafe { &*(state as *const State) }
    }
    pub fn from_c_mut<'a>(state: *mut RsvgState) -> &'a mut State {
        if !!state.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !state.is_null()",
                    &("rsvg_internals/src/state.rs", 1444u32, 5u32),
                )
            }
        };
        unsafe { &mut *(state as *mut State) }
    }
    pub fn to_c_mut(state: &mut State) -> *mut RsvgState {
        state as *mut State as *mut RsvgState
    }
    #[no_mangle]
    pub extern "C" fn rsvg_state_new() -> *mut RsvgState {
        Box::into_raw(Box::new(State::new())) as *mut RsvgState
    }
    #[no_mangle]
    pub extern "C" fn rsvg_state_free(state: *mut RsvgState) {
        let state = from_c_mut(state);
        unsafe {
            Box::from_raw(state);
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_state_parse_style_pair(
        state: *mut RsvgState,
        attr: Attribute,
        value: *const libc::c_char,
        important: glib_sys::gboolean,
        accept_shorthands: glib_sys::gboolean,
    ) -> glib_sys::gboolean {
        let state = from_c_mut(state);
        if !!value.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !value.is_null()",
                    &("rsvg_internals/src/state.rs", 1479u32, 5u32),
                )
            }
        };
        let value = unsafe { utf8_cstr(value) };
        match state.parse_style_pair(
            attr,
            value,
            from_glib(important),
            from_glib(accept_shorthands),
        ) {
            Ok(_) => true.to_glib(),
            Err(_) => false.to_glib(),
        }
    }
    extern "C" {
        fn rsvg_lookup_apply_css_style(
            handle: *const RsvgHandle,
            target: *const libc::c_char,
            state: *mut RsvgState,
        ) -> glib_sys::gboolean;
    }
    #[no_mangle]
    pub extern "C" fn rsvg_parse_style_attrs(
        handle: *const RsvgHandle,
        raw_node: *const RsvgNode,
        tag: *const libc::c_char,
        pbag: *const PropertyBag,
    ) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/state.rs", 1509u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        let tag = unsafe { utf8_cstr(tag) };
        let pbag = unsafe { &*pbag };
        parse_style_attrs(handle, node, tag, pbag);
    }
    pub fn parse_style_attrs(
        handle: *const RsvgHandle,
        node: &RsvgNode,
        tag: &str,
        pbag: &PropertyBag,
    ) {
        let state = node.get_state_mut();
        match state.parse_presentation_attributes(pbag) {
            Ok(_) => (),
            Err(_) => (),
        }
        unsafe {
            rsvg_lookup_apply_css_style(handle, "*".to_glib_none().0, to_c_mut(state));
            rsvg_lookup_apply_css_style(handle, tag.to_glib_none().0, to_c_mut(state));
            if let Some(klazz) = node.get_class() {
                for cls in klazz.split_whitespace() {
                    let mut found = false;
                    if !cls.is_empty() {
                        if let Some(id) = node.get_id() {
                            let target = ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                                &["", ".", "#"],
                                &match (&tag, &cls, &id) {
                                    (arg0, arg1, arg2) => [
                                        ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                        ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                                        ::std::fmt::ArgumentV1::new(arg2, ::std::fmt::Display::fmt),
                                    ],
                                },
                                &[
                                    ::std::fmt::rt::v1::Argument {
                                        position: ::std::fmt::rt::v1::Position::At(0usize),
                                        format: ::std::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::std::fmt::rt::v1::Count::Implied,
                                            width: ::std::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::std::fmt::rt::v1::Argument {
                                        position: ::std::fmt::rt::v1::Position::At(1usize),
                                        format: ::std::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::std::fmt::rt::v1::Count::Implied,
                                            width: ::std::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::std::fmt::rt::v1::Argument {
                                        position: ::std::fmt::rt::v1::Position::At(2usize),
                                        format: ::std::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::std::fmt::rt::v1::Count::Implied,
                                            width: ::std::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ));
                            found = found
                                || from_glib(rsvg_lookup_apply_css_style(
                                    handle,
                                    target.to_glib_none().0,
                                    to_c_mut(state),
                                ));
                        }
                        if let Some(id) = node.get_id() {
                            let target = ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                                &[".", "#"],
                                &match (&cls, &id) {
                                    (arg0, arg1) => [
                                        ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                        ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                                    ],
                                },
                                &[
                                    ::std::fmt::rt::v1::Argument {
                                        position: ::std::fmt::rt::v1::Position::At(0usize),
                                        format: ::std::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::std::fmt::rt::v1::Count::Implied,
                                            width: ::std::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                    ::std::fmt::rt::v1::Argument {
                                        position: ::std::fmt::rt::v1::Position::At(1usize),
                                        format: ::std::fmt::rt::v1::FormatSpec {
                                            fill: ' ',
                                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                                            flags: 0u32,
                                            precision: ::std::fmt::rt::v1::Count::Implied,
                                            width: ::std::fmt::rt::v1::Count::Implied,
                                        },
                                    },
                                ],
                            ));
                            found = found
                                || from_glib(rsvg_lookup_apply_css_style(
                                    handle,
                                    target.to_glib_none().0,
                                    to_c_mut(state),
                                ));
                        }
                        let target = ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                            &["", "."],
                            &match (&tag, &cls) {
                                (arg0, arg1) => [
                                    ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                                    ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                                ],
                            },
                            &[
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                                ::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(1usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                },
                            ],
                        ));
                        found = found
                            || from_glib(rsvg_lookup_apply_css_style(
                                handle,
                                target.to_glib_none().0,
                                to_c_mut(state),
                            ));
                        if !found {
                            let target = ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                                &["."],
                                &match (&cls,) {
                                    (arg0,) => [::std::fmt::ArgumentV1::new(
                                        arg0,
                                        ::std::fmt::Display::fmt,
                                    )],
                                },
                                &[::std::fmt::rt::v1::Argument {
                                    position: ::std::fmt::rt::v1::Position::At(0usize),
                                    format: ::std::fmt::rt::v1::FormatSpec {
                                        fill: ' ',
                                        align: ::std::fmt::rt::v1::Alignment::Unknown,
                                        flags: 0u32,
                                        precision: ::std::fmt::rt::v1::Count::Implied,
                                        width: ::std::fmt::rt::v1::Count::Implied,
                                    },
                                }],
                            ));
                            rsvg_lookup_apply_css_style(
                                handle,
                                target.to_glib_none().0,
                                to_c_mut(state),
                            );
                        }
                    }
                }
            }
            if let Some(id) = node.get_id() {
                let target = ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                    &["#"],
                    &match (&id,) {
                        (arg0,) => [::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt)],
                    },
                    &[::std::fmt::rt::v1::Argument {
                        position: ::std::fmt::rt::v1::Position::At(0usize),
                        format: ::std::fmt::rt::v1::FormatSpec {
                            fill: ' ',
                            align: ::std::fmt::rt::v1::Alignment::Unknown,
                            flags: 0u32,
                            precision: ::std::fmt::rt::v1::Count::Implied,
                            width: ::std::fmt::rt::v1::Count::Implied,
                        },
                    }],
                ));
                rsvg_lookup_apply_css_style(handle, target.to_glib_none().0, to_c_mut(state));
                let target = ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                    &["", "#"],
                    &match (&tag, &id) {
                        (arg0, arg1) => [
                            ::std::fmt::ArgumentV1::new(arg0, ::std::fmt::Display::fmt),
                            ::std::fmt::ArgumentV1::new(arg1, ::std::fmt::Display::fmt),
                        ],
                    },
                    &[
                        ::std::fmt::rt::v1::Argument {
                            position: ::std::fmt::rt::v1::Position::At(0usize),
                            format: ::std::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::std::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::std::fmt::rt::v1::Count::Implied,
                                width: ::std::fmt::rt::v1::Count::Implied,
                            },
                        },
                        ::std::fmt::rt::v1::Argument {
                            position: ::std::fmt::rt::v1::Position::At(1usize),
                            format: ::std::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::std::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::std::fmt::rt::v1::Count::Implied,
                                width: ::std::fmt::rt::v1::Count::Implied,
                            },
                        },
                    ],
                ));
                rsvg_lookup_apply_css_style(handle, target.to_glib_none().0, to_c_mut(state));
            }
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::Style => {
                        if let Err(e) = state.parse_style_declarations(value) {
                            node.set_error(e);
                            break;
                        }
                    }
                    _ => (),
                }
            }
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_computed_values_get_lighting_color_argb(
        values: RsvgComputedValues,
    ) -> u32 {
        if !!values.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !values.is_null()",
                    &("rsvg_internals/src/state.rs", 1637u32, 5u32),
                )
            }
        };
        let values = unsafe { &*values };
        match values.lighting_color {
            LightingColor(cssparser::Color::CurrentColor) => rgba_to_argb(values.color.0),
            LightingColor(cssparser::Color::RGBA(ref rgba)) => rgba_to_argb(*rgba),
        }
    }
}
mod stop {
    use attributes::Attribute;
    use error::*;
    use handle::RsvgHandle;
    use length::*;
    use node::*;
    use parsers::parse_and_validate;
    use property_bag::PropertyBag;
    use std::cell::Cell;
    pub struct NodeStop {
        offset: Cell<f64>,
    }
    impl NodeStop {
        pub fn new() -> NodeStop {
            NodeStop {
                offset: Cell::new(0.0),
            }
        }
        pub fn get_offset(&self) -> f64 {
            self.offset.get()
        }
    }
    fn validate_offset(length: RsvgLength) -> Result<RsvgLength, AttributeError> {
        match length.unit {
            LengthUnit::Default | LengthUnit::Percent => {
                let mut offset = length.length;
                if offset < 0.0 {
                    offset = 0.0;
                } else if offset > 1.0 {
                    offset = 1.0;
                }
                Ok(RsvgLength::new(
                    offset,
                    LengthUnit::Default,
                    LengthDir::Both,
                ))
            }
            _ => Err(AttributeError::Value(
                "stop offset must be in default or percent units".to_string(),
            )),
        }
    }
    impl NodeTrait for NodeStop {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::Offset => {
                        let length =
                            parse_and_validate("offset", value, LengthDir::Both, validate_offset)?;
                        if !(length.unit == LengthUnit::Default
                            || length.unit == LengthUnit::Percent)
                        {
                            {
                                ::rt::begin_panic("assertion failed: length.unit == LengthUnit::Default || length.unit == LengthUnit::Percent",
                                                  &("rsvg_internals/src/stop.rs",
                                                    58u32, 21u32))
                            }
                        };
                        self.offset.set(length.length);
                    }
                    _ => (),
                }
            }
            Ok(())
        }
    }
}
mod structure {
    use aspect_ratio::*;
    use attributes::Attribute;
    use cairo;
    use cairo_sys;
    use drawing_ctx::DrawingCtx;
    use float_eq_cairo::ApproxEqCairo;
    use glib::translate::*;
    use glib_sys;
    use handle::RsvgHandle;
    use length::*;
    use node::*;
    use parsers::{parse, parse_and_validate, Parse};
    use property_bag::{OwnedPropertyBag, PropertyBag};
    use state::{self, Overflow};
    use std::cell::Cell;
    use std::cell::RefCell;
    use viewbox::*;
    use viewport::{draw_in_viewport, ClipMode};
    pub struct NodeGroup();
    impl NodeGroup {
        pub fn new() -> NodeGroup {
            NodeGroup()
        }
    }
    impl NodeTrait for NodeGroup {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, _: &PropertyBag) -> NodeResult {
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            draw_ctx.with_discrete_layer(
                node,
                values,
                clipping,
                &mut (|dc| {
                    node.draw_children(cascaded, dc, clipping);
                }),
            );
        }
    }
    pub struct NodeDefs();
    impl NodeDefs {
        pub fn new() -> NodeDefs {
            NodeDefs()
        }
    }
    impl NodeTrait for NodeDefs {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, _: &PropertyBag) -> NodeResult {
            Ok(())
        }
    }
    pub struct NodeSwitch();
    impl NodeSwitch {
        pub fn new() -> NodeSwitch {
            NodeSwitch()
        }
    }
    impl NodeTrait for NodeSwitch {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, _: &PropertyBag) -> NodeResult {
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            draw_ctx.with_discrete_layer(
                node,
                values,
                clipping,
                &mut (|dc| {
                    if let Some(child) = node.children().find(|c| c.get_cond()) {
                        dc.draw_node_from_stack(
                            &CascadedValues::new(cascaded, &child),
                            &child,
                            clipping,
                        );
                    }
                }),
            );
        }
    }
    pub struct NodeSvg {
        preserve_aspect_ratio: Cell<AspectRatio>,
        x: Cell<RsvgLength>,
        y: Cell<RsvgLength>,
        w: Cell<RsvgLength>,
        h: Cell<RsvgLength>,
        vbox: Cell<Option<ViewBox>>,
        pbag: RefCell<Option<OwnedPropertyBag>>,
    }
    impl NodeSvg {
        pub fn new() -> NodeSvg {
            NodeSvg {
                preserve_aspect_ratio: Cell::new(AspectRatio::default()),
                x: Cell::new(RsvgLength::parse_str("0", LengthDir::Horizontal).unwrap()),
                y: Cell::new(RsvgLength::parse_str("0", LengthDir::Vertical).unwrap()),
                w: Cell::new(RsvgLength::parse_str("100%", LengthDir::Horizontal).unwrap()),
                h: Cell::new(RsvgLength::parse_str("100%", LengthDir::Vertical).unwrap()),
                vbox: Cell::new(None),
                pbag: RefCell::new(None),
            }
        }
    }
    impl NodeTrait for NodeSvg {
        fn set_atts(
            &self,
            node: &RsvgNode,
            _: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            node.set_overflow_hidden();
            let is_inner_svg = node.get_parent().is_some();
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::PreserveAspectRatio => {
                        self.preserve_aspect_ratio
                            .set(parse("preserveAspectRatio", value, ())?)
                    }
                    Attribute::X => {
                        if is_inner_svg {
                            self.x.set(parse("x", value, LengthDir::Horizontal)?);
                        }
                    }
                    Attribute::Y => {
                        if is_inner_svg {
                            self.y.set(parse("y", value, LengthDir::Vertical)?);
                        }
                    }
                    Attribute::Width => self.w.set(parse_and_validate(
                        "width",
                        value,
                        LengthDir::Horizontal,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::Height => self.h.set(parse_and_validate(
                        "height",
                        value,
                        LengthDir::Vertical,
                        RsvgLength::check_nonnegative,
                    )?),
                    Attribute::ViewBox => self.vbox.set(parse("viewBox", value, ()).map(Some)?),
                    _ => (),
                }
            }
            *self.pbag.borrow_mut() = Some(pbag.to_owned());
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let nx = self.x.get().normalize(values, draw_ctx);
            let ny = self.y.get().normalize(values, draw_ctx);
            let nw = self.w.get().normalize(values, draw_ctx);
            let nh = self.h.get().normalize(values, draw_ctx);
            let do_clip = !values.is_overflow() && node.get_parent().is_some();
            draw_in_viewport(
                nx,
                ny,
                nw,
                nh,
                ClipMode::ClipToViewport,
                do_clip,
                self.vbox.get(),
                self.preserve_aspect_ratio.get(),
                node,
                values,
                draw_ctx.get_cairo_context().get_matrix(),
                draw_ctx,
                clipping,
                &mut (|dc| {
                    node.draw_children(cascaded, dc, clipping);
                }),
            );
        }
    }
    pub struct NodeUse {
        link: RefCell<Option<String>>,
        x: Cell<RsvgLength>,
        y: Cell<RsvgLength>,
        w: Cell<Option<RsvgLength>>,
        h: Cell<Option<RsvgLength>>,
    }
    impl NodeUse {
        pub fn new() -> NodeUse {
            NodeUse {
                link: RefCell::new(None),
                x: Cell::new(RsvgLength::default()),
                y: Cell::new(RsvgLength::default()),
                w: Cell::new(None),
                h: Cell::new(None),
            }
        }
    }
    impl NodeTrait for NodeUse {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::XlinkHref => *self.link.borrow_mut() = Some(value.to_owned()),
                    Attribute::X => self.x.set(parse("x", value, LengthDir::Horizontal)?),
                    Attribute::Y => self.y.set(parse("y", value, LengthDir::Vertical)?),
                    Attribute::Width => self.w.set(
                        parse_and_validate(
                            "width",
                            value,
                            LengthDir::Horizontal,
                            RsvgLength::check_nonnegative,
                        ).map(Some)?,
                    ),
                    Attribute::Height => self.h.set(
                        parse_and_validate(
                            "height",
                            value,
                            LengthDir::Vertical,
                            RsvgLength::check_nonnegative,
                        ).map(Some)?,
                    ),
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let link = self.link.borrow();
            if link.is_none() {
                return;
            }
            let acquired = draw_ctx.get_acquired_node(link.as_ref().unwrap());
            let child = if let Some(acquired) = acquired {
                acquired.get()
            } else {
                return;
            };
            if Node::is_ancestor(node.clone(), child.clone()) {
                return;
            }
            let nx = self.x.get().normalize(values, draw_ctx);
            let ny = self.y.get().normalize(values, draw_ctx);
            let nw = self
                .w
                .get()
                .unwrap_or_else(|| RsvgLength::parse_str("100%", LengthDir::Horizontal).unwrap())
                .normalize(values, draw_ctx);
            let nh = self
                .h
                .get()
                .unwrap_or_else(|| RsvgLength::parse_str("100%", LengthDir::Vertical).unwrap())
                .normalize(values, draw_ctx);
            if nw.approx_eq_cairo(&0.0) || nh.approx_eq_cairo(&0.0) {
                return;
            }
            if child.get_type() != NodeType::Symbol {
                let cr = draw_ctx.get_cairo_context();
                cr.translate(nx, ny);
                draw_ctx.with_discrete_layer(
                    node,
                    values,
                    clipping,
                    &mut (|dc| {
                        dc.draw_node_from_stack(
                            &CascadedValues::new_from_values(&child, values),
                            &child,
                            clipping,
                        );
                    }),
                );
            } else {
                child.with_impl(|symbol: &NodeSymbol| {
                    let do_clip = !values.is_overflow()
                        || (values.overflow == Overflow::Visible
                            && child.get_specified_values().is_overflow());
                    draw_in_viewport(
                        nx,
                        ny,
                        nw,
                        nh,
                        ClipMode::ClipToVbox,
                        do_clip,
                        symbol.vbox.get(),
                        symbol.preserve_aspect_ratio.get(),
                        node,
                        values,
                        draw_ctx.get_cairo_context().get_matrix(),
                        draw_ctx,
                        clipping,
                        &mut (|dc| {
                            child.draw_children(
                                &CascadedValues::new_from_values(&child, values),
                                dc,
                                clipping,
                            );
                        }),
                    );
                });
            }
        }
    }
    pub struct NodeSymbol {
        preserve_aspect_ratio: Cell<AspectRatio>,
        vbox: Cell<Option<ViewBox>>,
    }
    impl NodeSymbol {
        pub fn new() -> NodeSymbol {
            NodeSymbol {
                preserve_aspect_ratio: Cell::new(AspectRatio::default()),
                vbox: Cell::new(None),
            }
        }
    }
    impl NodeTrait for NodeSymbol {
        fn set_atts(
            &self,
            node: &RsvgNode,
            _: *const RsvgHandle,
            pbag: &PropertyBag,
        ) -> NodeResult {
            node.set_overflow_hidden();
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::PreserveAspectRatio => {
                        self.preserve_aspect_ratio
                            .set(parse("preserveAspectRatio", value, ())?)
                    }
                    Attribute::ViewBox => self.vbox.set(parse("viewBox", value, ()).map(Some)?),
                    _ => (),
                }
            }
            Ok(())
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_svg_get_size(
        raw_node: *const RsvgNode,
        out_width: *mut RsvgLength,
        out_height: *mut RsvgLength,
    ) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/structure.rs", 406u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        if !!out_width.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !out_width.is_null()",
                    &("rsvg_internals/src/structure.rs", 409u32, 5u32),
                )
            }
        };
        if !!out_height.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !out_height.is_null()",
                    &("rsvg_internals/src/structure.rs", 410u32, 5u32),
                )
            }
        };
        node.with_impl(|svg: &NodeSvg| unsafe {
            *out_width = svg.w.get();
            *out_height = svg.h.get();
        });
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_svg_get_view_box(
        raw_node: *const RsvgNode,
        out_vbox: *mut cairo_sys::cairo_rectangle_t,
    ) -> glib_sys::gboolean {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/structure.rs", 423u32, 5u32),
                )
            }
        };
        if !!out_vbox.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !out_vbox.is_null()",
                    &("rsvg_internals/src/structure.rs", 424u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        let mut vbox: Option<ViewBox> = None;
        node.with_impl(|svg: &NodeSvg| {
            vbox = svg.vbox.get();
        });
        if let Some(vb) = vbox {
            unsafe {
                *out_vbox = vb.0;
            }
            true.to_glib()
        } else {
            unsafe {
                *out_vbox = cairo::Rectangle {
                    x: 0.0,
                    y: 0.0,
                    width: 0.0,
                    height: 0.0,
                };
            }
            false.to_glib()
        }
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_svg_apply_atts(
        raw_node: *const RsvgNode,
        handle: *const RsvgHandle,
    ) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/structure.rs", 455u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        node.with_impl(|svg: &NodeSvg| {
            if let Some(owned_pbag) = svg.pbag.borrow().as_ref() {
                let pbag = PropertyBag::from_owned(owned_pbag);
                state::parse_style_attrs(handle, node, "svg", &pbag);
            }
        });
    }
}
pub mod surface_utils {
    //! Various utilities for working with Cairo image surfaces.
    use cairo;
    use std::ops::DerefMut;
    pub mod iterators {
        //! Pixel iterators for `SharedImageSurface`.
        use super::shared_surface::SharedImageSurface;
        use super::{EdgeMode, Pixel};
        use filters::context::IRect;
        use util::clamp;
        /// Iterator over pixels of a `SharedImageSurface`.
        #[rustc_copy_clone_marker]
        pub struct Pixels<'a> {
            surface: &'a SharedImageSurface,
            bounds: IRect,
            x: u32,
            y: u32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::fmt::Debug for Pixels<'a> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    Pixels {
                        surface: ref __self_0_0,
                        bounds: ref __self_0_1,
                        x: ref __self_0_2,
                        y: ref __self_0_3,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Pixels");
                        let _ = debug_trait_builder.field("surface", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("bounds", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("x", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("y", &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::clone::Clone for Pixels<'a> {
            #[inline]
            fn clone(&self) -> Pixels<'a> {
                {
                    let _: ::std::clone::AssertParamIsClone<
                        &'a SharedImageSurface,
                    >;
                    let _: ::std::clone::AssertParamIsClone<IRect>;
                    let _: ::std::clone::AssertParamIsClone<u32>;
                    let _: ::std::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::marker::Copy for Pixels<'a> {}
        /// Iterator over a (potentially out of bounds) rectangle of pixels of a `SharedImageSurface`.
        #[rustc_copy_clone_marker]
        pub struct PixelRectangle<'a> {
            surface: &'a SharedImageSurface,
            bounds: IRect,
            rectangle: IRect,
            edge_mode: EdgeMode,
            x: i32,
            y: i32,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::fmt::Debug for PixelRectangle<'a> {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    PixelRectangle {
                        surface: ref __self_0_0,
                        bounds: ref __self_0_1,
                        rectangle: ref __self_0_2,
                        edge_mode: ref __self_0_3,
                        x: ref __self_0_4,
                        y: ref __self_0_5,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("PixelRectangle");
                        let _ = debug_trait_builder.field("surface", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("bounds", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("rectangle", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("edge_mode", &&(*__self_0_3));
                        let _ = debug_trait_builder.field("x", &&(*__self_0_4));
                        let _ = debug_trait_builder.field("y", &&(*__self_0_5));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::clone::Clone for PixelRectangle<'a> {
            #[inline]
            fn clone(&self) -> PixelRectangle<'a> {
                {
                    let _: ::std::clone::AssertParamIsClone<
                        &'a SharedImageSurface,
                    >;
                    let _: ::std::clone::AssertParamIsClone<IRect>;
                    let _: ::std::clone::AssertParamIsClone<IRect>;
                    let _: ::std::clone::AssertParamIsClone<EdgeMode>;
                    let _: ::std::clone::AssertParamIsClone<i32>;
                    let _: ::std::clone::AssertParamIsClone<i32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl<'a> ::std::marker::Copy for PixelRectangle<'a> {}
        impl<'a> Pixels<'a> {
            /// Creates an iterator over the image surface pixels, constrained within the given bounds.
            #[inline]
            pub fn new(surface: &'a SharedImageSurface, bounds: IRect) -> Self {
                if !(bounds.x0 >= 0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x0 >= 0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 33u32, 9u32),
                        )
                    }
                };
                if !(bounds.x0 <= surface.width()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x0 <= surface.width()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 34u32, 9u32),
                        )
                    }
                };
                if !(bounds.x1 >= bounds.x0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x1 >= bounds.x0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 35u32, 9u32),
                        )
                    }
                };
                if !(bounds.x1 <= surface.width()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x1 <= surface.width()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 36u32, 9u32),
                        )
                    }
                };
                if !(bounds.y0 >= 0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y0 >= 0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 37u32, 9u32),
                        )
                    }
                };
                if !(bounds.y0 <= surface.height()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y0 <= surface.height()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 38u32, 9u32),
                        )
                    }
                };
                if !(bounds.y1 >= bounds.y0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y1 >= bounds.y0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 39u32, 9u32),
                        )
                    }
                };
                if !(bounds.y1 <= surface.height()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y1 <= surface.height()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 40u32, 9u32),
                        )
                    }
                };
                Self {
                    surface,
                    bounds,
                    x: bounds.x0 as u32,
                    y: bounds.y0 as u32,
                }
            }
        }
        impl<'a> PixelRectangle<'a> {
            /// Creates an iterator over the image surface pixels, constrained within the given bounds.
            #[inline]
            pub fn new(
                surface: &'a SharedImageSurface,
                bounds: IRect,
                rectangle: IRect,
                edge_mode: EdgeMode,
            ) -> Self {
                if !(bounds.x0 >= 0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x0 >= 0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 61u32, 9u32),
                        )
                    }
                };
                if !(bounds.x0 <= surface.width()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x0 <= surface.width()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 62u32, 9u32),
                        )
                    }
                };
                if !(bounds.x1 >= bounds.x0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x1 >= bounds.x0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 63u32, 9u32),
                        )
                    }
                };
                if !(bounds.x1 <= surface.width()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.x1 <= surface.width()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 64u32, 9u32),
                        )
                    }
                };
                if !(bounds.y0 >= 0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y0 >= 0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 65u32, 9u32),
                        )
                    }
                };
                if !(bounds.y0 <= surface.height()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y0 <= surface.height()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 66u32, 9u32),
                        )
                    }
                };
                if !(bounds.y1 >= bounds.y0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y1 >= bounds.y0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 67u32, 9u32),
                        )
                    }
                };
                if !(bounds.y1 <= surface.height()) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: bounds.y1 <= surface.height()",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 68u32, 9u32),
                        )
                    }
                };
                if !(rectangle.x1 >= rectangle.x0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: rectangle.x1 >= rectangle.x0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 70u32, 9u32),
                        )
                    }
                };
                if !(rectangle.y1 >= rectangle.y0) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: rectangle.y1 >= rectangle.y0",
                            &("rsvg_internals/src/surface_utils/iterators.rs", 71u32, 9u32),
                        )
                    }
                };
                Self {
                    surface,
                    bounds,
                    rectangle,
                    edge_mode,
                    x: rectangle.x0,
                    y: rectangle.y0,
                }
            }
        }
        impl<'a> Iterator for Pixels<'a> {
            type Item = (u32, u32, Pixel);
            #[inline]
            fn next(&mut self) -> Option<Self::Item> {
                if self.x == self.bounds.x1 as u32 || self.y == self.bounds.y1 as u32 {
                    return None;
                }
                let rv = Some((self.x, self.y, self.surface.get_pixel(self.x, self.y)));
                if self.x + 1 == self.bounds.x1 as u32 {
                    self.x = self.bounds.x0 as u32;
                    self.y += 1;
                } else {
                    self.x += 1;
                }
                rv
            }
        }
        impl<'a> Iterator for PixelRectangle<'a> {
            type Item = (i32, i32, Pixel);
            #[inline]
            fn next(&mut self) -> Option<Self::Item> {
                if self.x == self.rectangle.x1 || self.y == self.rectangle.y1 {
                    return None;
                }
                let rv = {
                    let get_pixel = |x, y| {
                        if x < self.bounds.x0
                            || y < self.bounds.y0
                            || x >= self.bounds.x1
                            || y >= self.bounds.y1
                        {
                            match self.edge_mode {
                                EdgeMode::None => Pixel {
                                    r: 0,
                                    g: 0,
                                    b: 0,
                                    a: 0,
                                },
                                EdgeMode::Duplicate => {
                                    let x = clamp(x, self.bounds.x0, self.bounds.x1);
                                    let y = clamp(y, self.bounds.y0, self.bounds.y1);
                                    self.surface.get_pixel(x as u32, y as u32)
                                }
                                EdgeMode::Wrap => {
                                    let wrap = |mut x, v| {
                                        while x < 0 {
                                            x += v;
                                        }
                                        x % v
                                    };
                                    let x = self.bounds.x0
                                        + wrap(x - self.bounds.x0, self.bounds.x1 - self.bounds.x0);
                                    let y = self.bounds.y0
                                        + wrap(y - self.bounds.y0, self.bounds.y1 - self.bounds.y0);
                                    self.surface.get_pixel(x as u32, y as u32)
                                }
                            }
                        } else {
                            self.surface.get_pixel(x as u32, y as u32)
                        }
                    };
                    Some((self.x, self.y, get_pixel(self.x, self.y)))
                };
                if self.x + 1 == self.rectangle.x1 {
                    self.x = self.rectangle.x0;
                    self.y += 1;
                } else {
                    self.x += 1;
                }
                rv
            }
        }
    }
    pub mod shared_surface {
        //! Shared access to Cairo image surfaces.
        use super::{
            iterators::{PixelRectangle, Pixels},
            EdgeMode, ImageSurfaceDataExt, Pixel,
        };
        use cairo::prelude::SurfaceExt;
        use cairo::{self, ImageSurface};
        use cairo_sys;
        use filters::context::IRect;
        use glib::translate::{Stash, ToGlibPtr};
        use rulinalg::matrix::{BaseMatrix, Matrix};
        use std::ptr::NonNull;
        use util::clamp;
        /// Wrapper for a Cairo image surface that allows shared access.
        ///
        /// There doesn't seem to be any good way of making safe shared access to `ImageSurface` pixel
        /// data, since a read-only borrowed reference can still be cloned and then modified (for example,
        /// via a `Context`). We can't simply use `ImageSurface::get_data()` because in the filter code we
        /// have surfaces referenced from multiple places and it would probably add more complexity to
        /// remove that and start passing around references.
        ///
        /// This wrapper asserts the uniqueness of its image surface and doesn't permit modifying it.
        ///
        /// Note: originally I had an idea of using `Rc<RefCell<ImageSurface>>` here which allows to create
        /// both read-only and unique read-write accessors safely, however then I realized a read-write
        /// accessor isn't of much use if it can't expose a Cairo context interface. Cairo contexts have
        /// the very same issue that they can be cloned from a read-only reference and break all safety
        /// constraints in this way. Thus the only safe way of exposing a Cairo context seemed to be to
        /// manually add all Cairo context methods on the accessor forwarding to the underlying Cairo
        /// context (without exposing the context itself to prevent cloning), which would result in too
        /// much code. Unless it's absolutely required, I'd like to avoid that.
        ///
        /// Having just read-only access simplifies things further dropping the need for `Rc<RefCell<>>`
        /// altogether.
        pub struct SharedImageSurface {
            surface: ImageSurface,
            data_ptr: NonNull<u8>,
            width: i32,
            height: i32,
            stride: isize,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::fmt::Debug for SharedImageSurface {
            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                match *self {
                    SharedImageSurface {
                        surface: ref __self_0_0,
                        data_ptr: ref __self_0_1,
                        width: ref __self_0_2,
                        height: ref __self_0_3,
                        stride: ref __self_0_4,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("SharedImageSurface");
                        let _ = debug_trait_builder.field("surface", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("data_ptr", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("width", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("height", &&(*__self_0_3));
                        let _ = debug_trait_builder.field("stride", &&(*__self_0_4));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::std::clone::Clone for SharedImageSurface {
            #[inline]
            fn clone(&self) -> SharedImageSurface {
                match *self {
                    SharedImageSurface {
                        surface: ref __self_0_0,
                        data_ptr: ref __self_0_1,
                        width: ref __self_0_2,
                        height: ref __self_0_3,
                        stride: ref __self_0_4,
                    } => SharedImageSurface {
                        surface: ::std::clone::Clone::clone(&(*__self_0_0)),
                        data_ptr: ::std::clone::Clone::clone(&(*__self_0_1)),
                        width: ::std::clone::Clone::clone(&(*__self_0_2)),
                        height: ::std::clone::Clone::clone(&(*__self_0_3)),
                        stride: ::std::clone::Clone::clone(&(*__self_0_4)),
                    },
                }
            }
        }
        impl SharedImageSurface {
            /// Creates a `SharedImageSurface` from a unique `ImageSurface`.
            ///
            /// # Panics
            /// Panics if the `ImageSurface` is not unique, that is, its reference count isn't 1.
            #[inline]
            pub fn new(surface: ImageSurface) -> Result<Self, cairo::Status> {
                let reference_count =
                    unsafe { cairo_sys::cairo_surface_get_reference_count(surface.to_raw_none()) };
                {
                    match (&reference_count, &1) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                {
                                    ::rt::begin_panic_fmt(
                                        &::std::fmt::Arguments::new_v1_formatted(
                                            &[
                                                "assertion failed: `(left == right)`\n  left: `",
                                                "`,\n right: `",
                                                "`",
                                            ],
                                            &match (&left_val, &right_val) {
                                                (arg0, arg1) => [
                                                    ::std::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::std::fmt::Debug::fmt,
                                                    ),
                                                    ::std::fmt::ArgumentV1::new(
                                                        arg1,
                                                        ::std::fmt::Debug::fmt,
                                                    ),
                                                ],
                                            },
                                            &[
                                                ::std::fmt::rt::v1::Argument {
                                                    position: ::std::fmt::rt::v1::Position::At(
                                                        0usize,
                                                    ),
                                                    format: ::std::fmt::rt::v1::FormatSpec {
                                                        fill: ' ',
                                                        align:
                                                            ::std::fmt::rt::v1::Alignment::Unknown,
                                                        flags: 0u32,
                                                        precision:
                                                            ::std::fmt::rt::v1::Count::Implied,
                                                        width: ::std::fmt::rt::v1::Count::Implied,
                                                    },
                                                },
                                                ::std::fmt::rt::v1::Argument {
                                                    position: ::std::fmt::rt::v1::Position::At(
                                                        1usize,
                                                    ),
                                                    format: ::std::fmt::rt::v1::FormatSpec {
                                                        fill: ' ',
                                                        align:
                                                            ::std::fmt::rt::v1::Alignment::Unknown,
                                                        flags: 0u32,
                                                        precision:
                                                            ::std::fmt::rt::v1::Count::Implied,
                                                        width: ::std::fmt::rt::v1::Count::Implied,
                                                    },
                                                },
                                            ],
                                        ),
                                        &(
                                            "rsvg_internals/src/surface_utils/shared_surface.rs",
                                            60u32,
                                            9u32,
                                        ),
                                    )
                                }
                            }
                        }
                    }
                };
                surface.flush();
                if surface.status() != cairo::Status::Success {
                    return Err(surface.status());
                }
                let data_ptr = NonNull::new(unsafe {
                    cairo_sys::cairo_image_surface_get_data(surface.to_raw_none())
                }).unwrap();
                let width = surface.get_width();
                let height = surface.get_height();
                let stride = surface.get_stride() as isize;
                Ok(Self {
                    surface,
                    data_ptr,
                    width,
                    height,
                    stride,
                })
            }
            /// Converts this `SharedImageSurface` back into a Cairo image surface.
            ///
            /// # Panics
            /// Panics if the underlying Cairo image surface is not unique, that is, there are other
            /// instances of `SharedImageSurface` pointing at the same Cairo image surface.
            #[inline]
            pub fn into_image_surface(self) -> ImageSurface {
                let reference_count = unsafe {
                    cairo_sys::cairo_surface_get_reference_count(self.surface.to_raw_none())
                };
                {
                    match (&reference_count, &1) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                {
                                    ::rt::begin_panic_fmt(
                                        &::std::fmt::Arguments::new_v1_formatted(
                                            &[
                                                "assertion failed: `(left == right)`\n  left: `",
                                                "`,\n right: `",
                                                "`",
                                            ],
                                            &match (&left_val, &right_val) {
                                                (arg0, arg1) => [
                                                    ::std::fmt::ArgumentV1::new(
                                                        arg0,
                                                        ::std::fmt::Debug::fmt,
                                                    ),
                                                    ::std::fmt::ArgumentV1::new(
                                                        arg1,
                                                        ::std::fmt::Debug::fmt,
                                                    ),
                                                ],
                                            },
                                            &[
                                                ::std::fmt::rt::v1::Argument {
                                                    position: ::std::fmt::rt::v1::Position::At(
                                                        0usize,
                                                    ),
                                                    format: ::std::fmt::rt::v1::FormatSpec {
                                                        fill: ' ',
                                                        align:
                                                            ::std::fmt::rt::v1::Alignment::Unknown,
                                                        flags: 0u32,
                                                        precision:
                                                            ::std::fmt::rt::v1::Count::Implied,
                                                        width: ::std::fmt::rt::v1::Count::Implied,
                                                    },
                                                },
                                                ::std::fmt::rt::v1::Argument {
                                                    position: ::std::fmt::rt::v1::Position::At(
                                                        1usize,
                                                    ),
                                                    format: ::std::fmt::rt::v1::FormatSpec {
                                                        fill: ' ',
                                                        align:
                                                            ::std::fmt::rt::v1::Alignment::Unknown,
                                                        flags: 0u32,
                                                        precision:
                                                            ::std::fmt::rt::v1::Count::Implied,
                                                        width: ::std::fmt::rt::v1::Count::Implied,
                                                    },
                                                },
                                            ],
                                        ),
                                        &(
                                            "rsvg_internals/src/surface_utils/shared_surface.rs",
                                            93u32,
                                            9u32,
                                        ),
                                    )
                                }
                            }
                        }
                    }
                };
                self.surface
            }
            /// Returns the surface width.
            #[inline]
            pub fn width(&self) -> i32 {
                self.width
            }
            /// Returns the surface height.
            #[inline]
            pub fn height(&self) -> i32 {
                self.height
            }
            /// Retrieves the pixel value at the given coordinates.
            #[inline]
            pub fn get_pixel(&self, x: u32, y: u32) -> Pixel {
                if !(x < self.width as u32) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: x < self.width as u32",
                            &(
                                "rsvg_internals/src/surface_utils/shared_surface.rs",
                                113u32,
                                9u32,
                            ),
                        )
                    }
                };
                if !(y < self.height as u32) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: y < self.height as u32",
                            &(
                                "rsvg_internals/src/surface_utils/shared_surface.rs",
                                114u32,
                                9u32,
                            ),
                        )
                    }
                };
                let value = unsafe {
                    *(self
                        .data_ptr
                        .as_ptr()
                        .offset(y as isize * self.stride + x as isize * 4)
                        as *const u32)
                };
                Pixel {
                    r: ((value >> 16) & 255) as u8,
                    g: ((value >> 8) & 255) as u8,
                    b: (value & 255) as u8,
                    a: ((value >> 24) & 255) as u8,
                }
            }
            /// Calls `set_source_surface()` on the given Cairo context.
            #[inline]
            pub fn set_as_source_surface(&self, cr: &cairo::Context, x: f64, y: f64) {
                cr.set_source_surface(&self.surface, x, y);
            }
            /// Returns a new `ImageSurface` with the same contents as the one stored in this
            /// `SharedImageSurface` within the given bounds.
            pub fn copy_surface(&self, bounds: IRect) -> Result<ImageSurface, cairo::Status> {
                let output_surface =
                    ImageSurface::create(cairo::Format::ARgb32, self.width, self.height)?;
                let cr = cairo::Context::new(&output_surface);
                cr.rectangle(
                    bounds.x0 as f64,
                    bounds.y0 as f64,
                    (bounds.x1 - bounds.x0) as f64,
                    (bounds.y1 - bounds.y0) as f64,
                );
                cr.clip();
                cr.set_source_surface(&self.surface, 0f64, 0f64);
                cr.paint();
                Ok(output_surface)
            }
            /// Scales the given surface by `x` and `y` into a surface `width``height` in size, clipped by
            /// `bounds`.
            pub fn scale_to(
                &self,
                width: i32,
                height: i32,
                bounds: IRect,
                x: f64,
                y: f64,
            ) -> Result<SharedImageSurface, cairo::Status> {
                let output_surface = ImageSurface::create(cairo::Format::ARgb32, width, height)?;
                {
                    let cr = cairo::Context::new(&output_surface);
                    cr.rectangle(
                        bounds.x0 as f64,
                        bounds.y0 as f64,
                        (bounds.x1 - bounds.x0) as f64,
                        (bounds.y1 - bounds.y0) as f64,
                    );
                    cr.clip();
                    cr.scale(x, y);
                    self.set_as_source_surface(&cr, 0.0, 0.0);
                    cr.paint();
                }
                Ok(SharedImageSurface::new(output_surface)?)
            }
            /// Returns a scaled version of a surface and bounds.
            #[inline]
            pub fn scale(
                &self,
                bounds: IRect,
                x: f64,
                y: f64,
            ) -> Result<(SharedImageSurface, IRect), cairo::Status> {
                let new_width = (f64::from(self.width) * x).ceil() as i32;
                let new_height = (f64::from(self.height) * x).ceil() as i32;
                let new_bounds = bounds.scale(x, y);
                Ok((
                    self.scale_to(new_width, new_height, new_bounds, x, y)?,
                    new_bounds,
                ))
            }
            /// Returns a surface with black background and alpha channel matching this surface.
            pub fn extract_alpha(&self, bounds: IRect) -> Result<ImageSurface, cairo::Status> {
                let mut output_surface =
                    ImageSurface::create(cairo::Format::ARgb32, self.width, self.height)?;
                let output_stride = output_surface.get_stride() as usize;
                {
                    let mut output_data = output_surface.get_data().unwrap();
                    for (x, y, Pixel { a, .. }) in Pixels::new(self, bounds) {
                        let output_pixel = Pixel {
                            r: 0,
                            g: 0,
                            b: 0,
                            a,
                        };
                        output_data.set_pixel(output_stride, output_pixel, x, y);
                    }
                }
                Ok(output_surface)
            }
            /// Returns a surface with pre-multiplication of color values undone.
            ///
            /// HACK: this is storing unpremultiplied pixels in an ARGB32 image surface (which is supposed
            /// to be premultiplied pixels).
            pub fn unpremultiply(&self, bounds: IRect) -> Result<ImageSurface, cairo::Status> {
                let mut output_surface =
                    ImageSurface::create(cairo::Format::ARgb32, self.width, self.height)?;
                let stride = output_surface.get_stride() as usize;
                {
                    let mut data = output_surface.get_data().unwrap();
                    for (x, y, pixel) in Pixels::new(self, bounds) {
                        data.set_pixel(stride, pixel.unpremultiply(), x, y);
                    }
                }
                Ok(output_surface)
            }
            /// Performs a convolution.
            ///
            /// Note that `kernel` is rotated 180 degrees.
            ///
            /// The `target` parameter determines the position of the kernel relative to each pixel of the
            /// image. The value of `(0, 0)` indicates that the top left pixel of the (180-degrees-rotated)
            /// kernel corresponds to the current pixel, and the rest of the kernel is to the right and
            /// bottom of the pixel. The value of `(cols / 2, rows / 2)` centers a kernel with an odd
            /// number of rows and columns.
            ///
            /// # Panics
            /// Panics if `kernel` has zero rows or columns.
            pub fn convolve(
                &self,
                bounds: IRect,
                target: (i32, i32),
                kernel: &Matrix<f64>,
                edge_mode: EdgeMode,
            ) -> Result<ImageSurface, cairo::Status> {
                if !(kernel.rows() >= 1) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: kernel.rows() >= 1",
                            &(
                                "rsvg_internals/src/surface_utils/shared_surface.rs",
                                267u32,
                                9u32,
                            ),
                        )
                    }
                };
                if !(kernel.cols() >= 1) {
                    {
                        ::rt::begin_panic(
                            "assertion failed: kernel.cols() >= 1",
                            &(
                                "rsvg_internals/src/surface_utils/shared_surface.rs",
                                268u32,
                                9u32,
                            ),
                        )
                    }
                };
                let mut output_surface =
                    ImageSurface::create(cairo::Format::ARgb32, self.width, self.height)?;
                let output_stride = output_surface.get_stride() as usize;
                {
                    let mut output_data = output_surface.get_data().unwrap();
                    for (x, y, _pixel) in Pixels::new(self, bounds) {
                        let kernel_bounds = IRect {
                            x0: x as i32 - target.0,
                            y0: y as i32 - target.1,
                            x1: x as i32 - target.0 + kernel.cols() as i32,
                            y1: y as i32 - target.1 + kernel.rows() as i32,
                        };
                        let mut r = 0.0;
                        let mut g = 0.0;
                        let mut b = 0.0;
                        let mut a = 0.0;
                        for (x, y, pixel) in
                            PixelRectangle::new(self, bounds, kernel_bounds, edge_mode)
                        {
                            let kernel_x = (kernel_bounds.x1 - x - 1) as usize;
                            let kernel_y = (kernel_bounds.y1 - y - 1) as usize;
                            let factor = kernel[[kernel_y, kernel_x]];
                            r += f64::from(pixel.r) * factor;
                            g += f64::from(pixel.g) * factor;
                            b += f64::from(pixel.b) * factor;
                            a += f64::from(pixel.a) * factor;
                        }
                        let convert = |x: f64| clamp(x, 0.0, 255.0).round() as u8;
                        let output_pixel = Pixel {
                            r: convert(r),
                            g: convert(g),
                            b: convert(b),
                            a: convert(a),
                        };
                        output_data.set_pixel(output_stride, output_pixel, x, y);
                    }
                }
                Ok(output_surface)
            }
            /// Returns a raw pointer to the underlying surface.
            ///
            /// # Safety
            /// The returned pointer must not be used to modify the surface.
            #[inline]
            pub unsafe fn to_glib_none(
                &self,
            ) -> Stash<*mut cairo_sys::cairo_surface_t, ImageSurface> {
                self.surface.to_glib_none()
            }
        }
    }
    /// A pixel consisting of R, G, B and A values.
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub struct Pixel {
        pub r: u8,
        pub g: u8,
        pub b: u8,
        pub a: u8,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for Pixel {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                Pixel {
                    r: ref __self_0_0,
                    g: ref __self_0_1,
                    b: ref __self_0_2,
                    a: ref __self_0_3,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Pixel");
                    let _ = debug_trait_builder.field("r", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("g", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("b", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("a", &&(*__self_0_3));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for Pixel {
        #[inline]
        fn clone(&self) -> Pixel {
            {
                let _: ::std::clone::AssertParamIsClone<u8>;
                let _: ::std::clone::AssertParamIsClone<u8>;
                let _: ::std::clone::AssertParamIsClone<u8>;
                let _: ::std::clone::AssertParamIsClone<u8>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for Pixel {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for Pixel {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::std::cmp::AssertParamIsEq<u8>;
                let _: ::std::cmp::AssertParamIsEq<u8>;
                let _: ::std::cmp::AssertParamIsEq<u8>;
                let _: ::std::cmp::AssertParamIsEq<u8>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for Pixel {
        #[inline]
        fn eq(&self, other: &Pixel) -> bool {
            match *other {
                Pixel {
                    r: ref __self_1_0,
                    g: ref __self_1_1,
                    b: ref __self_1_2,
                    a: ref __self_1_3,
                } => match *self {
                    Pixel {
                        r: ref __self_0_0,
                        g: ref __self_0_1,
                        b: ref __self_0_2,
                        a: ref __self_0_3,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                            && (*__self_0_3) == (*__self_1_3)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Pixel) -> bool {
            match *other {
                Pixel {
                    r: ref __self_1_0,
                    g: ref __self_1_1,
                    b: ref __self_1_2,
                    a: ref __self_1_3,
                } => match *self {
                    Pixel {
                        r: ref __self_0_0,
                        g: ref __self_0_1,
                        b: ref __self_0_2,
                        a: ref __self_0_3,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                            || (*__self_0_3) != (*__self_1_3)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::hash::Hash for Pixel {
        fn hash<__H: ::std::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                Pixel {
                    r: ref __self_0_0,
                    g: ref __self_0_1,
                    b: ref __self_0_2,
                    a: ref __self_0_3,
                } => {
                    ::std::hash::Hash::hash(&(*__self_0_0), state);
                    ::std::hash::Hash::hash(&(*__self_0_1), state);
                    ::std::hash::Hash::hash(&(*__self_0_2), state);
                    ::std::hash::Hash::hash(&(*__self_0_3), state)
                }
            }
        }
    }
    /// Modes which specify how the values of out of bounds pixels are computed.
    #[structural_match]
    #[rustc_copy_clone_marker]
    pub enum EdgeMode {
        /// The nearest inbounds pixel value is returned.
        Duplicate,

        /// The image is extended by taking the color values from the opposite of the image.
        ///
        /// Imagine the image being tiled infinitely, with the original image at the origin.
        Wrap,

        /// Zero RGBA values are returned.
        None,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for EdgeMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&EdgeMode::Duplicate,) => {
                    let mut debug_trait_builder = f.debug_tuple("Duplicate");
                    debug_trait_builder.finish()
                }
                (&EdgeMode::Wrap,) => {
                    let mut debug_trait_builder = f.debug_tuple("Wrap");
                    debug_trait_builder.finish()
                }
                (&EdgeMode::None,) => {
                    let mut debug_trait_builder = f.debug_tuple("None");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for EdgeMode {
        #[inline]
        fn clone(&self) -> EdgeMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for EdgeMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::Eq for EdgeMode {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for EdgeMode {
        #[inline]
        fn eq(&self, other: &EdgeMode) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    /// Extension methods for `cairo::ImageSurfaceData`.
    pub trait ImageSurfaceDataExt: DerefMut<Target = [u8]> {
        /// Sets the pixel at the given coordinates.
        #[inline]
        fn set_pixel(&mut self, stride: usize, pixel: Pixel, x: u32, y: u32) {
            let value = ((pixel.a as u32) << 24)
                | ((pixel.r as u32) << 16)
                | ((pixel.g as u32) << 8)
                | (pixel.b as u32);
            unsafe {
                *(&mut self[y as usize * stride + x as usize * 4] as *mut u8 as *mut u32) = value;
            }
        }
    }
    impl Pixel {
        /// Returns an unpremultiplied value of this pixel.
        #[inline]
        pub fn unpremultiply(self) -> Self {
            if self.a == 0 {
                self
            } else {
                let alpha = f64::from(self.a) / 255.0;
                let unpremultiply = |x| (f64::from(x) / alpha).round() as u8;
                Self {
                    r: unpremultiply(self.r),
                    g: unpremultiply(self.g),
                    b: unpremultiply(self.b),
                    a: self.a,
                }
            }
        }
        /// Returns a premultiplied value of this pixel.
        #[inline]
        pub fn premultiply(self) -> Self {
            let alpha = f64::from(self.a) / 255.0;
            let premultiply = |x| (f64::from(x) * alpha).round() as u8;
            Self {
                r: premultiply(self.r),
                g: premultiply(self.g),
                b: premultiply(self.b),
                a: self.a,
            }
        }
    }
    impl<'a> ImageSurfaceDataExt for cairo::ImageSurfaceData<'a> {}
}
mod text {
    use attributes::Attribute;
    use drawing_ctx::DrawingCtx;
    use handle::RsvgHandle;
    use length::*;
    use libc;
    use node::{boxed_node_new, CascadedValues, NodeResult, NodeTrait, NodeType, RsvgNode};
    use pango::{self, ContextExt, LayoutExt};
    use parsers::parse;
    use property_bag::PropertyBag;
    use space::xml_space_normalize;
    use state::{
        ComputedValues, Direction, FontStretch, FontStyle, FontVariant, FontWeight, TextAnchor,
        UnicodeBidi, WritingMode,
    };
    use std;
    use std::cell::{Cell, RefCell};
    use std::str;
    /// In SVG text elements, we use `NodeChars` to store character data.  For example,
    /// an element like `<text>Foo Bar</text>` will be a `NodeText` with a single child,
    /// and the child will be a `NodeChars` with "Foo Bar" for its contents.
    ///
    /// Text elements can contain `<tspan>` sub-elements.  In this case,
    /// those `tspan` nodes will also contain `NodeChars` children.
    ///
    /// A text or tspan element can contain more than one `NodeChars` child, for example,
    /// if there is an XML comment that splits the character contents in two:
    ///
    /// ```xml
    /// <text>
    ///   This sentence will create a NodeChars.
    ///   <!-- this comment is ignored -->
    ///   This sentence will cretea another NodeChars.
    /// </text>
    /// ```
    ///
    /// When rendering a text element, it will take care of concatenating the strings
    /// in its `NodeChars` children as appropriate, depending on the
    /// `xml:space="preserve"` attribute.  A `NodeChars` stores the characters verbatim
    /// as they come out of the XML parser, after ensuring that they are valid UTF-8.
    pub struct NodeChars {
        string: RefCell<String>,
    }
    impl NodeChars {
        fn new() -> NodeChars {
            NodeChars {
                string: RefCell::new(String::new()),
            }
        }
        fn append(&self, s: &str) {
            self.string.borrow_mut().push_str(s);
        }
        fn measure(
            &self,
            _node: &RsvgNode,
            values: &ComputedValues,
            draw_ctx: &DrawingCtx,
            length: &mut f64,
        ) {
            let s = self.string.borrow();
            let layout = create_pango_layout(draw_ctx, values, &s);
            let (width, _) = layout.get_size();
            *length = f64::from(width) / f64::from(pango::SCALE);
        }
        fn render(
            &self,
            _node: &RsvgNode,
            values: &ComputedValues,
            draw_ctx: &mut DrawingCtx,
            x: &mut f64,
            y: &mut f64,
            clipping: bool,
        ) {
            let s = self.string.borrow();
            let layout = create_pango_layout(draw_ctx, values, &s);
            let (width, _) = layout.get_size();
            let baseline = f64::from(layout.get_baseline()) / f64::from(pango::SCALE);
            let offset = baseline + values.baseline_shift.0.normalize(values, draw_ctx);
            if values.text_gravity_is_vertical() {
                draw_ctx.draw_pango_layout(&layout, values, *x + offset, *y, clipping);
                *y += f64::from(width) / f64::from(pango::SCALE);
            } else {
                draw_ctx.draw_pango_layout(&layout, values, *x, *y - offset, clipping);
                *x += f64::from(width) / f64::from(pango::SCALE);
            }
        }
    }
    impl NodeTrait for NodeChars {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, _: &PropertyBag) -> NodeResult {
            Ok(())
        }
    }
    pub struct NodeText {
        x: Cell<RsvgLength>,
        y: Cell<RsvgLength>,
        dx: Cell<RsvgLength>,
        dy: Cell<RsvgLength>,
    }
    impl NodeText {
        pub fn new() -> NodeText {
            NodeText {
                x: Cell::new(RsvgLength::default()),
                y: Cell::new(RsvgLength::default()),
                dx: Cell::new(RsvgLength::default()),
                dy: Cell::new(RsvgLength::default()),
            }
        }
    }
    impl NodeTrait for NodeText {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::X => self.x.set(parse("x", value, LengthDir::Horizontal)?),
                    Attribute::Y => self.y.set(parse("y", value, LengthDir::Vertical)?),
                    Attribute::Dx => self.dx.set(parse("dx", value, LengthDir::Horizontal)?),
                    Attribute::Dy => self.dy.set(parse("dy", value, LengthDir::Vertical)?),
                    _ => (),
                }
            }
            Ok(())
        }
        fn draw(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let mut x = self.x.get().normalize(values, draw_ctx);
            let mut y = self.y.get().normalize(values, draw_ctx);
            let mut dx = self.dx.get().normalize(values, draw_ctx);
            let mut dy = self.dy.get().normalize(values, draw_ctx);
            let anchor = values.text_anchor;
            let offset = anchor_offset(node, cascaded, draw_ctx, anchor, false);
            if values.text_gravity_is_vertical() {
                y -= offset;
                dy = match anchor {
                    TextAnchor::Start => dy,
                    TextAnchor::Middle => dy / 2f64,
                    _ => 0f64,
                }
            } else {
                x -= offset;
                dx = match anchor {
                    TextAnchor::Start => dx,
                    TextAnchor::Middle => dx / 2f64,
                    _ => 0f64,
                }
            }
            x += dx;
            y += dy;
            render_children(node, cascaded, draw_ctx, &mut x, &mut y, false, clipping);
        }
    }
    pub struct NodeTRef {
        link: RefCell<Option<String>>,
    }
    impl NodeTRef {
        pub fn new() -> NodeTRef {
            NodeTRef {
                link: RefCell::new(Default::default()),
            }
        }
        fn measure(
            &self,
            _node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            length: &mut f64,
        ) -> bool {
            let l = self.link.borrow();
            if l.is_none() {
                return false;
            }
            let done = if let Some(acquired) = draw_ctx.get_acquired_node(l.as_ref().unwrap()) {
                let c = acquired.get();
                measure_children(&c, cascaded, draw_ctx, length, true)
            } else {
                false
            };
            done
        }
        fn render(
            &self,
            _node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            x: &mut f64,
            y: &mut f64,
            clipping: bool,
        ) {
            let l = self.link.borrow();
            if l.is_none() {
                return;
            }
            if let Some(acquired) = draw_ctx.get_acquired_node(l.as_ref().unwrap()) {
                let c = acquired.get();
                render_children(&c, cascaded, draw_ctx, x, y, true, clipping)
            }
        }
    }
    impl NodeTrait for NodeTRef {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::XlinkHref => *self.link.borrow_mut() = Some(value.to_owned()),
                    _ => (),
                }
            }
            Ok(())
        }
    }
    pub struct NodeTSpan {
        x: Cell<Option<RsvgLength>>,
        y: Cell<Option<RsvgLength>>,
        dx: Cell<RsvgLength>,
        dy: Cell<RsvgLength>,
    }
    impl NodeTSpan {
        pub fn new() -> NodeTSpan {
            NodeTSpan {
                x: Cell::new(Default::default()),
                y: Cell::new(Default::default()),
                dx: Cell::new(RsvgLength::default()),
                dy: Cell::new(RsvgLength::default()),
            }
        }
        fn measure(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            length: &mut f64,
            usetextonly: bool,
        ) -> bool {
            let values = cascaded.get();
            if self.x.get().is_some() || self.y.get().is_some() {
                return true;
            }
            if values.text_gravity_is_vertical() {
                *length += self.dy.get().normalize(values, draw_ctx);
            } else {
                *length += self.dx.get().normalize(values, draw_ctx);
            }
            measure_children(node, cascaded, draw_ctx, length, usetextonly)
        }
        fn render(
            &self,
            node: &RsvgNode,
            cascaded: &CascadedValues,
            draw_ctx: &mut DrawingCtx,
            x: &mut f64,
            y: &mut f64,
            usetextonly: bool,
            clipping: bool,
        ) {
            let values = cascaded.get();
            let mut dx = self.dx.get().normalize(values, draw_ctx);
            let mut dy = self.dy.get().normalize(values, draw_ctx);
            let vertical = values.text_gravity_is_vertical();
            let anchor = values.text_anchor;
            let offset = anchor_offset(node, cascaded, draw_ctx, anchor, usetextonly);
            if let Some(self_x) = self.x.get() {
                *x = self_x.normalize(values, draw_ctx);
                if !vertical {
                    *x -= offset;
                    dx = match anchor {
                        TextAnchor::Start => dx,
                        TextAnchor::Middle => dx / 2f64,
                        _ => 0f64,
                    }
                }
            }
            *x += dx;
            if let Some(self_y) = self.y.get() {
                *y = self_y.normalize(values, draw_ctx);
                if vertical {
                    *y -= offset;
                    dy = match anchor {
                        TextAnchor::Start => dy,
                        TextAnchor::Middle => dy / 2f64,
                        _ => 0f64,
                    }
                }
            }
            *y += dy;
            render_children(node, cascaded, draw_ctx, x, y, usetextonly, clipping);
        }
    }
    impl NodeTrait for NodeTSpan {
        fn set_atts(&self, _: &RsvgNode, _: *const RsvgHandle, pbag: &PropertyBag) -> NodeResult {
            for (_key, attr, value) in pbag.iter() {
                match attr {
                    Attribute::X => self
                        .x
                        .set(parse("x", value, LengthDir::Horizontal).map(Some)?),
                    Attribute::Y => self
                        .y
                        .set(parse("y", value, LengthDir::Vertical).map(Some)?),
                    Attribute::Dx => self.dx.set(parse("dx", value, LengthDir::Horizontal)?),
                    Attribute::Dy => self.dy.set(parse("dy", value, LengthDir::Vertical)?),
                    _ => (),
                }
            }
            Ok(())
        }
    }
    fn to_pango_units(v: f64) -> i32 {
        (v * f64::from(pango::SCALE)) as i32
    }
    impl From<FontStyle> for pango::Style {
        fn from(s: FontStyle) -> pango::Style {
            match s {
                FontStyle::Normal => pango::Style::Normal,
                FontStyle::Italic => pango::Style::Italic,
                FontStyle::Oblique => pango::Style::Oblique,
            }
        }
    }
    impl From<FontVariant> for pango::Variant {
        fn from(v: FontVariant) -> pango::Variant {
            match v {
                FontVariant::Normal => pango::Variant::Normal,
                FontVariant::SmallCaps => pango::Variant::SmallCaps,
            }
        }
    }
    impl From<FontStretch> for pango::Stretch {
        fn from(s: FontStretch) -> pango::Stretch {
            match s {
                FontStretch::Normal => pango::Stretch::Normal,
                FontStretch::Wider => pango::Stretch::Expanded,
                FontStretch::Narrower => pango::Stretch::Condensed,
                FontStretch::UltraCondensed => pango::Stretch::UltraCondensed,
                FontStretch::ExtraCondensed => pango::Stretch::ExtraCondensed,
                FontStretch::Condensed => pango::Stretch::Condensed,
                FontStretch::SemiCondensed => pango::Stretch::SemiCondensed,
                FontStretch::SemiExpanded => pango::Stretch::SemiExpanded,
                FontStretch::Expanded => pango::Stretch::Expanded,
                FontStretch::ExtraExpanded => pango::Stretch::ExtraExpanded,
                FontStretch::UltraExpanded => pango::Stretch::UltraExpanded,
            }
        }
    }
    impl From<FontWeight> for pango::Weight {
        fn from(w: FontWeight) -> pango::Weight {
            match w {
                FontWeight::Normal => pango::Weight::Normal,
                FontWeight::Bold => pango::Weight::Bold,
                FontWeight::Bolder => pango::Weight::Ultrabold,
                FontWeight::Lighter => pango::Weight::Light,
                FontWeight::W100 => pango::Weight::Thin,
                FontWeight::W200 => pango::Weight::Ultralight,
                FontWeight::W300 => pango::Weight::Semilight,
                FontWeight::W400 => pango::Weight::Normal,
                FontWeight::W500 => pango::Weight::Medium,
                FontWeight::W600 => pango::Weight::Semibold,
                FontWeight::W700 => pango::Weight::Bold,
                FontWeight::W800 => pango::Weight::Ultrabold,
                FontWeight::W900 => pango::Weight::Heavy,
            }
        }
    }
    impl From<Direction> for pango::Direction {
        fn from(d: Direction) -> pango::Direction {
            match d {
                Direction::Ltr => pango::Direction::Ltr,
                Direction::Rtl => pango::Direction::Rtl,
            }
        }
    }
    impl From<Direction> for pango::Alignment {
        fn from(d: Direction) -> pango::Alignment {
            match d {
                Direction::Ltr => pango::Alignment::Left,
                Direction::Rtl => pango::Alignment::Right,
            }
        }
    }
    impl From<WritingMode> for pango::Direction {
        fn from(m: WritingMode) -> pango::Direction {
            match m {
                WritingMode::LrTb | WritingMode::Lr | WritingMode::Tb | WritingMode::TbRl => {
                    pango::Direction::Ltr
                }
                WritingMode::RlTb | WritingMode::Rl => pango::Direction::Rtl,
            }
        }
    }
    impl From<WritingMode> for pango::Gravity {
        fn from(m: WritingMode) -> pango::Gravity {
            match m {
                WritingMode::Tb | WritingMode::TbRl => pango::Gravity::East,
                WritingMode::LrTb | WritingMode::Lr | WritingMode::RlTb | WritingMode::Rl => {
                    pango::Gravity::South
                }
            }
        }
    }
    fn create_pango_layout(
        draw_ctx: &DrawingCtx,
        values: &ComputedValues,
        text: &str,
    ) -> pango::Layout {
        let pango_context = draw_ctx.get_pango_context();
        if !values.xml_lang.0.is_empty() {
            let pango_lang = pango::Language::from_string(&values.xml_lang.0);
            pango_context.set_language(&pango_lang);
        }
        pango_context.set_base_gravity(pango::Gravity::from(values.writing_mode));
        match (values.unicode_bidi, values.direction) {
            (UnicodeBidi::Override, _) | (UnicodeBidi::Embed, _) => {
                pango_context.set_base_dir(pango::Direction::from(values.direction));
            }
            (_, direction) if direction != Direction::Ltr => {
                pango_context.set_base_dir(pango::Direction::from(direction));
            }
            (_, _) => {
                pango_context.set_base_dir(pango::Direction::from(values.writing_mode));
            }
        }
        let mut font_desc = pango_context.get_font_description().unwrap();
        font_desc.set_family(&values.font_family.0);
        font_desc.set_style(pango::Style::from(values.font_style));
        font_desc.set_variant(pango::Variant::from(values.font_variant));
        font_desc.set_weight(pango::Weight::from(values.font_weight));
        font_desc.set_stretch(pango::Stretch::from(values.font_stretch));
        font_desc.set_size(to_pango_units(
            values.font_size.0.normalize(values, draw_ctx),
        ));
        let layout = pango::Layout::new(&pango_context);
        layout.set_font_description(&font_desc);
        let attr_list = pango::AttrList::new();
        attr_list.insert(
            pango::Attribute::new_letter_spacing(to_pango_units(
                values.letter_spacing.0.normalize(values, draw_ctx),
            )).unwrap(),
        );
        if values.text_decoration.underline {
            attr_list.insert(pango::Attribute::new_underline(pango::Underline::Single).unwrap());
        }
        if values.text_decoration.strike {
            attr_list.insert(pango::Attribute::new_strikethrough(true).unwrap());
        }
        layout.set_attributes(&attr_list);
        layout.set_alignment(pango::Alignment::from(values.direction));
        let t = xml_space_normalize(values.xml_space, text);
        layout.set_text(&t);
        layout
    }
    fn anchor_offset(
        node: &RsvgNode,
        cascaded: &CascadedValues,
        draw_ctx: &mut DrawingCtx,
        anchor: TextAnchor,
        textonly: bool,
    ) -> f64 {
        let mut offset = 0f64;
        match anchor {
            TextAnchor::Start => {}
            TextAnchor::Middle => {
                measure_children(node, cascaded, draw_ctx, &mut offset, textonly);
                offset /= 2f64;
            }
            _ => {
                measure_children(node, cascaded, draw_ctx, &mut offset, textonly);
            }
        }
        offset
    }
    fn measure_children(
        node: &RsvgNode,
        cascaded: &CascadedValues,
        draw_ctx: &mut DrawingCtx,
        length: &mut f64,
        textonly: bool,
    ) -> bool {
        let mut done = false;
        for child in node.children() {
            done = measure_child(
                &child,
                &CascadedValues::new(cascaded, &child),
                draw_ctx,
                length,
                textonly,
            );
            if done {
                break;
            }
        }
        done
    }
    fn measure_child(
        node: &RsvgNode,
        cascaded: &CascadedValues,
        draw_ctx: &mut DrawingCtx,
        length: &mut f64,
        textonly: bool,
    ) -> bool {
        let values = cascaded.get();
        let mut done = false;
        let cr = draw_ctx.get_cairo_context();
        cr.save();
        cr.transform(node.get_transform());
        match (node.get_type(), textonly) {
            (NodeType::Chars, _) => {
                node.with_impl(|chars: &NodeChars| chars.measure(node, values, draw_ctx, length));
            }
            (_, true) => {
                done = measure_children(
                    node,
                    &CascadedValues::new(cascaded, node),
                    draw_ctx,
                    length,
                    textonly,
                );
            }
            (NodeType::TSpan, _) => {
                node.with_impl(|tspan: &NodeTSpan| {
                    done = tspan.measure(
                        node,
                        &CascadedValues::new(cascaded, node),
                        draw_ctx,
                        length,
                        textonly,
                    );
                });
            }
            (NodeType::TRef, _) => {
                node.with_impl(|tref: &NodeTRef| {
                    done =
                        tref.measure(node, &CascadedValues::new(cascaded, node), draw_ctx, length);
                });
            }
            (_, _) => {}
        }
        cr.restore();
        done
    }
    fn render_children(
        node: &RsvgNode,
        cascaded: &CascadedValues,
        draw_ctx: &mut DrawingCtx,
        x: &mut f64,
        y: &mut f64,
        textonly: bool,
        clipping: bool,
    ) {
        let values = cascaded.get();
        draw_ctx.with_discrete_layer(
            node,
            values,
            clipping,
            &mut (|dc| {
                for child in node.children() {
                    render_child(&child, cascaded, dc, x, y, textonly, clipping);
                }
            }),
        );
    }
    fn render_child(
        node: &RsvgNode,
        cascaded: &CascadedValues,
        draw_ctx: &mut DrawingCtx,
        x: &mut f64,
        y: &mut f64,
        textonly: bool,
        clipping: bool,
    ) {
        let values = cascaded.get();
        let cr = draw_ctx.get_cairo_context();
        cr.save();
        cr.transform(node.get_transform());
        match (node.get_type(), textonly) {
            (NodeType::Chars, _) => {
                node.with_impl(|chars: &NodeChars| {
                    chars.render(node, values, draw_ctx, x, y, clipping)
                });
            }
            (_, true) => {
                render_children(
                    node,
                    &CascadedValues::new(cascaded, node),
                    draw_ctx,
                    x,
                    y,
                    textonly,
                    clipping,
                );
            }
            (NodeType::TSpan, _) => {
                node.with_impl(|tspan: &NodeTSpan| {
                    tspan.render(
                        node,
                        &CascadedValues::new(cascaded, node),
                        draw_ctx,
                        x,
                        y,
                        textonly,
                        clipping,
                    );
                });
            }
            (NodeType::TRef, _) => {
                node.with_impl(|tref: &NodeTRef| {
                    tref.render(
                        node,
                        &CascadedValues::new(cascaded, node),
                        draw_ctx,
                        x,
                        y,
                        clipping,
                    );
                });
            }
            (_, _) => {}
        }
        cr.restore();
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_chars_new(raw_parent: *const RsvgNode) -> *const RsvgNode {
        boxed_node_new(
            NodeType::Chars,
            raw_parent,
            None,
            None,
            Box::new(NodeChars::new()),
        )
    }
    #[no_mangle]
    pub extern "C" fn rsvg_node_chars_append(
        raw_node: *const RsvgNode,
        text: *const libc::c_char,
        len: isize,
    ) {
        if !!raw_node.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !raw_node.is_null()",
                    &("rsvg_internals/src/text.rs", 749u32, 5u32),
                )
            }
        };
        let node: &RsvgNode = unsafe { &*raw_node };
        if !!text.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !text.is_null()",
                    &("rsvg_internals/src/text.rs", 752u32, 5u32),
                )
            }
        };
        if !(len >= 0) {
            {
                ::rt::begin_panic(
                    "assertion failed: len >= 0",
                    &("rsvg_internals/src/text.rs", 753u32, 5u32),
                )
            }
        };
        let bytes = unsafe { std::slice::from_raw_parts(text as *const u8, len as usize) };
        let utf8 = unsafe { str::from_utf8_unchecked(bytes) };
        node.with_impl(|chars: &NodeChars| {
            chars.append(utf8);
        });
    }
}
mod transform {
    use cairo;
    use cairo::MatrixTrait;
    use cssparser::{ParseError as CssParseError, Parser, Token};
    use error::*;
    use parsers::{optional_comma, Parse, ParseError};
    use std::f64::consts::*;
    impl Parse for cairo::Matrix {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<cairo::Matrix, AttributeError> {
            let matrix = parse_transform_list(parser)?;
            matrix
                .try_invert()
                .map(|_| matrix)
                .map_err(|_| AttributeError::Value("invalid transformation matrix".to_string()))
        }
    }
    fn parse_transform_list(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        let mut matrix = cairo::Matrix::identity();
        loop {
            if parser.is_exhausted() {
                break;
            }
            let m = parse_transform_command(parser)?;
            matrix = cairo::Matrix::multiply(&m, &matrix);
            optional_comma(parser);
        }
        Ok(matrix)
    }
    fn make_expected_function_error() -> AttributeError {
        AttributeError::from(ParseError::new(
            "expected matrix|translate|scale|rotate|skewX|skewY",
        ))
    }
    fn parse_transform_command(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        match parser.next()?.clone() {
            Token::Function(ref name) => parse_transform_function(name, parser),
            Token::Ident(ref name) => {
                parser.expect_parenthesis_block()?;
                parse_transform_function(name, parser)
            }
            _ => Err(make_expected_function_error()),
        }
    }
    fn parse_transform_function(
        name: &str,
        parser: &mut Parser,
    ) -> Result<cairo::Matrix, AttributeError> {
        match name {
            "matrix" => parse_matrix_args(parser),
            "translate" => parse_translate_args(parser),
            "scale" => parse_scale_args(parser),
            "rotate" => parse_rotate_args(parser),
            "skewX" => parse_skewx_args(parser),
            "skewY" => parse_skewy_args(parser),
            _ => Err(make_expected_function_error()),
        }
    }
    fn parse_matrix_args(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        parser
            .parse_nested_block(|p| {
                let xx = f64::from(p.expect_number()?);
                optional_comma(p);
                let yx = f64::from(p.expect_number()?);
                optional_comma(p);
                let xy = f64::from(p.expect_number()?);
                optional_comma(p);
                let yy = f64::from(p.expect_number()?);
                optional_comma(p);
                let x0 = f64::from(p.expect_number()?);
                optional_comma(p);
                let y0 = f64::from(p.expect_number()?);
                Ok(cairo::Matrix::new(xx, yx, xy, yy, x0, y0))
            })
            .map_err(CssParseError::<()>::basic)
            .map_err(AttributeError::from)
    }
    fn parse_translate_args(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        parser
            .parse_nested_block(|p| {
                let tx = f64::from(p.expect_number()?);
                let ty = f64::from(
                    p.try(|p| -> Result<f32, CssParseError<()>> {
                        optional_comma(p);
                        Ok(p.expect_number()?)
                    }).unwrap_or(0.0),
                );
                Ok(cairo::Matrix::new(1.0, 0.0, 0.0, 1.0, tx, ty))
            })
            .map_err(CssParseError::<()>::basic)
            .map_err(AttributeError::from)
    }
    fn parse_scale_args(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        parser
            .parse_nested_block(|p| {
                let x = f64::from(p.expect_number()?);
                let y =
                    p.try(|p| -> Result<f32, CssParseError<()>> {
                        optional_comma(p);
                        Ok(p.expect_number()?)
                    }).map(f64::from)
                        .unwrap_or(x);
                Ok(cairo::Matrix::new(x, 0.0, 0.0, y, 0.0, 0.0))
            })
            .map_err(CssParseError::<()>::basic)
            .map_err(AttributeError::from)
    }
    fn parse_rotate_args(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        parser
            .parse_nested_block(|p| {
                let angle = f64::from(p.expect_number()?) * PI / 180.0;
                let (s, c) = angle.sin_cos();
                let (tx, ty) =
                    p.try(|p| -> Result<_, CssParseError<()>> {
                        optional_comma(p);
                        let tx = f64::from(p.expect_number()?);
                        optional_comma(p);
                        let ty = f64::from(p.expect_number()?);
                        Ok((tx, ty))
                    }).unwrap_or((0.0, 0.0));
                let mut m = cairo::Matrix::new(1.0, 0.0, 0.0, 1.0, tx, ty);
                m = cairo::Matrix::multiply(&cairo::Matrix::new(c, s, -s, c, 0.0, 0.0), &m);
                m = cairo::Matrix::multiply(&cairo::Matrix::new(1.0, 0.0, 0.0, 1.0, -tx, -ty), &m);
                Ok(m)
            })
            .map_err(CssParseError::<()>::basic)
            .map_err(AttributeError::from)
    }
    fn parse_skewx_args(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        parser
            .parse_nested_block(|p| {
                let a = f64::from(p.expect_number()?) * PI / 180.0;
                Ok(cairo::Matrix::new(1.0, 0.0, a.tan(), 1.0, 0.0, 0.0))
            })
            .map_err(CssParseError::<()>::basic)
            .map_err(AttributeError::from)
    }
    fn parse_skewy_args(parser: &mut Parser) -> Result<cairo::Matrix, AttributeError> {
        parser
            .parse_nested_block(|p| {
                let a = f64::from(p.expect_number()?) * PI / 180.0;
                Ok(cairo::Matrix::new(1.0, a.tan(), 0.0, 1.0, 0.0, 0.0))
            })
            .map_err(CssParseError::<()>::basic)
            .map_err(AttributeError::from)
    }
}
mod unitinterval {
    use cssparser::Parser;
    use error::*;
    use parsers::{Parse, ParseError};
    #[rustc_copy_clone_marker]
    pub struct UnitInterval(pub f64);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for UnitInterval {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                UnitInterval(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("UnitInterval");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for UnitInterval {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for UnitInterval {
        #[inline]
        fn clone(&self) -> UnitInterval {
            {
                let _: ::std::clone::AssertParamIsClone<f64>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for UnitInterval {
        #[inline]
        fn eq(&self, other: &UnitInterval) -> bool {
            match *other {
                UnitInterval(ref __self_1_0) => match *self {
                    UnitInterval(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &UnitInterval) -> bool {
            match *other {
                UnitInterval(ref __self_1_0) => match *self {
                    UnitInterval(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl Default for UnitInterval {
        fn default() -> UnitInterval {
            UnitInterval(1.0)
        }
    }
    impl Parse for UnitInterval {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<UnitInterval, AttributeError> {
            let x = f64::from(
                parser
                    .expect_number()
                    .map_err(|_| AttributeError::Parse(ParseError::new("expected number")))?,
            );
            let cx = if x < 0.0 {
                0.0
            } else if x > 1.0 {
                1.0
            } else {
                x
            };
            Ok(UnitInterval(cx))
        }
    }
    impl From<UnitInterval> for u8 {
        fn from(val: UnitInterval) -> u8 {
            let UnitInterval(x) = val;
            (x * 255.0 + 0.5).floor() as u8
        }
    }
}
mod util {
    use libc;
    use std::ffi::CStr;
    use std::str;
    pub fn clone_fallback_name(fallback: &Option<String>) -> Option<String> {
        if let Some(ref fallback_name) = *fallback {
            Some(fallback_name.clone())
        } else {
            None
        }
    }
    /// Converts a `char *` which is known to be valid UTF-8 into a `&str`
    ///
    /// The usual `from_glib_none(s)` allocates an owned String.  The
    /// purpose of `utf8_cstr()` is to get a temporary string slice into a
    /// C string which is already known to be valid UTF-8; for example,
    /// as for strings which come from `libxml2`.
    pub unsafe fn utf8_cstr<'a>(s: *const libc::c_char) -> &'a str {
        if !!s.is_null() {
            {
                ::rt::begin_panic(
                    "assertion failed: !s.is_null()",
                    &("rsvg_internals/src/util.rs", 24u32, 5u32),
                )
            }
        };
        str::from_utf8_unchecked(CStr::from_ptr(s).to_bytes())
    }
    pub unsafe fn utf8_cstr_opt<'a>(s: *const libc::c_char) -> Option<&'a str> {
        if s.is_null() {
            None
        } else {
            Some(utf8_cstr(s))
        }
    }
    pub fn clamp<T: PartialOrd>(val: T, low: T, high: T) -> T {
        if val < low {
            low
        } else if val > high {
            high
        } else {
            val
        }
    }
}
mod viewbox {
    use cairo;
    use cssparser::Parser;
    use error::*;
    use parsers;
    use parsers::Parse;
    use parsers::{ListLength, ParseError};
    #[rustc_copy_clone_marker]
    pub struct ViewBox(pub cairo::Rectangle);
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ViewBox {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                ViewBox(ref __self_0_0) => {
                    let mut debug_trait_builder = f.debug_tuple("ViewBox");
                    let _ = debug_trait_builder.field(&&(*__self_0_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ViewBox {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ViewBox {
        #[inline]
        fn clone(&self) -> ViewBox {
            {
                let _: ::std::clone::AssertParamIsClone<cairo::Rectangle>;
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ViewBox {
        #[inline]
        fn eq(&self, other: &ViewBox) -> bool {
            match *other {
                ViewBox(ref __self_1_0) => match *self {
                    ViewBox(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ViewBox) -> bool {
            match *other {
                ViewBox(ref __self_1_0) => match *self {
                    ViewBox(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    impl ViewBox {
        pub fn new(x: f64, y: f64, w: f64, h: f64) -> ViewBox {
            if !(w >= 0.0 && h >= 0.0) {
                {
                    ::rt::begin_panic(
                        "width and height must not be negative",
                        &("rsvg_internals/src/viewbox.rs", 14u32, 9u32),
                    )
                }
            };
            ViewBox(cairo::Rectangle {
                x,
                y,
                width: w,
                height: h,
            })
        }
    }
    impl Parse for ViewBox {
        type Data = ();
        type Err = AttributeError;
        fn parse(parser: &mut Parser, _: ()) -> Result<ViewBox, AttributeError> {
            let v = parsers::number_list(parser, ListLength::Exact(4))
                .map_err(|_| ParseError::new("string does not match \'x [,] y [,] w [,] h\'"))?;
            let (x, y, w, h) = (v[0], v[1], v[2], v[3]);
            if w >= 0.0 && h >= 0.0 {
                Ok(ViewBox(cairo::Rectangle {
                    x,
                    y,
                    width: w,
                    height: h,
                }))
            } else {
                Err(AttributeError::Value(
                    "width and height must not be negative".to_string(),
                ))
            }
        }
    }
}
mod viewport {
    use aspect_ratio::AspectRatio;
    use cairo;
    use cairo::MatrixTrait;
    use drawing_ctx::DrawingCtx;
    use float_eq_cairo::ApproxEqCairo;
    use node::RsvgNode;
    use state::ComputedValues;
    use viewbox::*;
    #[rustc_copy_clone_marker]
    pub enum ClipMode {
        ClipToViewport,
        ClipToVbox,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::fmt::Debug for ClipMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match (&*self,) {
                (&ClipMode::ClipToViewport,) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipToViewport");
                    debug_trait_builder.finish()
                }
                (&ClipMode::ClipToVbox,) => {
                    let mut debug_trait_builder = f.debug_tuple("ClipToVbox");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::marker::Copy for ClipMode {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::clone::Clone for ClipMode {
        #[inline]
        fn clone(&self) -> ClipMode {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::std::cmp::PartialEq for ClipMode {
        #[inline]
        fn eq(&self, other: &ClipMode) -> bool {
            {
                let __self_vi = unsafe { ::std::intrinsics::discriminant_value(&*self) } as isize;
                let __arg_1_vi = unsafe { ::std::intrinsics::discriminant_value(&*other) } as isize;
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    pub fn draw_in_viewport(
        vx: f64,
        vy: f64,
        vw: f64,
        vh: f64,
        clip_mode: ClipMode,
        do_clip: bool,
        vbox: Option<ViewBox>,
        preserve_aspect_ratio: AspectRatio,
        node: &RsvgNode,
        values: &ComputedValues,
        mut affine: cairo::Matrix,
        draw_ctx: &mut DrawingCtx,
        clipping: bool,
        draw_fn: &mut FnMut(&mut DrawingCtx),
    ) {
        if vw.approx_eq_cairo(&0.0) || vh.approx_eq_cairo(&0.0) {
            return;
        }
        draw_ctx.with_discrete_layer(
            node,
            values,
            clipping,
            &mut (|dc| {
                if do_clip && clip_mode == ClipMode::ClipToViewport {
                    dc.get_cairo_context().set_matrix(affine);
                    dc.clip(vx, vy, vw, vh);
                }
                if let Some(vbox) = vbox {
                    if vbox.0.width.approx_eq_cairo(&0.0) || vbox.0.height.approx_eq_cairo(&0.0) {
                        return;
                    }
                    dc.push_view_box(vbox.0.width, vbox.0.height);
                    let (x, y, w, h) =
                        preserve_aspect_ratio.compute(vbox.0.width, vbox.0.height, vx, vy, vw, vh);
                    affine.translate(x, y);
                    affine.scale(w / vbox.0.width, h / vbox.0.height);
                    affine.translate(-vbox.0.x, -vbox.0.y);
                    dc.get_cairo_context().set_matrix(affine);
                    if do_clip && clip_mode == ClipMode::ClipToVbox {
                        dc.clip(vbox.0.x, vbox.0.y, vbox.0.width, vbox.0.height);
                    }
                } else {
                    dc.push_view_box(vw, vh);
                    affine.translate(vx, vy);
                    dc.get_cairo_context().set_matrix(affine);
                }
                draw_fn(dc);
                dc.pop_view_box();
            }),
        );
    }
}
